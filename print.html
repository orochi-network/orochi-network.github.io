<!DOCTYPE HTML>
<html lang="en" class="light" dir="">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Orochi Network&#x27;s Cookbook</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <!-- SEO -->
        <meta name="description" content="Orochi Network applies Cryptography, ZKP, Multi Party Computation to create secure and scalable solutions for Blockchain, dApps, zkApps, Data, Custody, Computation and Daily life.">
        <meta property="og:title" content="Cookbook | Orochi Network">
        <meta property="og:description" content="Orochi Network applies Cryptography, ZKP, Multi Party Computation to create secure and scalable solutions for Blockchain, dApps, zkApps, Data, Custody, Computation and Daily life.">
        <meta property="og:image:type" content="image/png">
        <meta property="og:image:width" content="600">
        <meta property="og:image:height" content="315">
        <meta property="og:image" content="https://docs.orochi.network/assets/cookbook-facebook.png?v2">
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Cookbook | Orochi Network">
        <meta name="twitter:description" content="Orochi Network applies Cryptography, ZKP, Multi Party Computation to create secure and scalable solutions for Blockchain, dApps, zkApps, Data, Custody, Computation and Daily life.">
        <meta name="twitter:image:type" content="image/png">
        <meta name="twitter:image:width" content="800">
        <meta name="twitter:image:height" content="418">
        <meta name="twitter:image" content="https://docs.orochi.network/assets/cookbook-twitter.png?v2">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="orochi-network/orochi-network.html"><strong aria-hidden="true">1.</strong> What is Orochi Network?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="orochi-network/verifiable-data-pipeline.html"><strong aria-hidden="true">1.1.</strong> What is Verifiable Data Pipeline?</a></li><li class="chapter-item expanded "><a href="orochi-network/zk-data-rollups.html"><strong aria-hidden="true">1.2.</strong> What is ZK-data-rollups?</a></li><li class="chapter-item expanded "><a href="orochi-network/use-cases.html"><strong aria-hidden="true">1.3.</strong> Use cases</a></li><li class="chapter-item expanded "><a href="orochi-network/architecture.html"><strong aria-hidden="true">1.4.</strong> Architecture</a></li></ol></li><li class="chapter-item expanded "><a href="orochi-network/products.html"><strong aria-hidden="true">2.</strong> Products</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zkdatabase/chapter.html"><strong aria-hidden="true">2.1.</strong> zkDatabase</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zkdatabase/accumulation/accumulation.html"><strong aria-hidden="true">2.1.1.</strong> Accumulation</a></li><li class="chapter-item expanded "><a href="zkdatabase/b-tree/b-tree.html"><strong aria-hidden="true">2.1.2.</strong> B-Tree</a></li><li class="chapter-item expanded "><a href="zkdatabase/composability/composability.html"><strong aria-hidden="true">2.1.3.</strong> Composability</a></li><li class="chapter-item expanded "><a href="zkdatabase/serialization/serialization.html"><strong aria-hidden="true">2.1.4.</strong> Serialization</a></li><li class="chapter-item expanded "><a href="zkdatabase/data-collection/data-collection.html"><strong aria-hidden="true">2.1.5.</strong> Data Collection</a></li><li class="chapter-item expanded "><a href="zkdatabase/distributed-storage-engine/section.html"><strong aria-hidden="true">2.1.6.</strong> Distributed-Storage-Engine</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zkdatabase/distributed-storage-engine/ipfs.html"><strong aria-hidden="true">2.1.6.1.</strong> IPFS</a></li><li class="chapter-item expanded "><a href="zkdatabase/distributed-storage-engine/storage-engine.html"><strong aria-hidden="true">2.1.6.2.</strong> Storage-Engine</a></li></ol></li><li class="chapter-item expanded "><a href="zkdatabase/merkle-tree/merkle-tree.html"><strong aria-hidden="true">2.1.7.</strong> Merkle-Tree</a></li></ol></li><li class="chapter-item expanded "><a href="zk-memory/chapter.html"><strong aria-hidden="true">2.2.</strong> zkMemory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zk-memory/execution-trace/execution-trace.html"><strong aria-hidden="true">2.2.1.</strong> Execution Trace</a></li><li class="chapter-item expanded "><a href="zk-memory/commitment/commitment.html"><strong aria-hidden="true">2.2.2.</strong> Commitment Schemes</a></li><li class="chapter-item expanded "><a href="zk-memory/constraints/constraints.html"><strong aria-hidden="true">2.2.3.</strong> Memory Consistency Constraints</a></li><li class="chapter-item expanded "><a href="zk-memory/nova-variant/nova-variant.html"><strong aria-hidden="true">2.2.4.</strong> Nova Variants</a></li></ol></li><li class="chapter-item expanded "><a href="orochi-network/orand-orocle.html"><strong aria-hidden="true">2.3.</strong> Orand & Orocle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="orochi-network/orocle-v2.html"><strong aria-hidden="true">2.3.1.</strong> Orocle V2</a></li><li class="chapter-item expanded "><a href="orochi-network/orand-v3.html"><strong aria-hidden="true">2.3.2.</strong> Orand V3</a></li><li class="chapter-item expanded "><a href="orochi-network/contract-integration.html"><strong aria-hidden="true">2.3.3.</strong> Orand Contract Integration</a></li><li class="chapter-item expanded "><a href="orochi-network/api-reference.html"><strong aria-hidden="true">2.3.4.</strong> API Reference</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ecvrf/verifiable-random-function.html"><strong aria-hidden="true">3.</strong> Verifiable Random Function (VRF)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecvrf/ecvrf-summary/overview-of-vrf.html"><strong aria-hidden="true">3.1.</strong> Overview of VRF</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecvrf/ecvrf-summary/introduction.html"><strong aria-hidden="true">3.1.1.</strong> Introduction to VRF</a></li><li class="chapter-item expanded "><a href="ecvrf/ecvrf-summary/vrf-syntax.html"><strong aria-hidden="true">3.1.2.</strong> VRF Algorithms</a></li><li class="chapter-item expanded "><a href="ecvrf/ecvrf-summary/vrf-properties.html"><strong aria-hidden="true">3.1.3.</strong> VRF Security Properties</a></li><li class="chapter-item expanded "><a href="ecvrf/ecvrf-summary/vrf-history.html"><strong aria-hidden="true">3.1.4.</strong> History of VRF</a></li></ol></li><li class="chapter-item expanded "><a href="ecvrf/ecvrf-construction/vrf-based-on-elliptic-curve.html"><strong aria-hidden="true">3.2.</strong> VRF Based on Elliptic Curve (ECVRF)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecvrf/ecvrf-construction/why-using-ecvrf.html"><strong aria-hidden="true">3.2.1.</strong> Why using ECVRF</a></li><li class="chapter-item expanded "><a href="ecvrf/ecvrf-construction/ecvrf-construction.html"><strong aria-hidden="true">3.2.2.</strong> ECVRF Construction</a></li><li class="chapter-item expanded "><a href="ecvrf/ecvrf-construction/ecvrf-auxiliary-function.html"><strong aria-hidden="true">3.2.3.</strong> ECVRF Auxiliary Function</a></li><li class="chapter-item expanded "><a href="ecvrf/ecvrf-construction/implementation-python.html"><strong aria-hidden="true">3.2.4.</strong> Implementation</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="dkg/dkg.html"><strong aria-hidden="true">4.</strong> Distributed Key Generation (DKG)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dkg/dkg-summary/chapter.html"><strong aria-hidden="true">4.1.</strong> Overview of DKG</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dkg/dkg-summary/dkg-properties.html"><strong aria-hidden="true">4.1.1.</strong> DKG Properties</a></li><li class="chapter-item expanded "><a href="dkg/dkg-summary/dkg-application.html"><strong aria-hidden="true">4.1.2.</strong> DKG Application</a></li></ol></li><li class="chapter-item expanded "><a href="dkg/verifiable-secret-sharing/chapter.html"><strong aria-hidden="true">4.2.</strong> Verifiable Secret Sharing (VSS)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dkg/verifiable-secret-sharing/introduction.html"><strong aria-hidden="true">4.2.1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="dkg/verifiable-secret-sharing/syntax.html"><strong aria-hidden="true">4.2.2.</strong> Syntax and Properties</a></li><li class="chapter-item expanded "><a href="dkg/verifiable-secret-sharing/pedersen-construction.html"><strong aria-hidden="true">4.2.3.</strong> Pedersen's Construction</a></li></ol></li><li class="chapter-item expanded "><a href="dkg/dkg-construction/chapter.html"><strong aria-hidden="true">4.3.</strong> Construction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dkg/dkg-construction/why-gennaro.html"><strong aria-hidden="true">4.3.1.</strong> Why Gennaro et al's Construction?</a></li><li class="chapter-item expanded "><a href="dkg/dkg-construction/dkg-construction.html"><strong aria-hidden="true">4.3.2.</strong> Gennaro et al's Construction</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="threshold-ecdsa/chapter.html"><strong aria-hidden="true">5.</strong> Threshold Signature</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threshold-ecdsa/threshold-ecdsa-introduction/introduction.html"><strong aria-hidden="true">5.1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="threshold-ecdsa/threshold-ecdsa-introduction/definition.html"><strong aria-hidden="true">5.2.</strong> Definition and Security</a></li><li class="chapter-item expanded "><a href="threshold-ecdsa/threshold-ecdsa-construction/introduction.html"><strong aria-hidden="true">5.3.</strong> Canneti et al 's Construction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/keygen.html"><strong aria-hidden="true">5.3.1.</strong> Key Generation</a></li><li class="chapter-item expanded "><a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/sign.html"><strong aria-hidden="true">5.3.2.</strong> Signing</a></li><li class="chapter-item expanded "><a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/verify.html"><strong aria-hidden="true">5.3.3.</strong> Verification</a></li><li class="chapter-item expanded "><a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/supporting-algorithms.html"><strong aria-hidden="true">5.3.4.</strong> Supporting Algorithms</a></li><li class="chapter-item expanded "><a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/abort-identification.html"><strong aria-hidden="true">5.3.5.</strong> Identifying Aborts</a></li><li class="chapter-item expanded "><a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/security-consideration.html"><strong aria-hidden="true">5.3.6.</strong> Security Consideration</a></li></ol></li><li class="chapter-item expanded "><a href="threshold-ecdsa/frost-construction/introduction.html"><strong aria-hidden="true">5.4.</strong> FROST's Construction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threshold-ecdsa/frost-construction/keygen.html"><strong aria-hidden="true">5.4.1.</strong> Key Generation</a></li><li class="chapter-item expanded "><a href="threshold-ecdsa/frost-construction/sign.html"><strong aria-hidden="true">5.4.2.</strong> Signing</a></li><li class="chapter-item expanded "><a href="threshold-ecdsa/frost-construction/verify.html"><strong aria-hidden="true">5.4.3.</strong> Verification</a></li><li class="chapter-item expanded "><a href="threshold-ecdsa/frost-construction/supporting-algorithms.html"><strong aria-hidden="true">5.4.4.</strong> Supporting Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="threshold-ecdsa/intended-implementation/our-intended-implementation.html"><strong aria-hidden="true">5.5.</strong> Implementation Guideline</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threshold-ecdsa/intended-implementation/threshold-ecdsa-for-secp256k1.html"><strong aria-hidden="true">5.5.1.</strong> Threshold signature using secp256k1 parameters</a></li><li class="chapter-item expanded "><a href="threshold-ecdsa/intended-implementation/threshold-eddsa-for-ed25519.html"><strong aria-hidden="true">5.5.2.</strong> Threshold signature using ed25519 parameters</a></li><li class="chapter-item expanded "><a href="threshold-ecdsa/intended-implementation/threshold-eddsa-for-sr25519.html"><strong aria-hidden="true">5.5.3.</strong> Threshold signature using sr25519 parameters</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="isogeny-based-crypto/chapter.html"><strong aria-hidden="true">6.</strong> Isogeny Based Crypto</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="isogeny-based-crypto/supersingular-isogeny-graph/chapter.html"><strong aria-hidden="true">6.1.</strong> Overview of Supersingular Isogeny Graph</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="isogeny-based-crypto/supersingular-isogeny-graph/background/elliptic-curve.html"><strong aria-hidden="true">6.1.1.</strong> Elliptic Curves</a></li><li class="chapter-item expanded "><a href="isogeny-based-crypto/supersingular-isogeny-graph/background/isogeny.html"><strong aria-hidden="true">6.1.2.</strong> Isogenies</a></li><li class="chapter-item expanded "><a href="isogeny-based-crypto/supersingular-isogeny-graph/background/supersingular-elliptic-curve.html"><strong aria-hidden="true">6.1.3.</strong> Supersingular Elliptic Curves</a></li><li class="chapter-item expanded "><a href="isogeny-based-crypto/supersingular-isogeny-graph/graph/supersingular-isogeny-graph.html"><strong aria-hidden="true">6.1.4.</strong> Supersingular Isogeny Graph (Pizer Graphs)</a></li><li class="chapter-item expanded "><a href="isogeny-based-crypto/supersingular-isogeny-graph/graph/application.html"><strong aria-hidden="true">6.1.5.</strong> Applications of Pizer Graphs</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="kzg-polynomial-commitment-scheme/chapter.html"><strong aria-hidden="true">7.</strong> KZG Polynomial Commitment Scheme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kzg-polynomial-commitment-scheme/pcs-definition/section.html"><strong aria-hidden="true">7.1.</strong> Polynomial Commitment Scheme - Definition</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kzg-polynomial-commitment-scheme/pcs-definition/syntax.html"><strong aria-hidden="true">7.1.1.</strong> Syntax</a></li><li class="chapter-item expanded "><a href="kzg-polynomial-commitment-scheme/pcs-definition/security-requirement.html"><strong aria-hidden="true">7.1.2.</strong> Security Requirements</a></li></ol></li><li class="chapter-item expanded "><a href="kzg-polynomial-commitment-scheme/technical-overview/section.html"><strong aria-hidden="true">7.2.</strong> Technical Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kzg-polynomial-commitment-scheme/technical-overview/commitment-without-hiding.html"><strong aria-hidden="true">7.2.1.</strong> Commitment to Polynomial Without Hiding Property</a></li><li class="chapter-item expanded "><a href="kzg-polynomial-commitment-scheme/technical-overview/correct-evaluation-from-commitment.html"><strong aria-hidden="true">7.2.2.</strong> Correct Evaluation from the Commitment</a></li><li class="chapter-item expanded "><a href="kzg-polynomial-commitment-scheme/technical-overview/dealing-with-hiding.html"><strong aria-hidden="true">7.2.3.</strong> Dealing with Hiding</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="plonk/chapter.html"><strong aria-hidden="true">8.</strong> PlonK</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="plonk/arithmetization/section.html"><strong aria-hidden="true">8.1.</strong> PlonK's Arithmetization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="plonk/arithmetization/circuit-specification.html"><strong aria-hidden="true">8.1.1.</strong> Circuit Specification</a></li><li class="chapter-item expanded "><a href="plonk/arithmetization/breaking-circuit.html"><strong aria-hidden="true">8.1.2.</strong> Breaking Circuit</a></li><li class="chapter-item expanded "><a href="plonk/arithmetization/gate-constraints.html"><strong aria-hidden="true">8.1.3.</strong> Gate Constraints</a></li><li class="chapter-item expanded "><a href="plonk/arithmetization/copy-constraints.html"><strong aria-hidden="true">8.1.4.</strong> Copy Constraints</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="halo2-for-dummies/chapter.html"><strong aria-hidden="true">9.</strong> Halo 2 for Dummies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="halo2-for-dummies/plonkish/section.html"><strong aria-hidden="true">9.1.</strong> PLONKish Arithemetization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="halo2-for-dummies/plonkish/simple-arithmetic-circuit.html"><strong aria-hidden="true">9.1.1.</strong> A Simple Arithmetic Circuit</a></li><li class="chapter-item expanded "><a href="halo2-for-dummies/plonkish/transforming-to-plonkish-arithmetization.html"><strong aria-hidden="true">9.1.2.</strong> Transforming to PLONKish Arithmetization</a></li></ol></li><li class="chapter-item expanded "><a href="halo2-for-dummies/simple-example/section.html"><strong aria-hidden="true">9.2.</strong> A Simple Halo 2 Program</a></li></ol></li><li class="chapter-item expanded "><a href="verifiable-delay-functions/chapter.html"><strong aria-hidden="true">10.</strong> Verifiable Delay Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="verifiable-delay-functions/vdf-summary/introduction.html"><strong aria-hidden="true">10.1.</strong> Introduction to VDF</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="verifiable-delay-functions/vdf-summary/definition.html"><strong aria-hidden="true">10.1.1.</strong> VDF Algorithms</a></li><li class="chapter-item expanded "><a href="verifiable-delay-functions/vdf-summary/properties.html"><strong aria-hidden="true">10.1.2.</strong> VDF Properties</a></li><li class="chapter-item expanded "><a href="verifiable-delay-functions/vdf-summary/application.html"><strong aria-hidden="true">10.1.3.</strong> VDF Applications</a></li></ol></li><li class="chapter-item expanded "><a href="verifiable-delay-functions/vdf-candidates/existing-construction.html"><strong aria-hidden="true">10.2.</strong> A survey of VDF constructions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="verifiable-delay-functions/vdf-candidates/squaring-construction.html"><strong aria-hidden="true">10.2.1.</strong> Modular Square Root based Construction</a></li><li class="chapter-item expanded "><a href="verifiable-delay-functions/vdf-candidates/rsa-time-lock-construction.html"><strong aria-hidden="true">10.2.2.</strong> Group of Unknown Order based Construction</a></li><li class="chapter-item expanded "><a href="verifiable-delay-functions/vdf-candidates/isogeny-construction.html"><strong aria-hidden="true">10.2.3.</strong> Isogeny based Construction</a></li><li class="chapter-item expanded "><a href="verifiable-delay-functions/vdf-candidates/comparision.html"><strong aria-hidden="true">10.2.4.</strong> Comparision</a></li><li class="chapter-item expanded "><a href="verifiable-delay-functions/vdf-candidates/vc-based-construction.html"><strong aria-hidden="true">10.2.5.</strong> Possible IVC based Construction</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="poseidon-hash/chapter.html"><strong aria-hidden="true">11.</strong> Poseidon hash for ZK Applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="poseidon-hash/cryptographic-sponge-function/cryptographic-sponge-function.html"><strong aria-hidden="true">11.1.</strong> Cryptographic sponge functions</a></li><li class="chapter-item expanded "><a href="poseidon-hash/poseidon-hash-overview/poseidon-hash-overview.html"><strong aria-hidden="true">11.2.</strong> Overview of Poseidon Hash Function</a></li><li class="chapter-item expanded "><a href="poseidon-hash/poseidon-permutation-design/section.html"><strong aria-hidden="true">11.3.</strong> Poseidon permutation design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="poseidon-hash/poseidon-permutation-design/hades-design-strategy.html"><strong aria-hidden="true">11.3.1.</strong> Hades design strategy</a></li><li class="chapter-item expanded "><a href="poseidon-hash/poseidon-permutation-design/hades-based-design.html"><strong aria-hidden="true">11.3.2.</strong> Hades-based permutation design</a></li><li class="chapter-item expanded "><a href="poseidon-hash/poseidon-permutation-design/concrete-poseidon-instantiation.html"><strong aria-hidden="true">11.3.3.</strong> Concrete Poseidon permutation instantiation</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="orochi-network/orocle-v1.html"><strong aria-hidden="true">12.</strong> Deprecated</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="orochi-network/orocle-v1.html"><strong aria-hidden="true">12.1.</strong> Orocle V1 (deprecated)</a></li><li class="chapter-item expanded "><a href="orochi-network/orand-v2.html"><strong aria-hidden="true">12.2.</strong> Orand V2 (deprecated)</a></li><li class="chapter-item expanded "><a href="orochi-network/sdk.html"><strong aria-hidden="true">12.3.</strong> Orochi Network SDK</a></li><li class="chapter-item expanded "><a href="orochi-network/code-integration.html"><strong aria-hidden="true">12.4.</strong> Orand Code Integration</a></li></ol></li><li class="chapter-item expanded "><a href="bibliography.html">Bibliography</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Orochi Network&#x27;s Cookbook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p align="center">
    <img src="orochi-network/../assets/orochi-network.png" alt="Orochi Network">
</p>
<h1 id="what-is-orochi-network"><a class="header" href="#what-is-orochi-network">What is Orochi Network?</a></h1>
<ul>
<li><a href="orochi-network/orochi-network.html#introduction">Introduction</a></li>
<li><a href="orochi-network/orochi-network.html#challenges">Challenges</a>
<ul>
<li><a href="orochi-network/orochi-network.html#data-integrity">Data Integrity</a></li>
<li><a href="orochi-network/orochi-network.html#data-availability">Data Availability</a></li>
<li><a href="orochi-network/orochi-network.html#interoperability">Interoperability</a></li>
<li><a href="orochi-network/orochi-network.html#scalability">Scalability</a></li>
</ul>
</li>
<li><a href="orochi-network/orochi-network.html#our-solutions">Our Solutions</a>
<ul>
<li><a href="orochi-network/orochi-network.html#orochi-network-verifiable-data-infrastructure">Orochi Network: Verifiable Data Infrastructure</a></li>
</ul>
</li>
<li><a href="orochi-network/orochi-network.html#token-utilities">Token Utilities</a>
<ul>
<li><a href="orochi-network/orochi-network.html#1incentivizing-validators">1.Incentivizing Validators</a></li>
<li><a href="orochi-network/orochi-network.html#2distributed-storage">2.Distributed Storage</a></li>
<li><a href="orochi-network/orochi-network.html#3rewarding-zk-sequencers">3.Rewarding ZK Sequencers</a></li>
<li><a href="orochi-network/orochi-network.html#4transaction-fees">4.Transaction Fees</a></li>
</ul>
</li>
<li><a href="orochi-network/orochi-network.html#the-future-of-web3">The Future of Web3</a></li>
</ul>
<p><strong>Orochi Network</strong> is a <strong>Verifiable Data Infrastructure</strong> designed to ensure data integrity and privacy through advanced cryptographic techniques. Orochi Network provides a secure infrastructure for processing and proving data without compromising confidentiality. This combination of cutting-edge cryptographic primitives allows users to trust the system’s outputs while keeping sensitive information protected, making it a powerful solution for applications requiring both transparency and privacy.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p><strong>Orochi Network</strong> is an innovative <strong>Verifiable Data Infrastructure</strong> that redefines how data is handled in the digital age. Built on the principles of security and trustless, it utilizes advanced cryptographic tools like <strong>Zero-Knowledge Proofs (ZKP)</strong>, <strong>Fully Homomorphic Encryption (FHE)</strong>, and <strong>Trusted Execution Environments (TEE)</strong> to guarantee data integrity and privacy. Whether for businesses, developers, or individuals, Orochi Network offers a robust platform where data can be processed and verified securely, ensuring transparency without sacrificing confidentiality. It’s a forward-thinking solution for a world increasingly reliant on trustworthy and private data systems.</p>
<p>At the core of Orochi Network lies its <strong>Verifiable Data Pipeline</strong> and <strong>ZK-Data-Rollups</strong>, two pivotal components that elevate data integrity to new heights. The Verifiable Data Pipeline ensures that every step of data processing is transparent and tamper-proof, while ZK-Data-Rollups harness Zero-Knowledge Proofs to compress and validate data efficiently without revealing sensitive details. Together, these innovations provide a robust foundation for secure, scalable, and privacy-preserving data management, making Orochi Network a trailblazer in delivering trust and reliability in the digital ecosystem.</p>
<pre class="mermaid">%%{init: {'theme':'neutral'}}%%
flowchart TD
    A[Orochi Network] --&gt; B[Real World Data]
    C[zkVM] --&gt; A
    D[zkML/AI] --&gt; A
    E[zkApp/dApp] --&gt; A
    F[Fintech/DeFi] --&gt; A
    G[Blockchain] --&gt; A
    H[IoT/DePIN] --&gt; A
    J[ID/KYC] --&gt; A
</pre>
<p align="center">
    </br><b>Figure 1:</b> Orochi Network turn <b>data</b> to <b>verifiable data</b>, and operating as the backbone of the new internet
</p>
<h2 id="challenges"><a class="header" href="#challenges">Challenges</a></h2>
<h3 id="data-integrity"><a class="header" href="#data-integrity">Data Integrity</a></h3>
<p>In a truly decentralized Web3 ecosystem, data integrity would be ensured through a distributed network of aggregators. Each node could independently prove the correctness of data using cryptographic protocols.</p>
<p>However, many Web3 solutions today still rely on oracles, which are fundamentally flawed and unable to guarantee data authenticity. Consequently, smart contracts are often unable to confirm the legitimacy of third-party provided data. This vulnerability leads to potential losses and fraudulent activities.</p>
<h3 id="data-availability"><a class="header" href="#data-availability">Data Availability</a></h3>
<p>Smart contracts run in an isolated environment, such as the EVM or WASM runtime on the blockchain. While this isolation allow smart contract to be executed seamlessly regardless the differences of the architecture, it also limits their ability to directly interact with external data sources, like those in the real world.</p>
<p>Additionally, as the number of users and transactions on a blockchain network grows, storing and accessing all data on-chain becomes increasingly impractical and costly.</p>
<h3 id="interoperability"><a class="header" href="#interoperability">Interoperability</a></h3>
<p>Interoperability is a critical aspect of any decentralized Web3 ecosystem. However, many existing solutions struggle with interoperability due to the lack of standardization and compatibility between different architectures.</p>
<p>Existing DA Layer solution is just a combination of blockchain and commitment schemes and it is failed to prove the DA state to on-chain contracts in a single succinct proof.</p>
<h3 id="scalability"><a class="header" href="#scalability">Scalability</a></h3>
<p>Nowadays DA Layers are leveraging existing technical stack that mean they are also inherits issues of existing blockchains, namely finality and scalability. They can not deallocate resource that store on their system and unable to reach instant finality with BFT consensus.</p>
<h2 id="our-solutions"><a class="header" href="#our-solutions">Our Solutions</a></h2>
<h3 id="orochi-network-verifiable-data-infrastructure"><a class="header" href="#orochi-network-verifiable-data-infrastructure">Orochi Network: Verifiable Data Infrastructure</a></h3>
<p>Orochi Network positions as the first Verifiable Data Infrastructure, emphasizing the use of ZKPs for secure and verifiable data processing. This focus on ZKPs caters to applications, platforms requiring high levels of privacy, security and decentralized. Here's a breakdown of our key features and potential of our ZKP centric approach:</p>
<ul>
<li><strong>Native ZK-data-rollups:</strong> Unlike other DA Layers, Orochi Network natively supports ZKPs and perform the rollups on the data. This allows for efficient on-chain verification of data with one single succinct proof, this approach potentially improving scalability and privacy for decentralized applications.</li>
<li><strong>Verifiable Data Pipeline:</strong> Orochi Network goes beyond just data availability. We offers cryptographic proofs at every step of data processing – from sampling to storage and retrieval. Our solution is only reply on cryptography protocols that helps to take down third party trust and helping to transform <strong>Real World Data</strong> to <strong>Provable Data</strong> which can be read and verified by smart contracts.</li>
<li><strong>Utilizes Merkle Directed Acyclic Graph (Merkle DAG):</strong> Orochi Network leverages Merkle DAG technology, potentially offering advantages over traditional blockchain structures in terms of scalability and performance.</li>
<li><strong>Succinct Hybrid aBFT Consensus:</strong> This consensus mechanism allows for asynchronous finalization of states, potentially improving efficiency compared to synchronous approaches used by some competitors.</li>
<li><strong>Proof-System Agnostic:</strong> Orochi Network can work with various ZKP systems like Plonky3, Halo2, Nova, and Pickles, offering developers flexibility in choosing the most suitable proof system for their needs.</li>
<li><strong>Blockchain Agnostic:</strong> Orochi Network is designed to be blockchain-agnostic by leveraging ZKPs to improve interoperability between different blockchains, potentially enabling integration with diverse blockchain platforms.</li>
</ul>
<h2 id="token-utilities"><a class="header" href="#token-utilities">Token Utilities</a></h2>
<p>The native token of Orochi Network, referred to as $ON, serves as the cornerstone of its Verifiable Data Infrastructure, enabling a secure and efficient ecosystem. The token fulfills several critical functions, outlined below:</p>
<h3 id="1incentivizing-validators"><a class="header" href="#1incentivizing-validators">1.Incentivizing Validators</a></h3>
<p>Validators ensure the network’s security and integrity by staking $ON to participate in the consensus process. They are rewarded with $ON based on their contributions, fostering a reliable and decentralized system.</p>
<h3 id="2distributed-storage"><a class="header" href="#2distributed-storage">2.Distributed Storage</a></h3>
<p>Users can utilize $ON to lease space on Orochi’s distributed storage network, supporting secure and verifiable data management. Fees compensate providers who maintain this infrastructure.</p>
<h3 id="3rewarding-zk-sequencers"><a class="header" href="#3rewarding-zk-sequencers">3.Rewarding ZK Sequencers</a></h3>
<p>Zero-Knowledge (ZK) sequencers, responsible for processing transactions and ensuring privacy, receive $ON as compensation for their computational efforts, enhancing network scalability.</p>
<h3 id="4transaction-fees"><a class="header" href="#4transaction-fees">4.Transaction Fees</a></h3>
<p>$ON is used to cover fees for transactions and network interactions, ensuring operational sustainability while providing access to Orochi’s advanced features.</p>
<p><em>Through these utilities, $ON drives participation and sustains the Orochi Network, aligning the interests of validators, storage providers, sequencers, and users within a robust economic framework.</em></p>
<h2 id="the-future-of-web3"><a class="header" href="#the-future-of-web3">The Future of Web3</a></h2>
<p>Our <strong>Verifiable Data Infrastructure</strong> is a promising step towards a more secure, scalable, and user-friendly Web3. By leveraging the power of Zero-Knowledge Proofs, our Verifiable Data Infrastructure offers solutions to some of the most pressing challenges facing the decentralized future of the internet. As Verifiable Data Infrastructure continues to evolve, it has the potential to be a game-changer for Web3, ushering in a new era of innovation and user adoption.</p>
<p>In essence, our suite of products, anchored by the innovative Verifiable Data Infrastructure, lays the groundwork for a future web built on secure, scalable, and user-friendly decentralized applications. By addressing the limitations of current dApps, Orochi Network has the potential to unlock the true potential of Web3, paving the way for a more decentralized and empowering online experience for everyone. The promise of Orochi Network has been recognized by leading organizations within the blockchain space. Orochi Network is a grantee of the <strong>Ethereum Foundation</strong>, <strong>Web3 Foundation</strong>, <strong>Mina Protocol</strong>, and <strong>Aleo</strong>. This recognition underscores the potential of our technology to shape the future of Web3.</p>
<p><em>built with ❤️ and 🦀</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verifiable-data-pipeline"><a class="header" href="#verifiable-data-pipeline">Verifiable Data Pipeline</a></h1>
<p>Our <strong>Verifiable Data Pipeline</strong> introduces a groundbreaking concept poised to supplant traditional Oracle systems, delivering unparalleled security and reliability. Unlike conventional approaches, it employs proof composition to ensure that every stage of data handling—sampling, processing, lookup, and transformation—is cryptographically verified. This innovative mechanism guarantees that data remains trustworthy and intact throughout its journey, offering a robust alternative to legacy solutions. By redefining how data integrity is maintained, our <strong>Verifiable Data Pipeline</strong> sets a new standard for secure and dependable data management within the Orochi Network.</p>
<pre class="mermaid">%%{init: {'theme':'neutral'}}%%
flowchart TD
    A[Real World Data] --&gt;|Raw Data| B[Verifiable Sampling]
    B --&gt; |Sampled Data| C[Verifiable Processing]
    C --&gt; |Stuctured Data| D[Immutable Storage]
    D --&gt; |Retrieve Data| E[Lookup Prover]
    E --&gt; |Verify Data| F[ZK Applications]
    F --&gt; |Update| G[Transforming Prover]
    G --&gt; |Proof of Transformation|D
</pre>
<p align="center">
    </br><b>Figure 1:</b> Verifibable Data Pipeline
</p>
<p>Verifiable Data Pipeline delivers significant value by proving every step of data processing, ensuring verifiable data through the use of Zero-Knowledge Proofs (ZKP) and recursive proofs. This approach guarantees data integrity and authenticity while safeguarding privacy and enabling scalability, meeting the demands of a data-centric landscape.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zk-data-rollups"><a class="header" href="#zk-data-rollups">ZK-data-rollups</a></h1>
<p><strong>ZK-data-dollups</strong>, a key component of <strong>Orochi Network</strong>, build on the proven ZK-Rollups, widely used to enhance scalability in Layer 2 solutions across Web3. By adapting this approach, ZK-Data-Rollups deliver both security and cost-efficient verification, compressing data's proofs into succinct, cryptographically verified proofs without compromising privacy. This design mirrors the efficiency and trust that ZK-Rollups bring to blockchain transactions, making ZK-data-rollups an ideal solution for secure, low-cost data handling in the Web3 ecosystem, further solidifying Orochi Network’s commitment to innovation and reliability.</p>
<p align="center">
    <img src="orochi-network/../assets/orochi-network/ZK-data-rollups-1.jpg" alt="ZK-data-rollups">
    </br><b>Figure 1:</b> ZK-data-rollups circuit
</p>
<p>Within ZK-Data-Rollups, each step of data transformation is proven with a Zero-Knowledge Proof (ZKP), ensuring that every stage is secure and verifiable without revealing the data itself. Unlike a single cooperative proof, each ZKP is carried forward and included in the next step of the process, creating a chained sequence of proofs. This step-by-step integration enhances security and maintains rigorous integrity throughout the data transformation pipeline, delivering a highly secure and efficient solution tailored for Web3 applications.</p>
<p align="center">
    <img src="orochi-network/../assets/orochi-network/ZK-data-rollups-2.jpg" alt="ZK-data-rollups">
    </br><b>Figure 2:</b> Proof composistion
</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h1>
<ul>
<li><a href="orochi-network/use-cases.html#artificial-intelligence-and-machine-learning">Artificial Intelligence and Machine Learning</a></li>
<li><a href="orochi-network/use-cases.html#internet-of-things">Internet of Things</a></li>
<li><a href="orochi-network/use-cases.html#real-world-asset-tokenization">Real-World Asset Tokenization</a></li>
<li><a href="orochi-network/use-cases.html#supply-chain-and-provenance-tracking">Supply Chain and Provenance Tracking</a></li>
<li><a href="orochi-network/use-cases.html#cross-chain-interoperability">Cross-Chain Interoperability</a></li>
<li><a href="orochi-network/use-cases.html#gaming-and-metaverse">Gaming and Metaverse</a></li>
</ul>
<p><strong>Verifiable Data Pipeline</strong> and <strong>ZK-Data-Rollups</strong> provide a robust foundation for proving data authenticity and processing it securely across various applications. Below are possible use cases of Orochi Network:</p>
<h2 id="artificial-intelligence-and-machine-learning"><a class="header" href="#artificial-intelligence-and-machine-learning">Artificial Intelligence and Machine Learning</a></h2>
<p>Orochi Network transforms Artificial Intelligence (AI) and Machine Learning (ML) by ensuring the integrity and trustworthiness of training datasets and model outputs. Zero-Knowledge Proofs (ZKP) cryptographically prove that data used for training—such as medical records or financial histories—remains untampered and accurate, while Fully Homomorphic Encryption (FHE) enables privacy-preserving computations across collaborative parties. This allows organizations to validate model integrity and predictions without exposing sensitive inputs, fostering trust in critical applications like autonomous systems or diagnostics. By embedding verifiable proofs, Orochi enhances accountability and reliability in AI/ML, paving the way for secure, transparent innovation.</p>
<h2 id="internet-of-things"><a class="header" href="#internet-of-things">Internet of Things</a></h2>
<p>Orochi Network guarantees that data from IoT devices—such as smart meters, sensors, or industrial equipment—is processed and transmitted tamper-proof. It's also enable efficient validation and compression of massive IoT datasets, making real-time applications like energy trading, traffic management, or smart city operations both scalable and trustworthy.</p>
<h2 id="real-world-asset-tokenization"><a class="header" href="#real-world-asset-tokenization">Real-World Asset Tokenization</a></h2>
<p>Orochi Network ensures that critical asset data—such as ownership titles, valuations, or transaction histories—is cryptographically verified from source to consumption, preventing fraud and ensuring transparency without compromising sensitive details. ZK-Data-Rollups further enhance scalability by compressing large datasets into succinct proofs, enabling efficient on-chain processing. This makes tokenized assets reliable and accessible across decentralized ecosystems, facilitating seamless trading, fractional ownership, and cross-border transactions while bridging traditional finance with Web3 innovation.</p>
<h2 id="supply-chain-and-provenance-tracking"><a class="header" href="#supply-chain-and-provenance-tracking">Supply Chain and Provenance Tracking</a></h2>
<p>Orochi Network ensures transparency and trust by verifying the journey of goods from origin to end consumer. We prove the authenticity of critical data—such as sourcing details, manufacturing records, and shipping logs—without revealing proprietary information, preventing counterfeiting and fraud. This system efficiently validates large datasets, enabling scalable tracking of products like luxury goods, pharmaceuticals, or raw materials across decentralized networks. By providing tamper-proof provenance, Orochi Network enhances consumer confidence, supports regulatory compliance, and empowers businesses to demonstrate sustainability or ethical practices with verifiable evidence.</p>
<h2 id="cross-chain-interoperability"><a class="header" href="#cross-chain-interoperability">Cross-Chain Interoperability</a></h2>
<p>Verifiable Data enhances trust and efficiency by enabling seamless data exchange between disparate blockchain networks, such as Ethereum and BNB Chain. By providing a standardized, provable format, it eliminates the need for resource-intensive validation processes on each chain, reduces the risk of data inconsistencies, and ensures that smart contracts across blockchains can rely on accurate, untampered inputs—ultimately fostering a more connected and scalable Web3 landscape.</p>
<h2 id="gaming-and-metaverse"><a class="header" href="#gaming-and-metaverse">Gaming and Metaverse</a></h2>
<p>In the realm of Gaming and the Metaverse, Orochi Network enhances trust and scalability for decentralized experiences. Through Orand’s verifiable randomness, it ensures fairness in blockchain-based games by delivering unbiased outcomes for loot drops, matchmaking, and prize distributions, fostering player confidence. We're also able to prove ownership and transaction histories of in-game assets or NFTs, safeguarding players from fraud while preserving privacy. Additionally, by efficiently processing massive virtual world datasets—such as user interactions and events—through compressed, verifiable proofs, it maintains data integrity across decentralized platforms, enabling a seamless and trustworthy Metaverse ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<ul>
<li><a href="orochi-network/architecture.html#component-view">Component View</a>
<ul>
<li><a href="orochi-network/architecture.html#verifiable-data-pipeline">Verifiable Data Pipeline</a></li>
<li><a href="orochi-network/architecture.html#distributred-storage">Distributred Storage</a></li>
<li><a href="orochi-network/architecture.html#succinct-abft-consensus">Succinct aBFT Consensus</a></li>
</ul>
</li>
<li><a href="orochi-network/architecture.html#zk-centric-approach">ZK-Centric Approach</a></li>
</ul>
<h2 id="component-view"><a class="header" href="#component-view">Component View</a></h2>
<p>We provides robust support for a wide range of commitment schemes and proof systems, making it a standout in secure data infrastructure. It leverages schemes like Merkle trees and polynomial commitments to ensure efficient and verifiable data handling. Additionally, Orochi Network integrates advanced Zero-Knowledge Proof (ZKP) systems such as Halo2, Pickles, ZK-STARK, and Plonky3, offering features like succinctness, scalability, and even post-quantum security. This versatility enhances privacy, interoperability, and efficiency, positioning Orochi Network as a powerful solution for blockchain ecosystems and decentralized applications requiring cutting-edge cryptographic tools.</p>
<p align="center">
    <img src="orochi-network/../assets/orochi-network/orochi-network-architecture.png" alt="ZK-data-rollups">
    </br><b>Figure 1:</b> Orochi Network Architecture
</p>
<h3 id="verifiable-data-pipeline-1"><a class="header" href="#verifiable-data-pipeline-1">Verifiable Data Pipeline</a></h3>
<p>Orochi Network goes beyond just data availability. Its verifiable data pipeline offers cryptographic proofs at every step of data processing – from sampling to storage and retrieval. This level of verifiability enhances trust and transparency within blockchain applications.</p>
<ul>
<li><strong>Verifiable Sampling</strong> proves a data sample’s authenticity from an endpoint (e.g., blockchain, API or database). A prover generates a succinct proof to confirm the sample’s integrity (TLS certificate verification) and adherence to a sampling algorithm.</li>
<li><strong>Verifiable Processing</strong> is a subsequent step after <strong>Verifiable Sampling</strong>, it proves that raw data has been accurately transformed into structured data per a defined algorithm.</li>
<li><strong>Lookup Prove</strong> proves the correctness of a lookup operation over a BTree while linking it to a proof of membership in a commitment scheme, such as a Merkle tree. It ensures that a specific key-value pair retrieved from the BTree exists within the committed dataset, generating a succinct proof that verifies both the lookup’s accuracy and the data’s inclusion.</li>
<li><strong>Transformation Prover</strong> proves the correctness of data updates and schema transformations. It ensures that data record is accurately modified—such as through insertions, deletions, or format changes—and aligns with a predefined schema, producing a ZKP tied to a commitment scheme like a Merkle root.</li>
</ul>
<h3 id="distributred-storage"><a class="header" href="#distributred-storage">Distributred Storage</a></h3>
<p>Here’s a concise introduction to the three components of Distributed Storage:</p>
<ul>
<li><strong>Merkle DAG (Directed Acyclic Graph)</strong> A hierarchical structure of hashed nodes that enables content-addressable storage, linking data via cryptographic hashes to ensure integrity and efficient retrieval across distributed systems, with each node verifying its subtree.</li>
<li><strong>Commitment Schemes</strong> Cryptographic tools, like Merkle trees or polynomial commitments, that bind data to a single value (e.g., a root hash), allowing provers to confirm authenticity or membership without exposing the full dataset, ensuring trust in a compact form.</li>
<li><strong>ZK-Data-Rollups</strong> A scalability solution using Zero-Knowledge Proofs (ZKP) to compress off-chain data updates into succinct on-chain proofs, verifying storage operations efficiently while preserving privacy and enabling high-throughput decentralized storage.</li>
</ul>
<h3 id="succinct-abft-consensus"><a class="header" href="#succinct-abft-consensus">Succinct aBFT Consensus</a></h3>
<p>Unlike other consensus mechanisms, <strong>Orochi Network’s Succinct aBFT Consensus</strong> achieves fast finality by employing an aBFT approach, tolerating faults while rapidly confirming transactions, and uses ZKP to cryptographically prove the integrity of the entire blockchain state in a compact, verifiable form.</p>
<ul>
<li><strong>Gossip DAG (Directed Acyclic Graph)</strong> A structure that records transactions and messages propagated across nodes in a gossip-based protocol, organizing them into a tamper-evident graph where each node’s hash links to prior events, enabling efficient tracking and validation of network activity.</li>
<li><strong>Orochi Consensus</strong> An asynchronous Byzantine Fault Tolerant (aBFT) mechanism tailored for Orochi Network, ensuring agreement among distributed nodes even under adversarial conditions, achieving consensus without relying on synchronous timing assumptions for resilience and speed.</li>
<li><strong>Proof Composition</strong> A process that aggregate multiple Zero-Knowledge Proofs (ZKPs) into a single, succinct proof, verifying the correctness of the entire consensus process and blockchain state efficiently, reducing computational overhead for validators and users.</li>
</ul>
<h2 id="zk-centric-approach"><a class="header" href="#zk-centric-approach">ZK-Centric Approach</a></h2>
<p>Orochi Network positions as the first Verifiable Data Infrastructure, emphasizing the use of ZKPs for efficient and verifiable data processing. This focus on ZKPs caters to applications requiring high levels of privacy and trust.</p>
<ul>
<li><strong>Proof-System Agnostic</strong> Orochi Network can work with various ZKP systems like Halo2, ZK-STARK, and Pickles, offering developers flexibility in choosing the most suitable proof system for their needs.</li>
<li><strong>Blockchain Agnostic</strong> Orochi Network is designed to be blockchain-agnostic, potentially enabling integration with diverse blockchain platforms.</li>
<li><strong>Succinct Hybrid aBFT Consensus</strong> This consensus mechanism allows for asynchronous finalization of states, potentially improving efficiency compared to synchronous approaches used by some competitors.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="products"><a class="header" href="#products">Products</a></h1>
<ul>
<li><a href="orochi-network/../zkdatabase/chapter.html">zkDatabase - Self-proving Database</a></li>
<li><a href="orochi-network/../zk-memory/chapter.html">zkMemory - An Universal Memory Prover Module</a></li>
<li><a href="orochi-network/./orand-orocle.html">Orocle and Orand</a></li>
</ul>
<h4 id="orochi--open-source"><a class="header" href="#orochi--open-source">Orochi ❤️ Open Source</a></h4>
<p>All projects are open-sourced and public.</p>
<ul>
<li>Our scientific paper that proposes Conditional Folding Scheme: <a href="https://eprint.iacr.org/2024/336">RAMenPaSTA: Parallelizable Scalable Transparent Arguments of Knowledge for RAM Programs</a></li>
<li>Our construction in Distributed ECVRF - <a href="https://docsend.com/view/5y7rc5cww2juudzn">Orand - A fast, publicly verifiable, scalable decentralized random number generator for blockchain-based applications</a></li>
<li>Our zkDatabase - <a href="https://github.com/orochi-network/zkDatabase">zkDatabase - Self-proving Database</a></li>
<li>Our zkVM framework PoC - <a href="https://github.com/orochi-network/orochimaru/tree/main/zkmemory">zkMemory - An universal memory prover in Zero-Knowledge Proof</a></li>
<li>Our proposal to improve security of Smart Contracts - <a href="https://eips.ethereum.org/EIPS/eip-6366">ERC-6366: Permission Token</a></li>
<li>Our proposal to improve permission and role handling - <a href="https://eips.ethereum.org/EIPS/eip-6617">ERC-6617: Bit Based Permission</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zkdatabase-self-proving-database"><a class="header" href="#zkdatabase-self-proving-database">zkDatabase: Self-proving Database</a></h1>
<p>zkDatabase inherits the technology from Verifiable Data Infrastructure and zkMemory, this branch of product intents to fill the gap between enterprise and ZK technology. It opens new possibilities for FinTech, Insurance, Gaming, etc. For the first time, off-chain data can be verified independently by any party. Let's check the use cases of zkDatabase:</p>
<p><strong>FinTech</strong></p>
<p>zkDatabase can be utilized to enhance the security and privacy of financial transactions by proving data integrity and preventing money laundering. This can be achieved through the use of Zero-Knowledge Proofs (ZKPs) where transactions are recorded with proof of their legitimacy without revealing sensitive user data. For instance, zkDatabase can manage customer transaction records, ensuring that each transaction's compliance with Anti-Money Laundering (AML) regulations is verifiable without exposing personal or financial details of the users. This setup allows financial institutions to demonstrate to regulators that they are adhering to AML standards while simultaneously preserving customer privacy, thus maintaining trust and confidentiality in financial dealings</p>
<p><strong>IoT</strong></p>
<p>Weak IoT devices often lack the processing power to implement robust security measures, but with zkDatabase, data can be stored in a centralized hub/server while proofs of data integrity are committed on-chain. This means sensitive information like sensor readings or device status can be verified for authenticity and integrity without exposing the actual data, thereby protecting these devices from unauthorized access or tampering while ensuring that privacy is maintained, even on low-power or resource-constrained IoT devices.</p>
<p><strong>Healthcare</strong></p>
<p>Zero-Knowledge Proofs can revolutionize data privacy by allowing medical records to be stored and managed in a way that ensures patient confidentiality. Using Zero-Knowledge Proofs, zkDatabase can enable healthcare providers to verify the legitimacy and integrity of medical data without exposing sensitive patient information. For instance, a patient's medical history or test results can be proven to be up-to-date and accurate for treatment or research purposes, but only the necessary details are shared, not the entire medical record. This enhances patient privacy, reduces the risk of data breaches, and ensures compliance with privacy regulations like HIPAA, all while facilitating secure data sharing among healthcare professionals.</p>
<p><strong>AI/ML</strong></p>
<p>zkDatabase will concentrate on delivering proofs of data integrity to complement the outcomes of Zero-Knowledge Machine Learning (zkML), thereby making the entire process verifiable. This synergy ensures that the data input into ML models remains confidential and unaltered, while the results can be proven accurate through Zero-Knowledge Proofs, enhancing trust and transparency in AI applications.</p>
<p><strong>Insurance</strong></p>
<p>zkDatabase uses Zero-Knowledge Proofs to prove the claim/judgement are based on accurate data without revealing personal details, enhancing trust and streamlining claims processing.</p>
<p><strong>Web3 gaming</strong></p>
<p>Players can prove their in-game achievements or asset ownership without revealing their strategy or personal data. Additionally, zkDatabase allows game logic to be verified by smart contracts, ensuring that game rules, outcomes, and fairness are transparently and securely checked on-chain. This setup reduces the chances of cheating, provides trust in game mechanics, and supports a seamless, privacy-respecting environment where players can engage in play-to-earn models with confidence in the system's integrity.</p>
<p><strong>Identity</strong></p>
<p>Users can prove aspects of their identity like age, nationality, or financial status to service providers without disclosing unnecessary personal details.</p>
<p>This document provides an in-depth exploration of the zkDatabase, covering its various components, functionalities, and the underlying mechanisms that drive its operations. Our aim is to offer a comprehensive understanding of how zkDatabase functions and operates within the Mina Blockchain ecosystem.</p>
<h1 id="specification"><a class="header" href="#specification">Specification</a></h1>
<ul>
<li>
<p><a href="zkdatabase/./accumulation/accumulation.html">Accumulation</a>: Delving into the accumulation process, this section explains how the Mina Blockchain efficiently processes numerous transactions simultaneously, ensuring quick and secure transaction verification.</p>
</li>
<li>
<p><a href="zkdatabase/./b-tree/b-tree.html">B-Tree</a>: This part demystifies the role of B-Trees in organizing extensive data on the Mina Blockchain. Learn about their contribution to effective data management and utilization, and how they maintain order and efficiency.</p>
</li>
<li>
<p><a href="zkdatabase/./composability/composability.html">Composability</a>: Explore the concept of composability within the Mina Blockchain, where different elements interlink seamlessly like parts of a well-coordinated mechanism, ensuring smooth operations.</p>
</li>
<li>
<p><a href="zkdatabase/./serialization/serialization.html">Serialization</a>: In the context of SnakyJS, serialization involves converting specific data types to BSON (Binary JSON) and vice versa. This process is crucial for efficient data storage and transmission within the SnakyJS framework.</p>
</li>
<li>
<p><a href="zkdatabase/./data-collection/data-collection.html">Data Collection</a>: Focus on the process of extracting and processing information from blockchain networks. It involves retrieving transaction details and interactions for analysis, auditing, and ensuring transparency.</p>
</li>
<li>
<p><a href="zkdatabase/./distributed-storage-engine/section.html">Distributed Storage Engine</a>: Shift your focus to the distributed storage engine, understanding the use of IPFS for secure and efficient data storage, ensuring data integrity and accessibility.</p>
</li>
<li>
<p><a href="zkdatabase/./merkle-tree/merkle-tree.html">Merkle Tree</a>: Finally, dive into the functionalities of Merkle Trees in maintaining the accuracy and integrity of transactions and data, ensuring they remain tamper-proof within the blockchain network.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accumluation"><a class="header" href="#accumluation">Accumluation</a></h1>
<h2 id="the-problem-statement"><a class="header" href="#the-problem-statement">The problem statement</a></h2>
<p>Suppose we have a zkApp that updates its state with each user interaction. The updated state relies on both the previous state and the inputs from the interaction – a scenario likely common to many zkApps. The straightforward approach is to update the on-chain state during every interaction. However, to derive the new state, we must refer to the existing state. To validate that we're genuinely referencing the on-chain state, a precondition is set on the present state. Here's the catch: if multiple users unknowingly send their transactions within the same block, they'll establish the same precondition based on the current state, and concurrently attempt to update it. As a result, every transaction following the initial one becomes obsolete due to a stale precondition and gets declined.</p>
<h2 id="accumulation-and-concurrency-in-mina"><a class="header" href="#accumulation-and-concurrency-in-mina">Accumulation and Concurrency in Mina</a></h2>
<h3 id="accumulation-scheme"><a class="header" href="#accumulation-scheme">Accumulation scheme</a></h3>
<p>An accumulation scheme is a scheme that allows the prover to combine several proofs into a single proof, which can be verified more efficiently compared to verifying each proof separately. This scheme is critical in scaling blockchain systems and other similar systems, which involve numerous transactions and hence, multiple proofs.</p>
<p><a href="https://o1-labs.github.io/proof-systems/pickles/accumulation.html">Mina's Proof Systems</a> - offers deep insights into the utilization and implementation of accumulation schemes.</p>
<h3 id="block-production"><a class="header" href="#block-production">Block production</a></h3>
<p>In the Mina blockchain, transactions are grouped into blocks and added to the blockchain in a sequential manner. The blocks are created by block producers (similar to miners in other blockchain networks), and the block producers are responsible for processing the transactions in the blocks they produce.</p>
<p>Now, when multiple transactions are sent to the same smart contract, and possibly calling the same function within a short time frame, they would be processed one after the other, in the order they are included in the block by the block producer. </p>
<p><a href="https://docs.staketab.com/academy/mina/mina-block-production">Mina Block Production</a> - a comprehensive guide to understanding the nuances of block production within the Mina network.</p>
<h3 id="handling-concurrent-calls-to-the-same-function"><a class="header" href="#handling-concurrent-calls-to-the-same-function">Handling Concurrent Calls to the Same Function</a></h3>
<p>In the context of simultaneous calls to the same function in a smart contract:</p>
<ul>
<li>
<p>Atomicity: Each transaction is processed atomically. It will see a consistent state and produce a consistent state update.</p>
</li>
<li>
<p>Isolation: Transactions are isolated from each other until they are included in the block, at which point the state changes become visible to subsequent transactions.</p>
</li>
<li>
<p>Concurrency Issues: If two transactions are modifying the same piece of data, they will do so in the order determined by their position in the block, which prevents conflicts but can potentially lead to situations like <strong>front-running</strong>.</p>
</li>
</ul>
<h2 id="accumulation-in-o1js"><a class="header" href="#accumulation-in-o1js">Accumulation in o1js</a></h2>
<p>Actions, similar to events, are public data pieces shared with a zkApp transaction. What sets actions apart is their enhanced capability: they enable processing of past actions within a smart contract. This functionality is rooted in a commitment to the historical record of dispatched actions stored in every account, known as the <strong>actionState</strong>. This ensures verification that the processed actions align with those dispatched to the identical smart contract.</p>
<h3 id="practical-accumulation-managing-accumulation-in-code"><a class="header" href="#practical-accumulation-managing-accumulation-in-code">Practical Accumulation: Managing Accumulation in Code</a></h3>
<p>A code-based approach to handle accumulation using thresholds:</p>
<pre><code class="language-ts">@state root = State&lt;Field&gt;();
@state actionsHash = State&lt;Field&gt;();
@state userCount = State&lt;Field&gt;();
reducer = Reducer({ actionType: MerkleUpdate})

@method
deposit(user: PublicKey, amount: Field, witness: Witness) {
    this.userCount.set(this.userCount.get() + 1);
	this.root.assertEquals(this.root.get());
	this.root.assertEquals(witness.computeRoot(amount));
	user.send(this.account, amount);
	this.reducer.dispatch({ witness: witness, newLeaf: amount })

    if (this.userCount.get() &gt;= TRANSACTION_THRESHOLD) {
        // if we reach a certain treshold, we process all accumulated data
        let root = this.root.get();
        let actionsHash = this.actionsHash.get();
        
        let { state: newRoot, actionsHash: newActionsHash } = this.reducer.reduce(
            this.reducer.getActions(actionsHash),
            MerkleUpdate,
            (state: Field, action: MerkleUpdate) =&gt; {
                return action.witness.computeRoot(action.newLeaf);
            }
        );
        
        this.root.set(newRoot);
        this.actionsHash.set(newActionsHash);
        this.userCount.set(0);
    }
}
</code></pre>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<pre><code class="language-ts">reducer = Reducer({actionType: MyAction})
</code></pre>
<p><strong>reducer.dispatch(action: Field)</strong></p>
<ul>
<li>
<p>Description:
Dispatches an Action. Similar to normal Events, Actions can be stored by archive nodes and later reduced within a SmartContract method to change the state of the contract accordingly</p>
</li>
<li>
<p>Parameters:</p>
<ul>
<li><strong>action (MyAction)</strong>: Action to be stored.</li>
</ul>
</li>
</ul>
<p><strong>reducer.getActions(currentActionState: Field, endActionState:: Field)</strong></p>
<ul>
<li>
<p>Description:
Fetches the list of previously emitted <strong>Actions</strong>. Supposed to be used in the circuit.</p>
</li>
<li>
<p>Parameters:</p>
<ul>
<li><strong>currentActionState (Field)</strong>: The hash of already processed actions.</li>
<li><strong>endActionState (Field)</strong>: Calculated state of non-processed actions. Can be either <code>account.actionState</code> or be calculated with <code>Actions.updateSequenceState</code>.</li>
</ul>
</li>
<li>
<p>Returns: Returns the dispatched actions within the designated range. </p>
</li>
</ul>
<p><strong>reducer.fetchActions(currentActionState: Field, endActionState:: Field)</strong></p>
<ul>
<li>
<p>Description:
Fetches the list of previously emitted <strong>Actions</strong>. Supposed to be used out of circuit.</p>
</li>
<li>
<p>Parameters:</p>
<ul>
<li><strong>currentActionState (Field)</strong>: The hash of already processed actions.</li>
<li><strong>endActionState (Field)</strong>: Calculated state of non-processed actions. Can be either <code>account.actionState</code> or be calculated with <code>Actions.updateSequenceState</code> .</li>
</ul>
</li>
<li>
<p>Returns: Returns the dispatched actions within the designated range. </p>
</li>
</ul>
<p><strong>reducer.reduce(currentActionState: Field, endActionState:: Field)</strong></p>
<ul>
<li>
<p>Description:
Reduces a list of Actions, similar to <code>Array.reduce()</code>.</p>
</li>
<li>
<p>Parameters:</p>
<ul>
<li><strong>actions (Action[][])</strong>:  A list of sequences of pending actions. The maximum number of columns in a row is capped at 5. (P.S. A row is populated when multiple dispatch calls are made within a single @method.)</li>
<li><strong>stateType (Provable<State>)</strong>: Specifies the type of the state</li>
<li><strong>initial</strong>: An object comprising:
<ul>
<li><strong>state (State)</strong>: The current state.</li>
<li><strong>actionState (Field)</strong>: A pointer to actions in the historical record.</li>
</ul>
</li>
<li><strong>maxTransactionsWithActions (optional, number)</strong>: Defines the upper limit on the number of actions to process simultaneously. The default value is 32. This constraint exists because o1js cannot handle dynamic lists of variable sizes. The max value is limited by the circuit size.</li>
<li><strong>skipActionStatePrecondition (optional, boolean)</strong>: Skip the precondition assertion on the account. Each account has <code>account.actionState</code> which is the hash of all dispatched items. So, after reducing we check if all processed is equal to the all reduced once.</li>
</ul>
</li>
<li>
<p>Returns:</p>
<ul>
<li><strong>state</strong> (State): Represents the updated state of the zk app, e.g., the concluding root.</li>
<li><strong>actionState</strong> (Field): Indicates the position of the state. It is essentially the hash of the actions that have been processed.</li>
</ul>
</li>
</ul>
<h3 id="manual-calculation-of-the-pointer-to-the-actions-history"><a class="header" href="#manual-calculation-of-the-pointer-to-the-actions-history">Manual calculation of the pointer to the actions history</a></h3>
<pre><code class="language-ts">    let actionHashs = AccountUpdate.Actions.hash(pendingActions);
    let newState = AccountUpdate.Actions.updateSequenceState(currentActionState, actionHashs);
</code></pre>
<h3 id="commutative"><a class="header" href="#commutative">Commutative</a></h3>
<p>Actions are processed without a set order. To avoid race conditions in the zkApp, actions should be interchangeable against any state. For any two actions, a1 and a2, with a state <code>s</code>, the result of <code>s * a1 * a2</code> should be the same as <code>s * a2 * a1</code>.</p>
<h3 id="action-location"><a class="header" href="#action-location">Action Location</a></h3>
<p>All actions are stored in archive nodes.</p>
<h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<ul>
<li>https://github.com/o1-labs/o1js/issues/265</li>
<li>https://github.com/o1-labs/snarkyjs/issues/659</li>
<li>https://docs.minaprotocol.com/zkapps/o1js/actions-and-reducer</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="b-tree"><a class="header" href="#b-tree">B-tree</a></h1>
<p>A B-tree is a type of self-balancing search tree that maintains sorted data in a manner that allows for efficient insertion, deletion, and search operations. It is commonly used in database and file systems where large amounts of data need to be stored and retrieved efficiently.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>The main features of a B-tree are:</p>
<ol>
<li>All leaves are at the same level, making the tree perfectly balanced.</li>
<li>Each node in the B-tree contains a certain number of keys and pointers. The keys act as separation values which divide its subtrees. When we insert a new key into a B-tree, and if the node we want to insert into is already full, we perform a split operation. Similarly, deletion might cause a node to be less than half full, violating the properties of the B-tree. In this case, we perform a merge operation.</li>
<li>For a B-tree of order m (where m is a positive integer), every node in the tree contains a maximum of m children and a minimum of ⌈m/2⌉ children (except for the root which can have fewer children).</li>
<li>The keys within a node are ordered.</li>
<li>The subtree between two keys k1 and k2 consists of all keys that are greater than or equal to k1 and less than k2.</li>
</ol>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<ul>
<li>Insertion</li>
<li>Deletion</li>
<li>Search</li>
<li>Split and merge</li>
</ul>
<h3 id="split-and-merge-operations"><a class="header" href="#split-and-merge-operations">Split and Merge Operations</a></h3>
<p>When we insert a new key into a B-tree, it's possible that the node we want to insert into is already full. In this case, we have to split the node. Here is a high-level overview of how the split operation works:</p>
<ol>
<li>The node to be split is full and contains m-1 keys, where m is the order of the B-tree.</li>
<li>A new node is created, and approximately half of the keys from the original node are moved to this new node.</li>
<li>A key from the original node is moved up into the node's parent to act as a separator between the original node and the new node. If the original node was the root and has no parent, a new root is created.</li>
<li>The new node and the original node are now siblings.</li>
</ol>
<p>The split operation maintains the property that all leaf nodes are at the same level since all splits start at the leaf level and work their way up the tree.</p>
<p>Conversely, deletion from a B-tree might cause a node to be less than half full, violating the properties of the B-tree. In such cases, we perform a merge operation. Here's a simplified view of the merge process:</p>
<ol>
<li>Two sibling nodes, each with less than ⌈m/2⌉ keys, are combined into a single node.</li>
<li>A key from the parent node, which separates these two nodes, is moved down into the merged node.</li>
<li>If the parent node becomes less than half full as a result, it may also be merged with a sibling and so on.</li>
</ol>
<h3 id="time-complexity"><a class="header" href="#time-complexity">Time complexity</a></h3>
<p>Each operation runs in logarithmic time - <strong>O(log n)</strong>, making B-trees useful for systems that read and write large blocks of data, such as databases and filesystems.</p>
<h2 id="indexes"><a class="header" href="#indexes">Indexes</a></h2>
<p>Database indexing is a data structure technique to efficiently retrieve records from the database files based on some attributes on which the indexing has been done. Indexing in databases works similarly to an index in a book.</p>
<p>Indexes are used to quickly locate data without having to search every row in a database table every time a database table is accessed. Indexes can be created using one or more columns of a database table, providing the basis for both rapid random lookups and efficient access of ordered records.</p>
<p>The two main types of database indexes are:</p>
<ul>
<li>
<p><strong>Clustered Index</strong>: A clustered index determines the physical order of data in a table. Because the physical order of data in a table and the logical (index) order are the same, there can only be one clustered index per table.</p>
</li>
<li>
<p><strong>Non-clustered Index</strong>: A non-clustered index doesn’t sort the physical data inside the table. Instead, it creates a separate object within a table that contains the column(s) included in the index. The non-clustered index contains the column(s) values and the address of the record that the column(s) value corresponds to.</p>
</li>
</ul>
<h3 id="difference-between-clustered-and-non-clustered-indexes"><a class="header" href="#difference-between-clustered-and-non-clustered-indexes">Difference between Clustered and Non-Clustered Indexes</a></h3>
<p>In a clustered index, the leaf nodes of the B-tree structure contain the actual data rows. This is why there can only be one clustered index per table because it actually determines the physical order of data in the table.</p>
<p>In a non-clustered index, the leaf nodes contain a pointer or reference to the data rows, not the data itself. The data can be stored anywhere else in the database, and this pointer helps to quickly locate the actual data when needed.</p>
<p>Additional considerations when choosing between a Clustered and Non-Clustered Index include the order of data, frequency of updates, width of the table, and the need for multiple indexes. For instance, if the data in a table is accessed sequentially, a clustered index can be beneficial. If a table requires access via multiple different key columns, non-clustered indexes could be a good solution as you can create multiple non-clustered indexes on a single table.</p>
<div class="table-wrapper"><table><thead><tr><th>S.No</th><th></th><th>Clustered Indexes</th><th>Non-Clustered Indexes</th></tr></thead><tbody>
<tr><td>1</td><td><strong>Data sorting</strong></td><td>Defines the order or sorts the table or arranges the data by alphabetical order just like a dictionary.</td><td>Collects the data at one place and records at another place.</td></tr>
<tr><td>2</td><td><strong>Speed</strong></td><td>Generally faster for retrieving data in the sorted order or range of values.</td><td>Generally slower than the clustered index.</td></tr>
<tr><td>3</td><td><strong>Memory usage</strong></td><td>Demands less memory to execute the operation.</td><td>Demands more memory to execute the operations.</td></tr>
<tr><td>4</td><td><strong>Storage</strong></td><td>Permits you to save data sheets in the leaf nodes of the index.</td><td>Does not save data sheets in the leaf nodes of the index.</td></tr>
<tr><td>5</td><td><strong>Number per table</strong></td><td>A single table can consist of a sole clustered index.</td><td>A table can consist of multiple non-clustered indexes.</td></tr>
<tr><td>6</td><td><strong>Data storage</strong></td><td>Has the natural ability to store data on the disk.</td><td>Does not have the natural ability to store data on the disk.</td></tr>
</tbody></table>
</div>
<p>Resources: <a href="https://byjus.com/gate/difference-between-clustered-and-non-clustered-index/#:~:text=1-,A%20clustered%20index%20is%20used%20to%20define%20the%20order%20or,and%20records%20at%20another%20place.">Difference between Clustered and Non-Clustered Index</a></p>
<h3 id="choosing-between-clustered-and-non-clustered-indexes"><a class="header" href="#choosing-between-clustered-and-non-clustered-indexes">Choosing Between Clustered and Non-Clustered Indexes</a></h3>
<p>The choice between a clustered index and a non-clustered index often depends on the specific use case, the nature of the data, and the types of queries the database will be serving</p>
<ul>
<li><strong>Order of Data</strong>: If the data in a table is accessed sequentially, then a <strong>clustered index</strong> is typically the better choice because it physically stores the row data in sorted order. This can significantly speed up range queries and ordered access.</li>
<li><strong>Frequent Updates</strong>: If the indexed columns are updated frequently, <strong>non-clustered indexes</strong> can be a better choice. This is because any change to the data value of a clustered index requires physically rearranging the rows in the database, which can be an expensive operation.</li>
<li><strong>Wide Tables</strong>: In wide tables, where each row has a lot of data, <strong>non-clustered indexes</strong> can be beneficial. This is because non-clustered indexes only store the indexed columns and a pointer to the rest of the data, reducing the amount of data that needs to be read from disk for each query.</li>
<li><strong>Multiple Indexes</strong>: If a table needs to be accessed by multiple different key columns, <strong>non-clustered indexe</strong> can be a good solution because you can create multiple non-clustered indexes on a single table. Each non-clustered index will be optimized for access by its specific key column(s).</li>
</ul>
<p><strong>Clustered Indexes</strong>:</p>
<ol>
<li><strong>Primary Key</strong>: If a column is a unique identifier for rows in a table (like an ID), it should typically have a clustered index. The primary key of a table is a good candidate for a clustered index.</li>
<li><strong>Range Queries</strong>: Clustered indexes are beneficial for range queries that return a large range of ordered data, and queries where you expect to retrieve the data sorted by the indexed columns. The database can read the data off the disk in one continuous disk scan.</li>
<li><strong>Frequently Accessed Tables</strong>: If a table is frequently accessed by other database operations, like a foreign key relationship, a clustered index can help speed these operations.</li>
</ol>
<p>Resources: (Clustered Index)[https://vladmihalcea.com/clustered-index/]</p>
<p><strong>Non-Clustered Indexes</strong>:</p>
<ol>
<li><strong>Non-Unique Columns</strong>: If a column is not unique or has a high level of duplication, a non-clustered index can be a better choice.</li>
<li><strong>Specific Columns</strong>: If only specific columns are frequently accessed, a non-clustered index can provide quicker lookups since it doesn’t need to go through the entire row.</li>
<li><strong>Covering Indexes</strong>: For queries that can be covered by an index, a non-clustered index that includes all the necessary data can be highly efficient.</li>
<li><strong>Frequently Updated or Inserted Tables</strong>: If a table's data is frequently updated or if new data is often inserted, using non-clustered indexes can be beneficial as they can be less resource-intensive to maintain.</li>
</ol>
<h3 id="multiple-different-keys"><a class="header" href="#multiple-different-keys">Multiple different keys</a></h3>
<p>If you need to optimize access based on multiple different keys, it is more common to create multiple B-trees (i.e., multiple indexes), each with its own key. This way, you maintain the efficient logarithmic time complexity for searching, inserting, and deleting nodes in each tree.</p>
<h2 id="storing-data-raws"><a class="header" href="#storing-data-raws">Storing data raws</a></h2>
<p>A concise overview of data persistence:</p>
<ol>
<li>When we insert records into a table with a clustered index (typically created on the primary key), the database management system stores the records directly within the leaf nodes of the B-tree structure for this index. The records are sorted in the B-tree based on the values of the primary key.</li>
<li>We can create additional non-clustered indexes on the same table. These non-clustered indexes also use a B-tree structure, but they work slightly differently. Instead of storing the full record within the leaf nodes, they store the index key (which could be any column or combination of columns, not necessarily the primary key) and a reference (like a pointer) to the actual record in the clustered index.</li>
<li>When we perform a lookup using a non-clustered index, the database management system first locates the index key in the B-tree of the non-clustered index, finds the reference to the actual record, then uses that reference to retrieve the record from the B-tree of the clustered index.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composability"><a class="header" href="#composability">Composability</a></h1>
<p>Composability is the ability for different decentralized applications (dApps) or smart contracts to interact with each other in a seamless manner.
<strong>zkApp composability</strong> refers to the ability to call zkApp methods from other zkApp methods. It uses the <code>callData</code> field on the zkApp party to connect the result of the called zkApp to the circuit/proof of the caller zkApp.</p>
<h2 id="calldata"><a class="header" href="#calldata">CallData</a></h2>
<p>CallData is an opaque data for communicating between zkApps. `callData`` is a specific data structure generated during the execution of a zkApp method, and it's crucial in establishing a connection between the caller and the callee during a zkApp call</p>
<h3 id="composition-of-calldata"><a class="header" href="#composition-of-calldata">Composition of CallData</a></h3>
<p>The callData is formulated within the callee's circuit, and it is composed of a hash created from a collection of elements:</p>
<ul>
<li><strong>Inputs</strong>: The arguments that are being used to call a particular method in the smart contract, represented as an array of field elements.</li>
<li><strong>Outputs</strong>: The return values generated by the method, also represented as an array of field elements.</li>
<li><strong>Method Index</strong>: A numerical identifier for the method that is being called within the smart contract.</li>
<li><strong>Blinding Value</strong>: A random value that is known to both the caller and callee circuits at the time of proof generation, used to maintain the privacy of the inputs and outputs.</li>
</ul>
<h3 id="working"><a class="header" href="#working">Working</a></h3>
<ol>
<li>
<p>The callee smart contract first computes the callData hash with the aforementioned elements and stores it in its own callData field.</p>
</li>
<li>
<p>When the caller initiates a call to the callee zkApp, it witnesses the callee's party along with the hash of the callee's children and the method's return value.</p>
</li>
<li>
<p>Subsequently, within the caller's circuit, the same hash operation is performed as in the callee circuit, and it's compared against the callData acquired from the callee to ensure that the call was executed with the exact inputs and garnered the specified outputs.</p>
</li>
<li>
<p>This callData acts as a connecting link allowing the caller zkApp to make authenticated calls to another zkApp (callee) while maintaining the privacy and integrity of the transaction.</p>
</li>
</ol>
<h3 id="method-index"><a class="header" href="#method-index">Method Index</a></h3>
<p>The methods are stored in a fixed order, and that order is also baked into the verification key when compiling. Order depends on the order that the @method decorators are called in, but that's an implementation detail</p>
<h2 id="accountupdate"><a class="header" href="#accountupdate">AccountUpdate</a></h2>
<p>An <strong>AccountUpdate</strong> in the Mina Protocol signifies a set of alterations and events related to a single account during a transaction.</p>
<p>Each zkApp transaction constructed by o1js is composed of one or more AccountUpdates, arranged in a tree-like structure. The execution of this tree adheres to a pre-order traversal pattern; initiating with the primary account, followed by the subsequent left and right branches respectively.</p>
<p>Each <code>AccountUpdate</code> consists of components. Essentially, it can be seen as having a core and a set of metadata surrounding it.</p>
<ol>
<li><strong>Core Component</strong>:</li>
</ol>
<ul>
<li>Updates: This is the nucleus of an AccountUpdate, embodying the critical changes brought about by the transaction, including shifts in the zkApp state, alterations in permissions, and adjustments to the verification key linked to the account.</li>
</ul>
<ol start="2">
<li><strong>Metadata Components</strong>:</li>
</ol>
<ul>
<li>
<p>PublicKey: The unique identifier for the account being updated, akin to its address.</p>
</li>
<li>
<p>TokenId: Represents the custom token involved, defaulting to the MINA TokenId (1). It works in tandem with the PublicKey to uniquely identify an account on the Mina Protocol.</p>
</li>
<li>
<p>Preconditions: Specifies the essential conditions or assertions that need to be satisfied for the successful application of the AccountUpdate. These are usually framed through a method in the o1js library.</p>
</li>
<li>
<p>BalanceChange: Captures any fluctuations in the account's balance as a consequence of the transaction.</p>
</li>
<li>
<p>Authorization: Dictates the mode of authorizing the zkApp, which could be either a proof (aligned with the verification key on the account) or a signature.</p>
</li>
<li>
<p>MayUseToken: Signifies whether the zkApp possesses the authority to interact or manipulate its associated token.</p>
</li>
<li>
<p>Layout: Allows for making assertions regarding the structural makeup of an AccountUpdate, guaranteeing its compliance and integrity.</p>
</li>
</ul>
<h2 id="return-types"><a class="header" href="#return-types">Return types</a></h2>
<p>Only types built out of <code>Field</code> are valid return types. This includes snarkyjs primitive types and custom CircuitValues.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>The CallerContract class is invoking a method in the CalleeContract class. During this interaction, two separate AccountUpdates are created to record the changes and events that occurred during the transaction - one for the parent (CallerContract) and one for the child (CalleeContract).</p>
<pre><code class="language-ts">class CallerContract extends SmartContract {
  @method calledMethod(arg: UInt64): Bool {
     let calledContract = new CalleeContract(address);
     let result = calledContract.calledMethod(arg);
  }
}

class CalleeContract extends SmartContract {
  @method calledMethod(arg: UInt64): Bool {
     // ...
  }
}
</code></pre>
<ul>
<li>
<p>Once the child AccountUpdate is created, it is then verified in the parent's circuit, with assertions to validate that the right method was called with the correct parameters, and produced the expected outcome.</p>
</li>
<li>
<p>This process also involves verifying that the right zkApp was called by checking the publicKey and tokenId, as indicated in the child AccountUpdate.</p>
</li>
<li>
<p>After both AccountUpdates are verified, they are compiled into a tree-like structure, representing a cohesive record of the transaction.</p>
</li>
<li>
<p>This hierarchical structure is then submitted, effectively finalizing the transaction and documenting a secure, verified record of the entire interaction between the two contracts.</p>
</li>
</ul>
<p>These AccountUpdates work in tandem to create a comprehensive, secure, and verified record of the transaction, safeguarding the integrity of the process and ensuring transparency and accountability.</p>
<h2 id="composability-second-way"><a class="header" href="#composability-second-way">Composability: Second way</a></h2>
<p>Another approach to achieve composability is by chaining method calls from various smart contracts. This potentially could give use certain flexibility. However, the question is how can we ensure or enhance the security of such an approach?</p>
<pre><code class="language-ts">class OneZkApp extends SmartContract {
  @method callOne(): Field {
    //
  }
}

class SecondZkApp extends SmartContract {
  @method callSecond(field: Field) {
    //
  }
}

Mina.transaction(feePayer, () =&gt; {
  const result = oneZkApp.callOne();
  secondZkApp.callSecond(result);
});

</code></pre>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<ul>
<li>https://github.com/o1-labs/snarkyjs/issues/303</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization"><a class="header" href="#serialization">Serialization</a></h1>
<p>Serialization is the process of converting an object or data structure into a format that can be easily stored, transmitted, and reconstructed later. It is often used to save the state of a program, send data over a network, or store complex data structures, such as objects, in a human-readable or compact binary format. The opposite process, called deserialization, converts the stored format back into an object or data structure.</p>
<h2 id="data-type"><a class="header" href="#data-type">Data Type</a></h2>
<h3 id="snaryjs-supported-types"><a class="header" href="#snaryjs-supported-types">SnaryJS supported types</a></h3>
<ul>
<li><strong>Built-in types</strong>
<ul>
<li>Field</li>
<li>Bool</li>
<li>UInt32</li>
<li>UInt64</li>
<li>PublicKey</li>
<li>PrivateKey</li>
<li>Signature</li>
<li>Group</li>
<li>Scalar</li>
<li>CircuitString</li>
<li>Character</li>
</ul>
</li>
<li><strong>Custom types</strong>
<ul>
<li>Struct <a href="https://docs.minaprotocol.com/zkapps/snarkyjs-reference/modules#struct-1">*</a></li>
</ul>
</li>
<li><strong>Trees</strong>
<ul>
<li>MerkleTree</li>
<li>MerkleMap</li>
</ul>
</li>
</ul>
<h3 id="bson-supported-types"><a class="header" href="#bson-supported-types">Bson supported types</a></h3>
<ul>
<li>Double</li>
<li>String</li>
<li>Object</li>
<li>Array</li>
<li>Binary data</li>
<li>Undefined</li>
<li>ObjectId</li>
<li>Boolean</li>
<li>Date</li>
<li>Null</li>
<li>Regular Expression</li>
<li>DBPointer</li>
<li>JavaScript</li>
<li>Symbol</li>
<li>32-bit integer</li>
<li>Timestamp</li>
<li>64-bit integer</li>
<li>Decimal128</li>
<li>Min key</li>
<li>Max key</li>
</ul>
<h2 id="serializationdeserialization"><a class="header" href="#serializationdeserialization">Serialization/Deserialization</a></h2>
<p>The provided code snippet demonstrates how to convert a zk-snark data type into a BSON-supported format by first converting the value into a Uint8Array and then serializing it using BSON.</p>
<pre><code class="language-ts">const value = UInt64.from(12342);
const bytes: Uint8Array = Encoding.Bijective.Fp.toBytes(value.toFields());
const bson = BSON.serialize({ bytes });
</code></pre>
<p>This code snippet demonstrates the process of converting BSON data back into a zk-SNARK data type. This is done by first deserializing the BSON data into a JavaScript object, then converting the Binary data into a Uint8Array, and finally using a built-in decoding method to reconstruct the original value from the byte array.</p>
<pre><code class="language-ts">const deserializedBson = BSON.deserialize(bson);
const convertedResult = new Uint8Array(deserializedBson.bytes.buffer);
const initialField = Encoding.Bijective.Fp.fromBytes(convertedResult);
</code></pre>
<h3 id="serializing-arbitrary-data-into-field-elements"><a class="header" href="#serializing-arbitrary-data-into-field-elements">Serializing Arbitrary Data into Field Elements</a></h3>
<p>When serializing arbitrary data into field elements, it's important to note that field elements can hold a maximum of 254 arbitrary bits (not 255) due to the largest possible field element lying between 2^254 and 2^255.</p>
<p>You can utilize the <code>Encoding.bytesToFields</code> method, which efficiently packs 31 bytes per field element for serialization.</p>
<p><strong>HELP</strong> We need to clarify which kind of data type will be supported.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-collection"><a class="header" href="#data-collection">Data Collection</a></h1>
<p>Data collection occures by requesting <code>events</code> from the Mina blockchain, which are fired from <code>SmartContract</code>.</p>
<h2 id="smart-contract"><a class="header" href="#smart-contract">Smart Contract</a></h2>
<p>Define <em>names</em> and <em>types</em> of your events:</p>
<pre><code class="language-ts">events = {
  &quot;arbitrary-event-key&quot;: Field,
};
</code></pre>
<p>In order to send data to the blockchain with use the following method:</p>
<pre><code class="language-ts">this.emitEvent(&quot;arbitrary-event-key&quot;, data);
</code></pre>
<h2 id="off-chain"><a class="header" href="#off-chain">Off-chain</a></h2>
<p>The most convenient way to pull <code>events</code> off the blockchain is by <a href="https://berkeley.graphql.minaexplorer.com/">making graphql request</a>:</p>
<p><strong>Request</strong></p>
<pre><code class="language-gql">query getEvents($zkAppAddress: String!) {
  zkapps(
    query: {
      zkappCommand: { accountUpdates: { body: { publicKey: $zkAppAddress } } }
      canonical: true
      failureReason_exists: false
    }
    sortBy: BLOCKHEIGHT_DESC
    limit: 1000
  ) {
    hash
    dateTime
    blockHeight
    zkappCommand {
      accountUpdates {
        body {
          events
          publicKey
        }
      }
    }
  }
}
</code></pre>
<p>The response depends on the state of the smart contract, but it will be something like this:</p>
<p><strong>Response</strong></p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;zkapps&quot;: [
      {
        &quot;blockHeight&quot;: 17459,
        &quot;dateTime&quot;: &quot;2023-02-21T13:15:01Z&quot;,
        &quot;hash&quot;: &quot;CkpZ3ZXdPT9RqQZnmFNodB3HFPvVwz5VsTSkAcBANQjDZwp8iLtaU&quot;,
        &quot;zkappCommand&quot;: {
          &quot;accountUpdates&quot;: [
            {
              &quot;body&quot;: {
                &quot;events&quot;: [&quot;1,0&quot;],
                &quot;publicKey&quot;: &quot;B62qkzUATuPpDcqJ7W8pq381ihswvJ2HdFbE64GK2jP1xkqYUnmeuVA&quot;
              }
            }
          ]
        }
      },
      {
        &quot;blockHeight&quot;: 17458,
        &quot;dateTime&quot;: &quot;2023-02-21T13:09:01Z&quot;,
        &quot;hash&quot;: &quot;CkpaEP2EUvCdm7hT3cKe5S7CCusKWL2JgnJMg1KXqqmK5J8fVNYtp&quot;,
        &quot;zkappCommand&quot;: {
          &quot;accountUpdates&quot;: [
            {
              &quot;body&quot;: {
                &quot;events&quot;: [],
                &quot;publicKey&quot;: &quot;B62qkzUATuPpDcqJ7W8pq381ihswvJ2HdFbE64GK2jP1xkqYUnmeuVA&quot;
              }
            }
          ]
        }
      },
      {
        &quot;blockHeight&quot;: 17455,
        &quot;dateTime&quot;: &quot;2023-02-21T12:48:01Z&quot;,
        &quot;hash&quot;: &quot;CkpZePsTYryXnRNsBZyk12GMsdT8ZtDuzW5rdaBFKfJJ73mpJbeaT&quot;,
        &quot;zkappCommand&quot;: {
          &quot;accountUpdates&quot;: [
            {
              &quot;body&quot;: {
                &quot;events&quot;: [&quot;13,12&quot;],
                &quot;publicKey&quot;: &quot;B62qkzUATuPpDcqJ7W8pq381ihswvJ2HdFbE64GK2jP1xkqYUnmeuVA&quot;
              }
            }
          ]
        }
      }
    ]
  }
}
</code></pre>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>It is possible to send up to <strong>16 fields</strong> in events in a single transaction, and each field can be up to <strong>255 bits</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distributed-storage-engine"><a class="header" href="#distributed-storage-engine">Distributed Storage Engine</a></h1>
<p>This chapter provides a comprehensive insight into the IPFS (InterPlanetary File System) and its components, explaining how data is replicated and retrieved in the network using unique identifiers like PeerID and CID. It dives deep into concepts like IPNS, which provides a permanent pointer to mutable data, and Merkle DAG, a data structure essential for data storage and retrieval in IPFS. <a href="zkdatabase/distributed-storage-engine/./ipfs.html">IPFS</a>.</p>
<p>Next we describe the functionality and implementation of a Storage Engine, particularly focusing on the IPFS Storage Engine. <a href="zkdatabase/distributed-storage-engine/./storage-engine.html">Storage Engine</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ipfs"><a class="header" href="#ipfs">IPFS</a></h1>
<p>IPFS is a distributed protocol that allow you to replicate data among network, you can put a data to IPFS and get those data back as long as it wasn't run out of liveness. Data will be stored as blocks and each block will be identified by its digest.</p>
<h2 id="peerid"><a class="header" href="#peerid">PeerID</a></h2>
<p>PeerID is a unique identifier of a node in the network. It's a hash of public key of the node. Lip2p2 keypair is handle by its keychain. You can get the PeerID by:</p>
<pre><code class="language-ts">const libp2p = await createLibp2p({});
libp2p.peerId.toString();
</code></pre>
<h2 id="cid"><a class="header" href="#cid">CID</a></h2>
<p>CID is a unique fingerprint of data you can access the data as long as you know the exactly CID. The CID was calculated by hash function but it isn't data's digest. Instead the CID was calculated by digests of blocks of data.</p>
<p>Combining that digest with codec information about the block using multiformats:</p>
<ul>
<li>Multihash for information on the algorithm used to hash the data.</li>
<li>Multicodec for information on how to interpret the hashed data after it has been fetched.</li>
<li>Multibase for information on how the hashed data is encoded. Multibase is only used in the string representation of the CID.</li>
</ul>
<p>In our implementation we use CID v1 and use <code>SHA256</code> + <code>base58</code>. I supposed that <code>poseidon</code> could be better in the long term so we need to make a poseidon proposal to <code>multihash</code>.</p>
<h2 id="ipns"><a class="header" href="#ipns">IPNS</a></h2>
<p>As we know from above, each DAG node is immutable. In the reality, we want to keep the pointer to the data immutable. <a href="https://docs.ipfs.tech/concepts/ipns/">IPNS</a> will solve this by provide a permanently pointer (in fact it's a hash of public key).</p>
<h2 id="merkle-dag"><a class="header" href="#merkle-dag">Merkle DAG</a></h2>
<p>A Merkle DAG is a DAG where each node has an identifier, and this is the result of hashing the node's contents — any opaque payload carried by the node and the list of identifiers of its children — using a cryptographic hash function like SHA256. This brings some important considerations.</p>
<p>Our data will be stored in sub-merkle DAG. Every time we alter a leaf, it's also change the sub-merkle DAG node and it's required to recompute the CID, this will impact our implementation since we need a metadata file to keep track on CIDs and its children.</p>
<p>We can perform a lookup on a merkle DAG by using the CID of the root node. We can also perform a lookup on a sub-merkle DAG by using the CID of the root node of the sub-merkle DAG. DAG traversal is a recursive process that starts at the root node and ends when the desired node is found. This process is cheap and fast, since it only requires the node identifier.</p>
<h2 id="javascript-ipfs"><a class="header" href="#javascript-ipfs">Javascript IPFS</a></h2>
<p><a href="https://github.com/ipfs/js-ipfs">js-ipfs</a> paves the way for the Browser implementation of the IPFS protocol. Written entirely in JavaScript, it runs in a Browser, a Service Worker, a Web Extension and Node.js, opening the door to a world of possibilities.</p>
<p>We switch to <a href="https://github.com/ipfs/helia">Helia</a> due to the <code>js-ipfs</code> is discontinued.</p>
<h2 id="libp2p"><a class="header" href="#libp2p">libp2p</a></h2>
<p>LibP2p provide building blocks to build p2p application, it handled all p2p network related along side with its modules. It's flexible to use and develop with <a href="https://github.com/libp2p/js-libp2p">libp2p</a>. To config and work with libp2p you need to define:</p>
<ul>
<li>Transport:
<ul>
<li><a href="https://github.com/libp2p/js-libp2p-tcp">TCP</a>: TCP transport module help you to manage connection between nodes natively. TCP handles connect at transport layer (layer 4) that's why it's more efficient to maintain connection. But it's only work for <code>Node.js</code> run-time.</li>
<li><a href="https://github.com/libp2p/js-libp2p-websockets">WebSockets</a>: WebSocket in contrast to TCP, it's work on application layer (layer 7) that's why it's less efficient to maintain connection. But it's work for both <code>Node.js</code> and <code>Browser</code>.</li>
</ul>
</li>
<li>Encryption: <a href="https://github.com/ChainSafe/js-libp2p-noise">noise</a>, we don't have any option since TLS didn't have any implement for JS.</li>
<li>Multiplexer:
<ul>
<li><a href="https://github.com/libp2p/js-libp2p-mplex">mplex</a> <code>mplex</code> is a simple stream multiplexer that was designed in the early days of libp2p. It is a simple protocol that does not provide many features offered by other stream multiplexers. Notably, <code>mplex</code> does not provide flow control, a feature which is now considered critical for a stream multiplexer. <code>mplex</code> runs over a reliable, ordered pipe between two peers, such as a TCP connection. Peers can open, write to, close, and reset a stream. mplex uses a message-based framing layer like yamux, enabling it to multiplex different data streams, including stream-oriented data and other types of messages.</li>
<li><a href="https://github.com/ChainSafe/js-libp2p-yamux">yamux</a>. Yamux (Yet another Multiplexer) is a powerful stream multiplexer used in libp2p. It was initially developed by Hashicorp for Go, and is now implemented in Rust, JavaScript and other languages. enables multiple parallel streams on a single TCP connection. The design was inspired by SPDY (which later became the basis for HTTP/2), however it is not compatible with it. One of the key features of Yamux is its support for flow control through backpressure. This mechanism helps to prevent data from being sent faster than it can be processed. It allows the receiver to specify an offset to which the sender can send data, which increases as the receiver processes the data. This helps prevent the sender from overwhelming the receiver, especially when the receiver has limited resources or needs to process complex data. <em><strong>Note</strong>: Yamux should be used over mplex in libp2p, as mplex doesn’t provide a mechanism to apply backpressure on the stream level.</em></li>
</ul>
</li>
<li>Node discovery: <a href="https://github.com/libp2p/js-libp2p-kad-dht">KAD DHT</a> The Kademlia Distributed Hash Table (DHT), or Kad-DHT, is a distributed hash table that is designed for P2P networks. Kad-DHT in libp2p is a subsystem based on the <a href="https://docs.libp2p.io/concepts/discovery-routing/kaddht/#:~:text=based%20on%20the-,Kademlia%20whitepaper,-.">Kademlia whitepaper</a>. Kad-DHT offers a way to find nodes and data on the network by using a <a href="https://docs.libp2p.io/concepts/discovery-routing/kaddht/#:~:text=by%20using%20a-,routing%20table,-that%20organizes%20peers">routing table</a> that organizes peers based on how similar their keys are.</li>
</ul>
<p><em><strong>Note:</strong> KAD DHT boostrap didn't work as expected that's why you would see I connect the bootstrap nodes directly in the construction.</em></p>
<pre><code class="language-ts">const nodeP2p = await createLibp2p(config);
// Manual patch for node bootstrap
const addresses = [
  &quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN&quot;,
  &quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa&quot;,
  &quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb&quot;,
  &quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt&quot;,
].map((e) =&gt; multiaddr(e));
for (let i = 0; i &lt; addresses.length; i += 1) {
  await nodeP2p.dial(addresses[i]);
}
await nodeP2p.start();
</code></pre>
<h2 id="helia"><a class="header" href="#helia">Helia</a></h2>
<p><a href="https://github.com/ipfs/helia">Helia</a> is an new project that handle <code>ipfs</code> in modular manner. You can construct a new instance of <code>Helia</code> on top of libp2p.</p>
<pre><code class="language-ts">return createHelia({
  blockstore: new FsBlockstore(&quot;./local-storage&quot;),
  libp2p,
});
</code></pre>
<p>By passing libp2p instance to Helia, it's highly configurable.</p>
<h2 id="unixfs"><a class="header" href="#unixfs">UnixFS</a></h2>
<p>To handle file I/O, we used <a href="https://github.com/ipfs/helia-unixfs">UnixFS</a>. It can be constructed in the same way that we did with <code>Helia</code> but it will take a <code>Helia</code> instance instead of <code>libp2p</code>.</p>
<pre><code class="language-ts">const fs = unixfs(heliaNode);
let text = &quot;&quot;;
const decoder = new TextDecoder();

let testCID = CID.parse(&quot;QmdASJKc1koDd9YczZwAbYWzUKbJU73g6YcxCnDzgxWtp3&quot;);
if (testCID) {
  console.log(&quot;Read:&quot;, testCID);
  for await (const chunk of fs.cat(testCID)) {
    text += decoder.decode(chunk, {
      stream: true,
    });
  }
  console.log(text);
}
</code></pre>
<p>After do research in <code>libp2p</code> and <code>ipfs</code> we introduce <code>StorageEngineIPFS</code> that handle <code>ipfs</code> I/O. The detail is given in <a href="zkdatabase/distributed-storage-engine/./storage-engine.html">specs</a>. In our implementation, we used <code>datastore-fs</code> and <code>blockstore-fs</code> to persist changes.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="storage-engine"><a class="header" href="#storage-engine">Storage Engine</a></h2>
<p>Storage Engine help us to handle file storage and local catching process, storage engine is also help to index files for further accession.</p>
<h3 id="ipfs-storage-engine"><a class="header" href="#ipfs-storage-engine">IPFS Storage Engine</a></h3>
<p>IPFS Storage Engine is a distributed storage engine based on <a href="https://ipfs.tech/">IPFS</a>. The <code>StorageEngineIPFS</code> ins an implementation of <code>IFileSystem</code> and <code>IFileIndex</code> that handle all I/O operations and indexing.</p>
<pre><code class="language-ts">/**
 * An interface of file engine, depend on the environment
 * file engine could be different
 */
export interface IFileSystem&lt;S, T, R&gt; {
  writeBytes(_data: R): Promise&lt;T&gt;;
  write(_filename: S, _data: R): Promise&lt;T&gt;;
  read(_filename: S): Promise&lt;R&gt;;
  remove(_filename: S): Promise&lt;boolean&gt;;
}

/**
 * Method that performing index and lookup file
 */
export interface IFileIndex&lt;S, T, R&gt; {
  publish(_contentID: T): Promise&lt;R&gt;;
  republish(): void;
  resolve(_peerID?: S): Promise&lt;T&gt;;
}

/**
 * IPFS file system
 */

export type TIPFSFileSystem = IFileSystem&lt;string, CID, Uint8Array&gt;;

/**
 * IPFS file index
 */
export type TIPFSFileIndex = IFileIndex&lt;PeerId, CID, IPNSEntry&gt;;
</code></pre>
<p>The relationship between <code>StorageEngineIPFS</code> and other classes/interfaces is shown below:</p>
<pre class="mermaid">classDiagram
  LibP2pNode -- StorageEngineIPFS
  Helia-- StorageEngineIPFS
  UnixFS -- StorageEngineIPFS
  IPNS -- StorageEngineIPFS
  IFileSystem &lt;|-- StorageEngineIPFS
  IFileIndex &lt;|-- StorageEngineIPFS
  IFileSystem : writeByte(data Uint8Array) CID
  IFileSystem : write(filename string, data Uint8Array) CID
  IFileSystem : read(filename string) Uint8Array
  IFileSystem : remove(filename string) boolean
  IFileIndex : publish(contentID CID) IPNSEntry
  IFileIndex : republish() void
  IFileIndex : resolve(peerID PeerId) CID
  StorageEngineIPFS : static getInstance(basePath, config)
</pre>
<p>In our implementation, we used <code>datastore-fs</code> and <code>blockstore-fs</code> to persist changes with local file, for now browser is lack of performance to handle connections and I/O. So the best possible solution is provide a local node that handle all I/O and connection.</p>
<h4 id="usage-of-ipfs-storage-engine"><a class="header" href="#usage-of-ipfs-storage-engine">Usage of IPFS Storage Engine</a></h4>
<p>The database will be cached at local to make sure that the record are there event it's out live of liveness on IPFS network. To start an instance of <code>StorageEngineIPFS</code> we need to provide a <code>basePath</code> and <code>config</code> (we ignored config in this example):</p>
<pre><code class="language-ts">const storageIPFS = await StorageEngineIPFS.getInstance(
  &quot;/Users/chiro/GitHub/zkDatabase/zkdb/data&quot;
);
</code></pre>
<p>The <code>basePath</code> is the path to the local cache folder, the folder will be created if it's not exist. The <code>config</code> is the configuration of IPFS node, we will use default config if it's not provided. After we get the instance of <code>StorageEngineIPFS</code> we could use it to perform I/O operations.</p>
<pre><code class="language-ts">// Switch to collection `test`
newInstance.use(&quot;test&quot;);

// Write a document to current collection
await newInstance.writeBSON({ something: &quot;stupid&quot; });

// Read BSON data from ipfs
console.log(
  BSON.deserialize(
    await newInstance.read(
      &quot;bbkscciq5an6kqbwixefbpnftvo34pi2jem3e3rjppf3hai2gyifa&quot;
    )
  )
);
</code></pre>
<p>The process to update collection metadata and master metadata will be described in the following sections.</p>
<h4 id="file-mutability"><a class="header" href="#file-mutability">File mutability</a></h4>
<p>Since a DAG nodes are immutable but we unable to update the <code>CID</code> every time. So <code>IPNS</code> was used, <code>IPNS</code> create a record that mapped a <code>CID</code> to a <code>PeerID</code> hence the <code>PeerID</code> is unchanged, so as long as we keep the <code>IPNSEntry</code> update other people could get the <code>CID</code> of the zkDatabase.</p>
<h4 id="metadata"><a class="header" href="#metadata">Metadata</a></h4>
<p>The medata file is holding a mapping of data's poseidon hash to its <code>CID</code> that allowed us to retrieve the data from ipfs. It's also use to reconstruct the merkle tree. Metada is stored on IPFS and we also make a copy at local file system.</p>
<h5 id="ipfs-storage-engine-folder-structure"><a class="header" href="#ipfs-storage-engine-folder-structure">IPFS Storage Engine folder structure</a></h5>
<p>The structure of data folder is shown below:</p>
<pre><code class="language-text">├── helia
├── nodedata
│   ├── info
│   ├── peers
│   └── pkcs8
└── storage
    └── default
</code></pre>
<p>The <code>helia</code> folder is the folder that hold the Helia node's information, the <code>nodedata</code> folder is the folder that hold the IPFS node's information inclued node identity, peers and addition info. The <code>storage</code> folder is the folder that hold the data of our zkDatabase, all children folder of <code>storage</code> is the name of the collection, in this case we only have one collection called <code>default</code>.</p>
<h4 id="metadata-structure"><a class="header" href="#metadata-structure">Metadata structure</a></h4>
<p>There is a <code>metadata</code> file at the root of <code>storage</code> folder that contains all the index records for children's metadata, we called it master metadata.</p>
<pre><code class="language-json">{
  &quot;default&quot;: &quot;bafkreibbdesmz6d4fp2h24d6gebefzfl2i4fpxseiqe75xmt4fvwblfehu&quot;
}
</code></pre>
<p>The <code>default</code> is the name of the collection and the <code>bafkreibbdesmz6d4fp2h24d6gebefzfl2i4fpxseiqe75xmt4fvwblfehu</code> is the <code>CID</code> of the collection's metadata file. We use the <code>IPNS</code> to point current node <code>PeerID</code> to the <code>CID</code> of the master metadata file by which we could retrieve the list of <code>CID</code> of the collection's metadata file.</p>
<p>There are also a <code>metadata</code> file at each collection folder, we called it collection metadata.</p>
<pre><code class="language-json">{
  &quot;bbkscciq5an6kqbwixefbpnftvo34pi2jem3e3rjppf3hai2gyifa&quot;: &quot;bafkreifnz52i6ssyjqsbeogetwhgiabsjnztuuy6mshke5uemid33dsqny&quot;
}
</code></pre>
<p>You might aware that the key of the collection metadata is the poseidon hash of the database document in <code>base32</code> encoding, and the value is the <code>CID</code> of the document. The collection metadata is used to retrieve the <code>CID</code> of the document by its poseidon hash. There is also a file in the collection folder with the name <code>bbkscciq5an6kqbwixefbpnftvo34pi2jem3e3rjppf3hai2gyifa.zkdb</code> contains the content of the document which was encoded by <code>BSON</code>.</p>
<h4 id="bson-document"><a class="header" href="#bson-document">BSON Document</a></h4>
<p>BSON or Binnary JSON is a data structure that we used to encode and decode document. The document will be categorized into collections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merkle-tree"><a class="header" href="#merkle-tree">Merkle Tree</a></h1>
<p>To keep our merkle tree verification succinct, efficient and friendly with <a href="https://github.com/o1-labs/snarkyjs">SnarkyJS</a>. A poseidon merkle tree will be used to prove the immutability of the data. The <strong>Sparse Merkle Tree</strong> is utilized as an adaptation of the conventional Merkle Tree.</p>
<h2 id="sparse-merkle-tree-smt"><a class="header" href="#sparse-merkle-tree-smt">Sparse Merkle Tree (SMT)</a></h2>
<p>A Sparse Merkle Tree (SMT) is a variant of a standard Merkle tree that is optimized for scenarios where the data set is very large, but only a small portion of it is populated with values. You could refer to the following article to learn more: <a href="https://medium.com/@kelvinfichter/whats-a-sparse-merkle-tree-acda70aeb837">What’s a Sparse Merkle Tree?</a>.</p>
<h3 id="advantages-of-smt"><a class="header" href="#advantages-of-smt">Advantages of SMT</a></h3>
<p>Sparse Merkle Trees (SMTs) offer several benefits:</p>
<ol>
<li><strong>Efficiency</strong>: They allow efficient storage of large, sparse datasets with minimal memory overhead.</li>
<li><strong>Security</strong>: Sparse Merkle Trees (SMTs) share the tamper-proof nature of traditional Merkle Trees, ensuring cryptographic data integrity. However, they also share the same vulnerabilities, such as potential false proofs through hash collisions or second preimage attacks. To mitigate these risks, a strong, collision-resistant hash function is crucial. Additionally, cryptographic commitments to the SMT root can enhance security. With proper implementation, SMTs offer efficient and secure data storage for sparse datasets.</li>
<li><strong>Proof Size</strong>: The proof size for SMTs is consistent, regardless of the tree's size, making them optimal for scenarios where frequent proofs are required.</li>
<li><strong>Flexible Updating</strong>: They support efficient updates and insertions even in massive datasets.</li>
</ol>
<h3 id="ways-to-store-merkle-tree-on-ipfs"><a class="header" href="#ways-to-store-merkle-tree-on-ipfs">Ways to store Merkle Tree on IPFS</a></h3>
<p>Here are different ways you could store a Merkle Tree on IPFS:</p>
<ol>
<li>
<p><strong>JSON Serialization</strong>: One of the simplest ways to store a Merkle Tree in IPFS is to convert the Merkle Tree to a JSON structure and then save that to IPFS. This is a straightforward method but can be inefficient for large trees, as the entire tree needs to be retrieved even if you're only interested in certain parts of it.</p>
</li>
<li>
<p><strong>IPLD (InterPlanetary Linked Data)</strong>: IPLD is a data model and set of coding conventions for linking distributed content on IPFS. By using IPLD, you can create links between any piece of data stored within IPFS. While it involves the concept of DAGs, it provides a more flexible and efficient way to store and retrieve Merkle Trees on IPFS.</p>
</li>
<li>
<p><strong>BSON Serialization</strong>: BSON, or Binary JSON, extends the popular JSON model to include additional data types such as Date and raw binary data, and allows for a level of efficiency not present in standard JSON. This is because BSON data is a binary representation of JSON-like documents and BSON documents may have elements that are BSON arrays. Storing a Merkle Tree in IPFS using BSON serialization would provide a more space-efficient and potentially faster method for data retrieval compared to JSON, especially for large trees with binary data. Like with JSON, though, the whole tree would need to be retrieved even if you're only interested in certain parts. However, if the Merkle tree's structure can be mapped to a BSON document structure, it might allow for partial tree loading. When using BSON, you need to ensure that the data types you use in your Merkle Tree are compatible with BSON serialization. Some data types may not be supported or may need special handling.</p>
</li>
</ol>
<h3 id="storing-smt"><a class="header" href="#storing-smt">Storing SMT</a></h3>
<p>Roughly speaking, Sparse Merkle Trees consist of two types of nodes: <em>filled nodes</em> representing actual data, and <em>zero nodes</em> denoting areas of the tree that are unoccupied or sparse.</p>
<p>For effective persistence of a Merkle Tree in any storage medium, three key functions must be executed:</p>
<ul>
<li>Storing nodes</li>
<li>Fetching nodes</li>
<li>Creating a Merkle Tree proof</li>
</ul>
<p>All standart merkle tree functions can be implemented along with these 'key' functions.</p>
<h4 id="zero-nodes"><a class="header" href="#zero-nodes">Zero nodes</a></h4>
<p>For each level, zero nodes remain constant and can be generated during the initialization of the Merkle Tree.</p>
<pre><code class="language-ts">  protected zeroes: Field[];

  constructor(height: number) {
    this.zeroes = new Array(height);
    this.zeroes[0] = Field(0);
    for (let i = 1; i &lt; height; i+=1) {
      this.zeroes[i] = Poseidon.hash([this.zeroes[i - 1], this.zeroes[i - 1]]);
    }
  }
</code></pre>
<h4 id="filled-nodes"><a class="header" href="#filled-nodes">Filled nodes</a></h4>
<p>In order to properly store filled nodes, a more advanced approach is needed. As a rule of thumb, every digest must be accompanied by metadata that outlines its position within the tree. This information will assist in the restoration of the node and its associated proof in the future.</p>
<p>Consider the following as an example of how a node might be depicted in IPLD:</p>
<pre><code class="language-ts">interface IPDLNode {
  level: number;
  index: string;
  hash: Field;
  leftChildCID: CID | null;
  rightChildCID: CID | null;
}
</code></pre>
<h3 id="merkle-proof"><a class="header" href="#merkle-proof">Merkle Proof</a></h3>
<p>A Merkle Proof forms a vital component of the Merkle Tree.</p>
<p>Consider this general interface:</p>
<pre><code class="language-ts">interface MerkleProof {
  sibling: Field;
  isLeft: boolean; // isLeft = `index` mod 2 == 0
}
</code></pre>
<p><em>sibling</em> represents the other child of the parent node while <em>isLeft</em> can be determined by taking the modulus of the node's index by 2.</p>
<p>Merkle proofs can be built in two directions:</p>
<ul>
<li>from root to leaf</li>
<li>from leaf to root</li>
</ul>
<p>When using IPLD, constructing a Merkle proof <em>from root to leaf</em> is a logical approach since the alternative is less efficient due to the need to initially locate the leaf.</p>
<p>Merkle Proof can be used also to add/update leaves.</p>
<h3 id="time-complexity-1"><a class="header" href="#time-complexity-1">Time complexity</a></h3>
<p>The time complexity for all operation in a distributed SMT is equal to O(n), where <strong>n</strong> is the height of the tree.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zkmemory-an-universal-memory-prover-in-zero-knowledge-proof"><a class="header" href="#zkmemory-an-universal-memory-prover-in-zero-knowledge-proof">zkMemory: An Universal Memory Prover in Zero-Knowledge Proof</a></h1>
<p><strong>zkMemory</strong> is a powerful building block for creating secure and efficient <strong>Zero-Knowledge Virtual Machines (zkVMs)</strong>. Its modular design allows developers to integrate zkMemory into their zkVM architecture. This component acts as a dedicated memory prover, handling the ZKPs generation for memory operations within the zkVM.</p>
<p>By leveraging zkMemory's modularity, developers can design zkVM with customized instruction sets and architecture, enabling them to tailor the virtual machine to specific needs. This flexibility, coupled with zkMemory's potential efficiency gains in proof generation, paves the way for a new generation of zkVM applications within the Web3 landscape.</p>
<h1 id="specification-1"><a class="header" href="#specification-1">Specification</a></h1>
<p>In this chapter we give a brief overview to zkMemory, including its components and functionalities.</p>
<p>zkMemory is a module built by Orochi Network which allows a prover to prove the consistency when reading and writing values in the memory. The problem can be stated as follows:</p>
<p><strong>Consider a memory \(M\). Then for any cell of \(M\), during the course of time, whenever we read from the cell, the read value must be equal to the last time it was written in the same cell.</strong></p>
<p>Proving memory consistency is an important sub-component for handling the correctness RAM program, which can be used to construct zkVMs. Therefore, zkMemory could serve as a powerful library which handle the memory part in zkVMs and helps developers build custom zkVMs tailored to specific needs within the Web3 landscape. We divide this chapter into \(3\) major parts below:</p>
<ul>
<li>
<p>In <a href="zk-memory/./execution-trace/execution-trace.html">Execution Trace</a>, we describe <strong>execution trace</strong>, which are used to prove memory consistency from a memory \(M\) and a computation process of \(N\) steps.</p>
</li>
<li>
<p>In <a href="zk-memory/./commitment/commitment.html">Commitment Schemes</a>, we describe several commitment schemes for committing the execution trace that we support.</p>
</li>
<li>
<p>In <a href="zk-memory/./constraints/constraints.html">Memory Consistency Constraints</a>, we show how to prove the consistency of memory given the execution trace and how do we integrate Halo2 for the constraint.</p>
</li>
<li>
<p>In <a href="zk-memory/./nova-variant/nova-variant.html">Nova Variants</a>, we show how to prove the consistency of memory with two Nova variants, Nova and SuperNova. This implementation to experiment the capacity of Nova, SuperNova for zkVM.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="execution-trace"><a class="header" href="#execution-trace">Execution Trace</a></h2>
<p>We view a memory \(M\) to be an array \(M=(M_1,M_2,\dots,M_m)\). For a computation with \(N\) steps, n each step of a program execution, we could either i) Read a value from \(M_i\) for some \(i \leq m\) or ii) Write a value \(val\) to a cell \(M_i\) for some \(i \leq m\). To capture this reading/writing step, we define an execution trace to be the following tuple</p>
<p>$$(addr,time,op,val)$$</p>
<p>Here, \(addr\) is the address in the cell in the reading/writing process which is in \(\{1,2\dots,m\}\), \(time\) is the time log, \(op \in \{0,1\}\) is the value which determines whether the operation is READ or WRITE, and \(val\) is the value which is written to/read from \(M_{addr}\). We can see that, in the \(i\)-th execution step, the information from the \(i\)-th trace is sufficient to determine the action in reading/writing the value from/to the memory in that step. In the end, after the execution, we obtain we obtain an array of execution traces \((addr_i,time_i,op_i,val_i)_{i=1}^N\). In the next section, we show how to prove memory consistency given the whole execution trace array.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="commitment-schemes"><a class="header" href="#commitment-schemes">Commitment Schemes</a></h2>
<p>The first step in zkMemory is to commit the memory, then later we prove the correctness of the trace where its commitment serves as the public instance to prevent prover from cheating in the computation process. Later, we employ a ZKP protocol to prove that the execution trace is correct given its commitment. Currently, our zkMemory implementation supports 3 commitment schemes: KZG, Merkle Tree and Verkle Tree. We now give a high overview of these schemes.</p>
<h3 id="kzg-commitment-scheme"><a class="header" href="#kzg-commitment-scheme">KZG Commitment Scheme</a></h3>
<p>KZG is the first commitment scheme we intend to support, which is widely used in various ZKP systems such as Halo2. We have already presented an overview of KZG <a href="zk-memory/commitment/./../../kzg-polynomial-commitment-scheme/chapter.html">here</a>, therefore we refer the readers unfamiliar with KZG to the link. Let \(\mathsf{F}\) be a finite field, and let \(\omega\) be a root of \(4\)-th unity. To commit each trace in the trace, we first create a polynomial \(p(x)\) such that:</p>
<p>$$p(1)=addr,~p(\omega)=time,~p(\omega^2)=op,~p(\omega^3)=val$$</p>
<p>After creating the polynomial \(p(x)\), we use the KZG commitment algorithm to commit it which we denote \(\mathsf{com}(p(x))\), and the whole trace \(\mathsf{com}(p_i(x))_{i=1}^n\) is the commitment of the whole execution trace. Later, if needed, we can open any trace in the trace using the techniques in <a href="https://dankradfeist.de/ethereum/2021/06/18/pcs-multiproofs.html">this</a>, which provides constant opening size and verification time.</p>
<h3 id="merkle-tree-commitment-scheme"><a class="header" href="#merkle-tree-commitment-scheme">Merkle Tree Commitment Scheme</a></h3>
<p>Merkle Tree is the second commitment scheme we would support to commit the memory. At a high level, each leaf of a tree is assigned a value, and the value of the parent is equal to the hash of its children. When opening a leaf node, we only need to reveal all the values in the path from the leaf to the root as well as the sibling nodes in the path. The collision resistance property of cryptographic hash functions ensures that the prover cannot produce an invalid opening.</p>
<p>There are two methods for committing memory using Merkle tree. The first method is to commit to the trace, similar like what we did using KZG commitment. However there is a second method, which we commit to the <strong>memory cells</strong> instead of the trace, where we assign each leaf node to be a memory cell. In each step, we update the commitment from \(C\) to \(C'\) and provide a Verkle proof that \(C\) was indeed updated to \(C'\). This &quot;proof providing&quot; process can be built with a circuit to hide everything except the instances, which are \(C\) and \(C'\). The second method will be used to support memory consistency from IVC-based constructions like the Nova proof system, as currently we are additionally integrating Nova to support memory consistency in our zkMemory module.</p>
<h3 id="verkle-tree-commitment-scheme"><a class="header" href="#verkle-tree-commitment-scheme">Verkle Tree Commitment Scheme</a></h3>
<p>Verkle tree is very similar to Merkle tree, However, there are several benefits of using Verkle tree compared to Merkle tree as follows:</p>
<ul>
<li>The number of children of each parent node in Verkle tree is much greater, making the tree have a much lower height when committing the same data.</li>
<li>In addition, the number of children can be configured to one's desire, making the tree more flexible when using proof systems than Merkle Tree.</li>
</ul>
<p>Finally, to commit the memory with Verkle tree, we also do the same as Merkle tree, except that we now employ KZG commitment scheme to commit to the children, which enables constant proof size and verification time, which is also another huge benefit compared to Merkle tree according to <a href="https://dankradfeist.de/ethereum/2021/06/18/pcs-multiproofs.html">this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="memory-consistency-constraints"><a class="header" href="#memory-consistency-constraints">Memory Consistency Constraints</a></h2>
<h3 id="handling-the-constraints-using-sorting-technique"><a class="header" href="#handling-the-constraints-using-sorting-technique">Handling the Constraints using Sorting Technique</a></h3>
<p>For an array of execution traces \(tr=(addr_i,t_i,op_i,val_i)_{i=1}^n\), one known method to prove the correctness of \(tr\) is to use the <strong>sorting technique</strong>, which can be found in [<a href="zk-memory/constraints/../../bibliography.html#FKLO0W21">FKLO0W21</a>]. At a high level, we create a new array \(tr'\), which is a sorted version of \(tr\). The elements of \(tr'\) are sorted in <strong>increasing order</strong> by its address, then time log. We prove that the elements of \(tr'\) satisfy some specified constraints, then prove that \(tr\) and \(tr'\) are permutations of each other.</p>
<p>First, let us delve into the details of the constraints in \(tr'\). The constraints are as follows:</p>
<p>$$
\begin{cases}
time_i \lt time_{i+1}, \\
(op_{i+1}=1) \lor (addr_i'=addr_{i+1}'), \\
(addr_i' \lt addr_{i+1}' ) \lor ((addr_i'= addr_{i+1}') \land (time_i' \lt time_{i+1}')),\\
(op_{i+1}=1) \lor (val_i'=val_{i+1}') \lor (addr_{i}' \neq addr_{i+1}').\\
\end{cases}
$$</p>
<p>Let us explain the above constraints: Recall that in memory consistency, we simply need to prove that, for each memory cell, the value of the current step is equal to the value in the last step it was written. With this idea, we could sort the trace by their address first, then time and check them via the constraint \((addr_i' \lt addr_{i+1}' ) \lor ((addr_i'= addr_{i+1}') \land (time_i' \le time_{i+1}'))\). In this way, we can divide the array into consecutive ''blocks'' where each block contains the traces with the same address. In each block and each trace of it, we consider the time when the value is written (determined by \(val\) and \(op\)). We see that, if the value is written in the current step (\(op=1\)), then there is nothing to consider because we are writing a new value. Otherwise (\(op=0\)) meaning that we are reading from the cell, then the value \(val\) must be equal to the value of the previous trace in the block, and this can be captured by the constraint \( (op_{i+1}=1) \lor (val_i'=val_{i+1}') \lor (addr_{i}' \neq addr_{i+1}').\). Moreover, we need to ensure that the first time we access a memory cell, then the operation must be WRITE, which can be constrained by \( (op_{i+1}=1) \lor (addr_i'=addr_{i+1}')\), meaning that in every first trace in each block, the opcode of the trace must be \(1\). Finally, we need the original array to be sorted in ascending time, which can be captured via the constraint \( time_i \le time_{i+1}\). Thus, these constraints together are sufficient to check the consistency of the memory.</p>
<h3 id="integrating-halo2"><a class="header" href="#integrating-halo2">Integrating Halo2</a></h3>
<p>In this Section, we give a brief overview of handling constraints using Halo2. For readers who are new to Halo2, we refer to <a href="zk-memory/constraints/./../../halo2-for-dummies/chapter.html">halo2</a>. With the execution trace, we define our witness table where each row has the following config:</p>
<p>$$(addr,time,op,val,addr',dif,inv,time',op',val')$$</p>
<p>and the constraints (each must be equal to \(0\)) are rewritten in Halo2 as follows:</p>
<p>$$
\begin{cases}
C(time_i,time_{i+1})=0,  \\
(op_{i+1}-1)\cdot (addr_{i}'-addr_{i+1}')=0,  \\
C(addr_{i}'||time_{i}',addr_{i+1}'||time_{i+1}')=0, \\
(op_{i+1}'-1)\cdot (val_{i+1}'-val_i') \cdot ((addr_{i+1}'-addr_{i}') \cdot inv_{i+1} -1)=0.  \\
\end{cases}
$$</p>
<p>In the constraints above, we denote \(C\) to be the expression such that \(C(a,b)=0\) iff \(a \lt b\). The idea for construction this expression can be found in <a href="https://github.com/privacy-scaling-explorations/zkevm-circuits/blob/main/zkevm-circuits/src/state_circuit/lexicographic_ordering.rs">here</a>. At a high level, we parse \(a\) and \(b\) into \(256\)-bit chunks \((a_i)\) and \((b_i)\) for \(i=\{1,2\dots,32\}\) and look for the smallest \(j\) such that \(a_j \neq b_j\). Hence, it is equivalent to prove that \((b_j-a_j) \in \{1,\dots,255\}\) and \(a_i=b_i\) for all \(1\leq i
\leq j-1\). With this, the expression \(C\) can be written in high level as \(C=\mathsf{lookup}(b_j-a_j,\{1,\dots,255\})+\beta \cdot (\sum_{i=1}^{j-1}(b_i-a_i)\cdot \alpha^i )\) where \(\alpha ,\beta\) are random challenges generated by verifier, and \(\mathsf{lookup}(c,\{1,\dots,255\})\) is an expression that returns \(0\) if and only if \(c \in \{1,2\dots, 255\}\). Note that by Schwartz-Zippel lemma, we can see that if \(a \geq b\), then the expression \(C\) above does not return \(0\) with overwhelming probability.
In addition, for proving that \(tr\) and \(tr'\) are permutation of each other, we simply use the shuffle API from <a href="https://github.com/privacy-scaling-explorations/halo2/blob/9b33f9ce524dbb9133fc8b9638b2afd0571659a8/halo2_proofs/examples/shuffle_api.rs">here</a></p>
<p>Finally, with the constraints above, we could support proving memory consistency using Halo2. Our implementation for this can be found <a href="https://github.com/orochi-network/orochimaru/tree/main/zkmemory/src/constraints">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nova-and-supernova"><a class="header" href="#nova-and-supernova">Nova and SuperNova</a></h1>
<p>For Nova variants [<a href="zk-memory/nova-variant/../../bibliography.html#KS22">KS22</a>], we don't commit the execution trace to a polynomial, instead we commit value of each Memory cell \(M[add_j]\) in steps circuit to prove the memory consistency.</p>
<p>Given an initial memory \(M\) and a execution trace list \(tr\): </p>
<p>$$ (addr_i,instruction_i,value_i)_{i=1}^N$$</p>
<ul>
<li>\(\text{instruction}_i=0\), read \(value_i\) from \(M[addr_i]\)</li>
<li>\(\text{instruction}_i=1\), write \(value_i\) to \(M[addr_i]\)</li>
</ul>
<p>Every step \(j^{th}\) must satisfy following constraints:</p>
<ol>
<li>\(add_j \Leftarrow |M|\)</li>
<li>\((instruction_j - 1)\dot(M_j[add_j] - value_j) = 0\)</li>
<li>\(instruction_j \in \{ 0,1 \}\)</li>
</ol>
<p>In the implementation, we let \(z_i\) to be the \(i^{th}\) memory state, and the circuit has a witness input, the \(i^{th}\) trace record, consisting of \(addr_i\), \(instruction_i\) and \(value_i\). We also introduce the commitment to the memory at the last cell of \(z_i\) in application where one need to commit to the memory before proving.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="orand-public-randomness-beacon"><a class="header" href="#orand-public-randomness-beacon">Orand: Public Randomness Beacon</a></h2>
<p><strong>Orand</strong> leverages a <strong>Distributed Verifiable Random Function (DVRF)</strong>. In this setup, multiple participants collaborate in a distributed computational process to generate a single random value. Each participant contributes to the computation, but no individual can determine the outcome alone. This collective approach ensures that the resultant random value is both unpredictable and unbiased. Importantly, the generated value can be verified by anyone, maintaining transparency and eliminating the need for trust in any single third party, as the randomness's integrity is collectively assured and publicly verifiable.</p>
<h2 id="orocle-zkoracle-service"><a class="header" href="#orocle-zkoracle-service">Orocle: zkOracle Service</a></h2>
<p><strong>Orocle</strong> is a oracle service that fetches and verifies off-chain data to be used within blockchain smart contracts. Unlike traditional centralized oracles, Orocle operates on a provable model, reducing the risks associated with single points of failure and enhancing trust through a distributed network of nodes. This service is crafted to provide real-time, accurate data feeds for dynamic applications in the Web3 ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unlocking-the-web3-universe-orochi-networks-orocle-service"><a class="header" href="#unlocking-the-web3-universe-orochi-networks-orocle-service">Unlocking the Web3 Universe: Orochi Network's Orocle Service</a></h2>
<p>Imagine building a Web3 application that thrives on real-world data, free from centralized control. This is the vision behind Orochi Network's Orocle service, a powerful tool poised to revolutionize the way DApps interact with the external world.</p>
<p>Traditionally, DApps have struggled to access external data sources, relying on centralized oracles – single points of failure susceptible to manipulation and bias. Orochi's Orocle shatters these limitations, offering a decentralized, secure, and versatile solution for feeding accurate and verifiable data into your DApps.</p>
<h2 id="deployed-platform"><a class="header" href="#deployed-platform">Deployed Platform</a></h2>
<p>Orocle V2 was deployed on following smart contract platform.</p>
<h3 id="mainnet"><a class="header" href="#mainnet">Mainnet</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Network Name</th><th>Address</th></tr></thead><tbody>
<tr><td>Ancient8 Mainnet</td><td><a href="https://scan.ancient8.gg/address/0x80011aA6171B433d33c46B59A619FD338c155161">0x80011aA6171B433d33c46B59A619FD338c155161</a></td></tr>
<tr><td>U2U Solaris Mainnet</td><td><a href="https://u2uscan.xyz/address/0x6eFAA86dD3177d75d161A99e2c103409927f3C49">0x6eFAA86dD3177d75d161A99e2c103409927f3C49</a></td></tr>
<tr><td>BNB Chain</td><td><a href="https://bscscan.com/address/0xce978d96f761a0ae9dd252e666504482b74a4713">0xcE978D96f761a0AE9Dd252E666504482B74A4713</a></td></tr>
<tr><td>X Layer Mainnet</td><td><a href="https://www.okx.com/web3/explorer/xlayer/address/0x5cb715ddb32d0facd9c5b9e3a10f2ffceba93285">0x5cb715ddb32d0facd9c5b9e3a10f2ffceba93285</a></td></tr>
<tr><td>Saakuru (L2) Mainnet</td><td><a href="https://explorer.saakuru.network/address/0x5C27491559b3E438b18024A2d5C6f307fBD9Ba15">0x5C27491559b3E438b18024A2d5C6f307fBD9Ba15</a></td></tr>
<tr><td>Sei Mainnet</td><td><a href="https://seitrace.com/address/0xbA7f3cb53aA2De189b60c815Bca11ad9AEb2BA7E?chain=pacific-1">0x5C27491559b3E438b18024A2d5C6f307fBD9Ba15</a></td></tr>
<tr><td>Manta Pacific L2 Rollup</td><td><a href="https://pacific-explorer.manta.network/address/0x155bF6a23e5551b431cfb716D2c62409e49B03dd">0x155bF6a23e5551b431cfb716D2c62409e49B03dd</a></td></tr>
<tr><td>ZKsync Era Mainnet</td><td><a href="https://explorer.zksync.io/address/0x4e12287584A3a506755f8212311f6165336f98a9">0x4e12287584A3a506755f8212311f6165336f98a9</a></td></tr>
<tr><td>Scroll Mainnet</td><td><a href="https://scrollscan.com/address/0x59bcAa1fB8D336CE6103Ed95BD0929e78a1fcEf6">0x59bcAa1fB8D336CE6103Ed95BD0929e78a1fcEf6</a></td></tr>
<tr><td>Zircuit Mainnet</td><td><a href="https://explorer.zircuit.com/address/0xCB50b75b5CaF2F8A58e4842238475384fb6d5Ee6">0xCB50b75b5CaF2F8A58e4842238475384fb6d5Ee6</a></td></tr>
<tr><td>Phoenix Mainnet</td><td><a href="https://phoenix.lightlink.io/address/0x9A19D4065b91FE61664fE5C50f20048969729D74">0x9A19D4065b91FE61664fE5C50f20048969729D74</a></td></tr>
<tr><td>Etherlink Mainnet</td><td><a href="https://explorer.etherlink.com/address/0xF971965E35b8923DF33332561f69ce74547c3fE3">0xF971965E35b8923DF33332561f69ce74547c3fE3</a></td></tr>
<tr><td>5ireChain Mainnet</td><td><a href="https://5irescan.io/contract/evm/0xcAfEc24Fdb365e278bCF873B674CCC340734AE4f">0xcAfEc24Fdb365e278bCF873B674CCC340734AE4f</a></td></tr>
<tr><td>Zytron Mainnet</td><td><a href="https://explorer.zypher.network/address/0xEaC801617D35A62f6782Ce11f0E935DC5960817c">0xEaC801617D35A62f6782Ce11f0E935DC5960817c</a></td></tr>
<tr><td>Matchain Mainnet</td><td><a href="https://matchscan.io/address/0x5e0b469B7EfdECc5C781BC6FA2FFaBA1c2737a39">0x5e0b469B7EfdECc5C781BC6FA2FFaBA1c2737a39</a></td></tr>
<tr><td>Tangle Mainnet</td><td><a href="https://explorer.tangle.tools/address/0x8905422631B948c9B461a6b210142c3E3361E983">0x8905422631B948c9B461a6b210142c3E3361E983</a></td></tr>
<tr><td>Soneium Mainnet</td><td><a href="https://soneium.blockscout.com/address/0x1039Cd6d58e05ce4797E7fA971Fa9d332f96210d">0x1039Cd6d58e05ce4797E7fA971Fa9d332f96210d</a></td></tr>
<tr><td>Plume Mainnet</td><td><a href="https://explorer.plumenetwork.xyz/address/0x5a0EFE35dEBbC924f029f44653b8c32288C18175">0x5a0EFE35dEBbC924f029f44653b8c32288C18175</a></td></tr>
<tr><td>Base Mainnet</td><td><a href="https://base.blockscout.com/address/0x1Df0848aB779b1978392A6383487232BfB424b27">0x1Df0848aB779b1978392A6383487232BfB424b27</a></td></tr>
<tr><td>Abstract Mainnet</td><td><a href="https://abscan.org/address/0x202b52AC5a679CdD1aC46BcBE1211540CC05908B">0x202b52AC5a679CdD1aC46BcBE1211540CC05908B</a></td></tr>
</tbody></table>
</div>
<h3 id="testnet"><a class="header" href="#testnet">Testnet</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Network Name</th><th>Address</th></tr></thead><tbody>
<tr><td>Ancient8 Testnet</td><td><a href="https://scanv2-testnet.ancient8.gg/address/0xd26Ea014930305B498C5826cF0712F877CCAF93f">0xd26Ea014930305B498C5826cF0712F877CCAF93f</a></td></tr>
<tr><td>Unicorn Ultra Nebulas</td><td><a href="https://testnet.u2uscan.xyz/address/0x70523434ee6a9870410960E2615406f8F9850676">0x70523434ee6a9870410960E2615406f8F9850676</a></td></tr>
<tr><td>Sei Devnet</td><td><a href="https://seitrace.com/address/0x2cC3DF2fC577237A3Fa00634c3d90910211bdAc7?chain=arctic-1">0x2cC3DF2fC577237A3Fa00634c3d90910211bdAc7</a></td></tr>
<tr><td>Saakuru Testnet</td><td><a href="https://explorer.testnet.oasys.games/address/0xA346Ed72C477F5007866D6B9edCb1563af8cC23d">0xA346Ed72C477F5007866D6B9edCb1563af8cC23d</a></td></tr>
<tr><td>Zircuit Testnet</td><td><a href="https://explorer.testnet.zircuit.com/address/0x9eF4E958A94375436bA4071599BDF47f81E1d96f">0x9eF4E958A94375436bA4071599BDF47f81E1d96f</a></td></tr>
<tr><td>ZKFair Testnet</td><td><a href="https://testnet-scan.zkfair.io/address/0x4A9f4f5acF2E11eb4795f228805c6577876559e1">0x4A9f4f5acF2E11eb4795f228805c6577876559e1</a></td></tr>
<tr><td>X Layer Testnet</td><td><a href="https://www.okx.com/web3/explorer/xlayer-test/address/0x471434636bE5da937d401971267Dd56C1696C073">0x471434636bE5da937d401971267Dd56C1696C073</a></td></tr>
<tr><td>ZKLink Nova</td><td><a href="https://sepolia.explorer.zklink.io/address/0xb0b5fFeF72c6ea620689CF947C0458fAD5cF58da">0xb0b5fFeF72c6ea620689CF947C0458fAD5cF58da</a></td></tr>
<tr><td>BNB Chain Testnet</td><td><a href="https://testnet.bscscan.com/address/0xbC792147B026F2B998A97d6BC9718569Df79ec65">0xbC792147B026F2B998A97d6BC9718569Df79ec65</a></td></tr>
<tr><td>Arbitrum Sepolia Testnet</td><td><a href="https://sepolia.arbiscan.io/address/0x4ec4C6E856d0ce4D4bc57b50B9234DcD7c6c31BE">0x4ec4C6E856d0ce4D4bc57b50B9234DcD7c6c31BE</a></td></tr>
<tr><td>Moonbase Alpha Testnet</td><td><a href="https://moonbase.moonscan.io/address/0xCe4defA26b1820026136D71F2e00e291C479D656">0xCe4defA26b1820026136D71F2e00e291C479D656</a></td></tr>
<tr><td>Manta Pacific Sepolia Testnet</td><td><a href="https://pacific-explorer.sepolia-testnet.manta.network/address/0xc069da03509222325f9d51239E9F8E6F8cB953Eb">0xc069da03509222325f9d51239E9F8E6F8cB953Eb</a></td></tr>
<tr><td>Kroma Sepolia Testnet</td><td><a href="https://sepolia.etherscan.io/address/0x8519243FaeDcC4292c0b0ebB63b84020158bBE68">0x8519243FaeDcC4292c0b0ebB63b84020158bBE68</a></td></tr>
<tr><td>Fantom Testnet</td><td><a href="https://testnet.ftmscan.com/address/0xf20f36FBec4C592367D807112ddBd44275a1B2df">0xf20f36FBec4C592367D807112ddBd44275a1B2df</a></td></tr>
<tr><td>Base Sepolia Testnet</td><td><a href="https://base-sepolia.blockscout.com/address/0xC6b292b2c1bBDbFfbb0c415D3880DEd376dAd672">0xC6b292b2c1bBDbFfbb0c415D3880DEd376dAd672</a></td></tr>
<tr><td>Optimism Sepolia Testnet</td><td><a href="https://sepolia-optimistic.etherscan.io/address/0xCc00d46197FBee69d7C79661e2F89c17b12FFFf3">0xCc00d46197FBee69d7C79661e2F89c17b12FFFf3</a></td></tr>
<tr><td>Wanchain Testnet</td><td><a href="https://testnet.wanscan.org/address/0x5ad07a162a56E8e4621544fA5D9243CA83264053">0x5ad07a162a56E8e4621544fA5D9243CA83264053</a></td></tr>
<tr><td>Scroll Sepolia Testnet</td><td><a href="https://sepolia.scrollscan.dev/address/0xC385AbA69909502B439670Bc2d81FF6B4b30AD6e">0xC385AbA69909502B439670Bc2d81FF6B4b30AD6e</a></td></tr>
<tr><td>Morph Holesky Testnet</td><td><a href="https://explorer-holesky.morphl2.io/address/0xa43Df8eE133946f4f9e455722D7Ec9cb29A08740">0xa43Df8eE133946f4f9e455722D7Ec9cb29A08740</a></td></tr>
<tr><td>LightLink Pegasus Testnet</td><td><a href="https://pegasus.lightlink.io/address/0x9CB1bDc8D01841F1887f62a8F61813472B0cf1e4">0x9CB1bDc8D01841F1887f62a8F61813472B0cf1e4</a></td></tr>
<tr><td>Metis Sepolia Testnet</td><td><a href="https://sepolia-explorer.metisdevops.link/address/0xc02C419c3416484E088A8A96B59859D0Ea9d7e89">0xc02C419c3416484E088A8A96B59859D0Ea9d7e89</a></td></tr>
<tr><td>B² Testnet</td><td><a href="https://testnet-explorer.bsquared.network/address/0xD1159958Fb9d174230dD4B9Ae506AC2F518FD4Cf">0xD1159958Fb9d174230dD4B9Ae506AC2F518FD4Cf</a></td></tr>
<tr><td>StratoVM Sepolia Testnet</td><td><a href="https://explorer.stratovm.io/address/0xf48537f499c9bE20D5D261d765bECb4c20110bd2">0xf48537f499c9bE20D5D261d765bECb4c20110bd2</a></td></tr>
<tr><td>Core Blockchain Testnet</td><td><a href="https://scan.test.btcs.network/address/0x08f5A19CAE906E6851E38e6A1f1848464548D9ff">0x08f5A19CAE906E6851E38e6A1f1848464548D9ff</a></td></tr>
<tr><td>Linea Testnet</td><td><a href="https://sepolia.lineascan.build/address/0x4D214560D73215ec2a967B995aa4Afd69A4Bd470">0x08f5A19CAE906E6851E38e6A1f1848464548D9ff</a></td></tr>
<tr><td>Lumia Testnet</td><td><a href="https://testnet-explorer.lumia.org/address/0x4231579Bb5DB91d9ACB5A54482A1FA7Bbc08132a">0x4231579Bb5DB91d9ACB5A54482A1FA7Bbc08132a</a></td></tr>
<tr><td>Etherlink Testnet</td><td><a href="https://testnet.explorer.etherlink.com/address/0x6Fc8fcE9061977131A87D95458De69b9b4e36B1e">0x6Fc8fcE9061977131A87D95458De69b9b4e36B1e</a></td></tr>
<tr><td>IoTeX Testnet</td><td><a href="https://testnet.iotexscan.io/address/0xf49c2dfb6789c8643b772f8dd039e6cf5fdaf6ce">0xF49c2DFb6789C8643B772F8dd039E6cF5fdaF6CE</a></td></tr>
<tr><td>Chiado Testnet</td><td><a href="https://gnosis-chiado.blockscout.com/address/0xf40931591640833969ee404F1FFfc2C722eE402F">0xf40931591640833969ee404F1FFfc2C722eE402F</a></td></tr>
<tr><td>Minato Testnet</td><td><a href="https://explorer-testnet.soneium.org/address/0x544FE7b51EF279c15f82B2037e524eeCa1E610C3">0x544FE7b51EF279c15f82B2037e524eeCa1E610C3</a></td></tr>
<tr><td>AILayer Testnet</td><td><a href="https://testnet-explorer.ailayer.xyz/address/0x4995936C82D23c682DB5a6C811E06d8526914d45">0x4995936C82D23c682DB5a6C811E06d8526914d45</a></td></tr>
<tr><td>Polygon Amoy Testnet</td><td><a href="https://amoy.polygonscan.com/address/0xE4d4A21d13d55a8d3c2E2A90672ECb96557f1b6a">0xE4d4A21d13d55a8d3c2E2A90672ECb96557f1b6a</a></td></tr>
<tr><td>Boba Sepolia Testnet</td><td><a href="https://testnet.bobascan.com/address/0x595Dc78B75c58EE62335C787ceBf9B6791123126">0x595Dc78B75c58EE62335C787ceBf9B6791123126</a></td></tr>
<tr><td>NERO Testnet</td><td><a href="https://testnet.neroscan.io/address/0x702d504980a4ce8dd468ae68d5090a2022415bd2">0x702D504980A4cE8dd468ae68d5090A2022415bd2</a></td></tr>
<tr><td>Camp Network Testnet V2</td><td><a href="https://camp-network-testnet.blockscout.com/address/0x84877d49B4AAB22E1ddB710b209D647EDe9014df">0xE4d4A21d13d55a8d3c2E2A90672ECb96557f1b6a</a></td></tr>
<tr><td>5ireChain Testnet</td><td><a href="https://testnet.5irescan.io/contract/evm/0x3E36123bAE1d9EB392C32849324D093a45CEDd7F">0x3E36123bAE1d9EB392C32849324D093a45CEDd7F</a></td></tr>
<tr><td>Matchain Testnet</td><td><a href="https://testnet.matchscan.io/address/0x146a21217749E2Caf89dC8d558A604ED0556811A">0x146a21217749E2Caf89dC8d558A604ED0556811A</a></td></tr>
<tr><td>Neo X Testnet T4</td><td><a href="https://xt4scan.ngd.network/address/0x9Cbf2e0f820447e57D510AB6ECd8A12510228cD1">0x9Cbf2e0f820447e57D510AB6ECd8A12510228cD1</a></td></tr>
<tr><td>Berachain bArtio</td><td><a href="https://bartio.beratrail.io/address/0xA650a9cb01b86F8Ee6Af302E1BC7DC3e636cF384">0xA650a9cb01b86F8Ee6Af302E1BC7DC3e636cF384</a></td></tr>
<tr><td>Xprotocol Testnet</td><td><a href="https://explorer.testnet.xprotocol.org/address/0x4BF82218F6245a377B55ec3d550452BfC9462E1e">0x4BF82218F6245a377B55ec3d550452BfC9462E1e</a></td></tr>
<tr><td>Taiko Hekla</td><td><a href="https://hekla.taikoscan.io/address/0x50FD6cc6B5432D4500c4A1ee1e718CF90fbdd879">0x50FD6cc6B5432D4500c4A1ee1e718CF90fbdd879</a></td></tr>
<tr><td>Zytron Testnet</td><td><a href="https://explorer-testnet.zypher.network/address/0xd8E292643EA59e2CaE49de0e059485672cd70670">0xd8E292643EA59e2CaE49de0e059485672cd70670</a></td></tr>
<tr><td>Celo Testnet</td><td><a href="https://celo-alfajores.blockscout.com/address/0x0CA11ab5588D74d3a5eE61f3105D58D02298C029">0x0CA11ab5588D74d3a5eE61f3105D58D02298C029</a></td></tr>
<tr><td>Creator Testnet</td><td><a href="https://explorer.creatorchain.io/address/0xF159141Af20209b1d5539CFD2b073d4bc9EB6614">0xF159141Af20209b1d5539CFD2b073d4bc9EB6614</a></td></tr>
<tr><td>Monad Devnet</td><td><a href="https://explorer.monad-devnet.devnet101.com/address/0x6b214283b49255aDD892CBd84fBe6B11Eb7993d4">0x6b214283b49255aDD892CBd84fBe6B11Eb7993d4</a></td></tr>
<tr><td>0G Testnet</td><td><a href="https://chainscan-newton.0g.ai/address/0x18bb67e1695bcd1715ee60b323ac2a71aa61b805">0x18BB67E1695bCd1715eE60B323ac2A71aA61b805</a></td></tr>
<tr><td>Plume Devnet</td><td><a href="https://test-explorer.plumenetwork.xyz/address/0x892B1d1FE2F0b6AeA7E1eb3133480ec349F571bb">0x892B1d1FE2F0b6AeA7E1eb3133480ec349F571bb</a></td></tr>
<tr><td>Monad Testnet</td><td><a href="https://testnet.monadexplorer.com/address/0xf489dbe3Ae04cD5f4554F4b7df9F23443FC9e77b">0xf489dbe3Ae04cD5f4554F4b7df9F23443FC9e77b</a></td></tr>
<tr><td>Solo Testnet</td><td><a href="https://solo-testnet.explorer.caldera.xyz/address/0xBAEc9Ae0847568576a2DaF9a24246F5845cdac84">0x75Db90AC980B9f93fF7Ab54cE5F5BbF479DC86dA</a></td></tr>
<tr><td>Abstract Testnet</td><td><a href="https://sepolia.abscan.org/address/0x37ec7590D88d7664Bb759F04D9fCEf5F85d82D7B">0x37ec7590D88d7664Bb759F04D9fCEf5F85d82D7B</a></td></tr>
<tr><td>Lisk Testnet</td><td><a href="https://sepolia-blockscout.lisk.com/address/0x778465a251C605bE1e675c1e7ddc73a7e0b21938">0x778465a251C605bE1e675c1e7ddc73a7e0b21938</a></td></tr>
</tbody></table>
</div>
<h2 id="so-what-exactly-can-the-orochi-orocle-oracle-do"><a class="header" href="#so-what-exactly-can-the-orochi-orocle-oracle-do">So, what exactly can the Orochi Orocle (Oracle) do?</a></h2>
<ul>
<li><strong>Gather Diverse Data:</strong> Access a vast pool of information, from financial markets and weather updates to social media sentiment and IoT sensor readings. The possibilities are endless, empowering DApps with real-time, relevant data.</li>
<li><strong>Decentralized &amp; Trustworthy:</strong> Eliminate the risk of manipulation with a distributed network of nodes verifying and securing data integrity. No single entity controls the flow of information, fostering trust and transparency.</li>
<li><strong>Highly Scalable &amp; Efficient:</strong> Designed to handle high volumes of data requests efficiently, ensuring your DApp performs smoothly even with complex data integrations.</li>
<li><strong>Chain Agnostic:</strong> Integrate seamlessly with various blockchain platforms, offering flexibility and wider reach for your DApp.
But why is this important?</li>
</ul>
<h2 id="the-potential-applications-are-vast"><a class="header" href="#the-potential-applications-are-vast">The potential applications are vast:</a></h2>
<ul>
<li><strong>Decentralized finance (DeFi):</strong> Integrate real-world market data for dynamic pricing and risk management in DeFi protocols.</li>
<li><strong>Prediction markets:</strong> Enable accurate and trustworthy predictions based on real-time events and data.</li>
<li><strong>Supply chain management:</strong> Track goods movement and environmental conditions transparently across complex supply chains.</li>
<li><strong>Gaming &amp; Entertainment:</strong> Create immersive experiences that react to real-world events and user behavior.</li>
</ul>
<p>Orochi's Orocle is more than just a data feed; it's a gateway to a truly decentralized and data-driven future for Web3. By unlocking the power of real-world data, it empowers developers to build DApps that are not only innovative but also robust, secure, and truly impactful.</p>
<p>Ready to explore the possibilities? Dive into the world of Orochi Network and unleash the full potential of your Web3 vision.</p>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<p>Installing <code>@orochi-network/contracts</code> will help you interactive with Orochi Network Orocle and VRF (Orand) much more easier.</p>
<pre><code class="language-bash">npm i --save-dev @orochi-network/contracts
</code></pre>
<h2 id="orocle-aggregator-overview"><a class="header" href="#orocle-aggregator-overview">Orocle Aggregator Overview</a></h2>
<p>This section describes all methods of Orocle V2 that facilitate interaction from external smart contracts. To familiarize yourself with Orocle V2, the following terminology definitions may be helpful.</p>
<p><strong>appId:</strong> Application ID on Orocle, our oracle support multiple applications there are two of them listed here:</p>
<div class="table-wrapper"><table><thead><tr><th>Application ID</th><th>Description</th></tr></thead><tbody>
<tr><td>1</td><td>Asset Price</td></tr>
<tr><td>2</td><td>Cross Chain Data</td></tr>
</tbody></table>
</div>
<p><strong>round:</strong> Each application will have different round number, every time a new dataset submitted the round number will be increased by 1</p>
<p><strong>identifier:</strong> Data identifier, it's a <code>bytes20</code> used to index data on smart contract, for asset price application <code>identifier</code> is token's symbol</p>
<p><strong>Note:</strong></p>
<ul>
<li><em>Only 255 latest rounds will be cached on smart contract, you can not get more than 255 rounds from the current round by using <code>getData()</code> method</em></li>
<li><em>Round is uint64, so 2^64 is the limit of number of round</em></li>
</ul>
<h3 id="summary"><a class="header" href="#summary">Summary:</a></h3>
<ul>
<li>This contract defines an interface for interacting with an oracle aggregator.</li>
<li>It provides functions to retrieve application metadata, data, and round information.</li>
<li>It's designed for read-only access, as all functions are marked as view.</li>
</ul>
<h3 id="key-points"><a class="header" href="#key-points">Key Points:</a></h3>
<p>The IOrocleAggregatorV2 interface defines several methods:</p>
<ul>
<li><code>request(uint256 identifier, bytes calldata data)</code>: This function is used to create a new request. It takes an identifier and data as parameters and returns a boolean indicating whether the request was successful.</li>
<li><code>fulfill(uint256 identifier, bytes calldata data)</code>: This function is used to fulfill a request. It also takes an identifier and data as parameters and returns a boolean indicating whether the fulfillment was successful.</li>
<li><code>getMetadata(uint32 appId, bytes20 identifier)</code>: This function is used to get the metadata of a given application. It takes an application ID and an identifier as parameters and returns the round and the last update time.</li>
<li><code>getData(uint32 appId, uint64 round, bytes20 identifier)</code>: This function is used to get the data of an application for a specific round. It takes an application ID, a round number, and an identifier as parameters and returns the data.</li>
<li><code>getLatestData(uint32 appId, bytes20 identifier)</code>: This function is used to get the latest data of an application. It takes an application ID and an identifier as parameters and returns the data.</li>
<li><code>getLatestRound(uint32 appId, bytes20 identifier)</code>: This function is used to get the latest round of an application. It takes an application ID and an identifier as parameters and returns the round number, the last update time, and the data.</li>
</ul>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Here is an example of <code>AssetPrice</code> consumer:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@orochi-network/contracts/IOrocleAggregatorV2.sol';

contract ConsumerAssetPrice is Ownable {
  IOrocleAggregatorV2 private orocle;

  event SetOrocle(address indexed oldOrocle, address indexed newOrocle);

  constructor(address orocleAddress) {
    _setOrocle(orocleAddress);
  }

  function _setOrocle(address newOrocle) internal {
    emit SetOrocle(address(orocle), newOrocle);
    orocle = IOrocleAggregatorV2(newOrocle);
  }

  /**
   * Get price of an asset based USD
   * @dev Token price will use 18 decimal for all token
   * @param identifier Asset identifier (e.g. BTC, ETH, USDT)
   * @return price
   */
  function _getPrice(bytes20 identifier) internal view returns (uint256) {
    return uint256(orocle.getLatestData(1, identifier));
  }

  /**
   * Get price of a pair
   * @dev Token price will use 18 decimal for all token
   * (e.g. BTC/ETH =&gt; srcToken='BTC' dstToken='ETH')
   * @param srcToken Asset identifier of source
   * @param dstToken Asset identifier of destination
   * @return price
   */
  function _getPriceOfPair(bytes20 srcToken, bytes20 dstToken) internal view returns (uint256) {
    return (_getPrice(srcToken) * 10 ** 9) / (_getPrice(dstToken));
  }

  /**
   * Allow owner to set new Orocle address
   * @param newOrocle new Orocle address
   * @return success
   */
  function setOrocle(address newOrocle) external onlyOwner returns (bool) {
    _setOrocle(newOrocle);
    return true;
  }
}
</code></pre>
<p>Here is an example of <code>BitcoinSeller</code> that used <code>ConsumerAssetPrice</code>:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import './ConsumerAssetPrice.sol';

contract BitcoinSeller is ConsumerAssetPrice {
  constructor(address provider) ConsumerAssetPrice(provider) {}

  function estimate(uint256 amount) external view returns (uint256 total) {
    total = _getPrice('BTC') * amount;
  }

  function ethOverBtc() external view returns (uint256 price) {
    price = _getPriceOfPair('ETH', 'BTC');
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orand-v3"><a class="header" href="#orand-v3">Orand V3</a></h1>
<p>Orand project was built based on Elliptic Curve Verifiable Random Function (ECVRF). It is deterministic, verifiable and secured based on assumptions from elliptic curves. Administrators of Orochi Network are unable to manipulate the results.</p>
<p>To optimize operation costs and improve security we provided following features:</p>
<ul>
<li><strong>Verifiable:</strong> An Orand's epoch can be verified independently outside our system or can be verified by smart contracts.</li>
<li><strong>Self and Delegated Submission:</strong> Orand project have flexibility in proof submission, we just generate valid ECVRF proof and you can decide how to submit them:
<ul>
<li><strong>Self Submission:</strong> You can request from your back-end to Orand service and submit the randomness to your smart contract.</li>
<li><strong>Delegation Submission:</strong> You can delegate the submission process to Orochi Network by transfer token to our operator, so the feeding process will be performed automatically.</li>
<li><strong>Request Submission:</strong> Instead of request to Orand service, you can request randomness via Oracle contract.</li>
</ul>
</li>
<li><strong>Batching:</strong> We allow you to set the batching limit for one epoch, e.g., we can batch <code>100</code> randomness for one single epoch which makes the cost be reduced significantly.</li>
</ul>
<h2 id="deployed-platform-1"><a class="header" href="#deployed-platform-1">Deployed Platform</a></h2>
<p>Orand V3 was deployed on following smart contract platform.</p>
<h3 id="mainnet-1"><a class="header" href="#mainnet-1">Mainnet</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Network Name</th><th>Address</th></tr></thead><tbody>
<tr><td>Ancient8 Mainnet</td><td><a href="https://scan.ancient8.gg/address/0x970FD01B4427Ec1b48a8105aee7A3fc4E70E5FE5">0x970FD01B4427Ec1b48a8105aee7A3fc4E70E5FE5</a></td></tr>
<tr><td>U2U Solaris Mainnet</td><td><a href="https://u2uscan.xyz/address/0x635eB277805AFADDd720B873dfE87F8fc01b24e4">0x635eB277805AFADDd720B873dfE87F8fc01b24e4</a></td></tr>
<tr><td>BNB Chain</td><td><a href="https://bscscan.com/address/0x4DB03CC56421A81EC1398279913d8D55E62f5328">0x4DB03CC56421A81EC1398279913d8D55E62f5328</a></td></tr>
<tr><td>X Layer Mainnet</td><td><a href="https://www.okx.com/web3/explorer/xlayer/address/0x6254c96c3d96653FCD4A7133Ff138F97656522B7">0x6254c96c3d96653FCD4A7133Ff138F97656522B7</a></td></tr>
<tr><td>Saakuru (L2)</td><td><a href="https://explorer.saakuru.network/address/0x3CEA68A48c01Ff0759C3df54324b4E3B6F284303">0x3CEA68A48c01Ff0759C3df54324b4E3B6F284303</a></td></tr>
<tr><td>Sei Mainnet</td><td><a href="https://seitrace.com/address/0x6f24d4da6b9bBdbE4d5F2e3C663c8F1C617bdf13?chain=pacific-1">0x6f24d4da6b9bBdbE4d5F2e3C663c8F1C617bdf13</a></td></tr>
<tr><td>Manta Pacific L2 Rollup</td><td><a href="https://pacific-explorer.manta.network/address/0x2578F22C7488E08B6D8ED3Bb042b70a3444BF111">0x2578F22C7488E08B6D8ED3Bb042b70a3444BF111</a></td></tr>
<tr><td>ZKsync Era Mainnet</td><td><a href="https://explorer.zksync.io/address/0x29ca057761732432bcA26109A291291a365755b4">0x29ca057761732432bcA26109A291291a365755b4</a></td></tr>
<tr><td>Scroll Mainnet</td><td><a href="https://scrollscan.com/address/0x4e7dc620996e58A2BCba128c6b0C7e9e2De103dC">0x4e7dc620996e58A2BCba128c6b0C7e9e2De103dC</a></td></tr>
<tr><td>Zircuit Mainnet</td><td><a href="https://explorer.zircuit.com/address/0x99C2b1CcA077ceA2c84Fdc160aAc1A7f64ecf6be">0x99C2b1CcA077ceA2c84Fdc160aAc1A7f64ecf6be</a></td></tr>
<tr><td>Phoenix Mainnet</td><td><a href="https://phoenix.lightlink.io/address/0x0b226bf21B67A691775F9eDbc529D244FC79ab49">0x0b226bf21B67A691775F9eDbc529D244FC79ab49</a></td></tr>
<tr><td>Etherlink Mainnet</td><td><a href="https://explorer.etherlink.com/address/0xbaD95Bd46411785c1189a8dd06C1C354DE805170">0xbaD95Bd46411785c1189a8dd06C1C354DE805170</a></td></tr>
<tr><td>5ireChain Mainnet</td><td><a href="https://5irescan.io/contract/evm/0x53d56D3da563678f92CD87622fa72C1ae5c0876B">0x53d56D3da563678f92CD87622fa72C1ae5c0876B</a></td></tr>
<tr><td>Zytron Mainnet</td><td><a href="https://explorer.zypher.network/address/0x9bf3a59CDBb244f33bf40993e41893992624E665">0x9bf3a59CDBb244f33bf40993e41893992624E665</a></td></tr>
<tr><td>Matchain Mainnet</td><td><a href="https://matchscan.io/address/0x707dc1041dc702a83F7a0af57dDe1a3cdAC9643e">0x707dc1041dc702a83F7a0af57dDe1a3cdAC9643e</a></td></tr>
<tr><td>Tangle Mainnet</td><td><a href="https://explorer.tangle.tools/address/0xE41Bf77f68c37090364c1Fe73AF28d2CeF49C41d">0xE41Bf77f68c37090364c1Fe73AF28d2CeF49C41d</a></td></tr>
<tr><td>Soneium Mainnet</td><td><a href="https://soneium.blockscout.com/address/0x73a801b1438Bb41839504dd3Eaa2492989A902cf">0x73a801b1438Bb41839504dd3Eaa2492989A902cf</a></td></tr>
<tr><td>Plume Mainnet</td><td><a href="https://explorer.plumenetwork.xyz/address/0xC9395c0D17f4Ae1fFa0171b51a9eB189F7237e25">0xC9395c0D17f4Ae1fFa0171b51a9eB189F7237e25</a></td></tr>
<tr><td>Base Mainnet</td><td><a href="https://base.blockscout.com/address/0xa56013BDCC663B63C12f5ebddd0C754bF4fEf096">0xa56013BDCC663B63C12f5ebddd0C754bF4fEf096</a></td></tr>
<tr><td>Abstract Mainnet</td><td><a href="https://abscan.org/address/0x5b837C70feAD3ddCE3a1FA3049940e39dD16Bb2a">0x5b837C70feAD3ddCE3a1FA3049940e39dD16Bb2a</a></td></tr>
</tbody></table>
</div>
<h3 id="testnet-1"><a class="header" href="#testnet-1">Testnet</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Network Name</th><th>Address</th></tr></thead><tbody>
<tr><td>Ancient8 Testnet</td><td><a href="https://scanv2-testnet.ancient8.gg/address/0xD7a2643c1d9C3E6069f90DbAabd9D58825C7A2b9">0xD7a2643c1d9C3E6069f90DbAabd9D58825C7A2b9</a></td></tr>
<tr><td>Unicorn Ultra Nebulas</td><td><a href="https://testnet.u2uscan.xyz/address/0x3eAF9da360dA944105599cdB7833712346af6DF1">0x3eAF9da360dA944105599cdB7833712346af6DF1</a></td></tr>
<tr><td>Sei Devnet</td><td><a href="https://seitrace.com/address/0x2182fD816A3fCeCDeD390452524cfA8f21142A88?chain=arctic-1">0x2182fD816A3fCeCDeD390452524cfA8f21142A88</a></td></tr>
<tr><td>Saakuru Testnet</td><td><a href="https://explorer.testnet.oasys.games/address/0xA117B152a7bB8fAa9920e2C51B1Fb95452D2936f">0xA117B152a7bB8fAa9920e2C51B1Fb95452D2936f</a></td></tr>
<tr><td>Zircuit Testnet</td><td><a href="https://explorer.testnet.zircuit.com/address/0x1Ae52e0Ef3f78F015AEF13AbCB4776333fb073C2">0x1Ae52e0Ef3f78F015AEF13AbCB4776333fb073C2</a></td></tr>
<tr><td>ZKFair Testnet</td><td><a href="https://testnet-scan.zkfair.io/address/0xE733CaC2c60effe593587E595Ef6F98dA44a7cf4">0xE733CaC2c60effe593587E595Ef6F98dA44a7cf4</a></td></tr>
<tr><td>X Layer Testnet</td><td><a href="https://www.okx.com/web3/explorer/xlayer-test/address/0x50C72F5bea0757c8052daa6402568d4bbf2336Fb">0x50C72F5bea0757c8052daa6402568d4bbf2336Fb</a></td></tr>
<tr><td>ZKLink Nova</td><td><a href="https://sepolia.explorer.zklink.io/address/0xf9338096bb1bCdBDB83E5a237F198A60A48395a2">0xf9338096bb1bCdBDB83E5a237F198A60A48395a2</a></td></tr>
<tr><td>BNB Chain Testnet</td><td><a href="https://testnet.bscscan.com/address/0xA9aA047CaA5C24A4fC390F3887C98b20bc4e6556">0xA9aA047CaA5C24A4fC390F3887C98b20bc4e6556</a></td></tr>
<tr><td>Arbitrum Sepolia Testnet</td><td><a href="https://sepolia.arbiscan.io/address/0x398027eA740de745FE4Be768e6e5744A6C58514C">0x398027eA740de745FE4Be768e6e5744A6C58514C</a></td></tr>
<tr><td>Moonbase Alpha Testnet</td><td><a href="https://moonbase.moonscan.io/address/0xb368A56355707bC23321C85a9f2f1773B09a5a22">0xb368A56355707bC23321C85a9f2f1773B09a5a22</a></td></tr>
<tr><td>Manta Pacific Sepolia Testnet</td><td><a href="https://pacific-explorer.sepolia-testnet.manta.network/address/0x060b6352406f6a22a5BAfCB372EDa87a3B077D23">0x060b6352406f6a22a5BAfCB372EDa87a3B077D23</a></td></tr>
<tr><td>Kroma Sepolia Testnet</td><td><a href="https://sepolia.etherscan.io/address/0xabD720eaf47339150E0d0dF379307a17A68092Ac">0xabD720eaf47339150E0d0dF379307a17A68092Ac</a></td></tr>
<tr><td>Fantom Testnet</td><td><a href="https://testnet.ftmscan.com/address/0xc3A7a16304D08002c27441e9e2Cb6366E97862B2">0xc3A7a16304D08002c27441e9e2Cb6366E97862B2</a></td></tr>
<tr><td>Base Sepolia Testnet</td><td><a href="https://base-sepolia.blockscout.com/address/0x6240Cb830Ab06cd872827b92D6E9Fe9cA8Eac432">0x6240Cb830Ab06cd872827b92D6E9Fe9cA8Eac432</a></td></tr>
<tr><td>Optimism Sepolia Testnet</td><td><a href="https://sepolia-optimistic.etherscan.io/address/0x518fF0Ad9549BbB38000459C6F70bc78718cC0B1">0x518fF0Ad9549BbB38000459C6F70bc78718cC0B1</a></td></tr>
<tr><td>Wanchain Testnet</td><td><a href="https://testnet.wanscan.org/address/0xD682B35eB08cC3cb74F690f6B8fFAE087625a158">0xD682B35eB08cC3cb74F690f6B8fFAE087625a158</a></td></tr>
<tr><td>Scroll Sepolia Testnet</td><td><a href="https://sepolia.scrollscan.dev/address/0x25fa439D1030540FCd9B2E67F0e8A704ad078226">0x25fa439D1030540FCd9B2E67F0e8A704ad078226</a></td></tr>
<tr><td>Morph Holesky Testnet</td><td><a href="https://explorer-holesky.morphl2.io/address/0x6d660F6e9bC72709c96448dEe00D0c08cfD77577">0x6d660F6e9bC72709c96448dEe00D0c08cfD77577</a></td></tr>
<tr><td>LightLink Pegasus Testnet</td><td><a href="https://pegasus.lightlink.io/address/0x591749260B0dEc690976ce1dDFbd71694578b99e">0x591749260B0dEc690976ce1dDFbd71694578b99e</a></td></tr>
<tr><td>Metis Sepolia Testnet</td><td><a href="https://sepolia-explorer.metisdevops.link/address/0xD2Aaf6e041596431D7df35aC95e7BA74735266cD">0xD2Aaf6e041596431D7df35aC95e7BA74735266cD</a></td></tr>
<tr><td>B² Testnet</td><td><a href="https://testnet-explorer.bsquared.network/address/0xE21Bc6E404A4133119A164352477C1439205Af27">0xE21Bc6E404A4133119A164352477C1439205Af27</a></td></tr>
<tr><td>StratoVM Sepolia Testnet</td><td><a href="https://explorer.stratovm.io/address/0x2f685A31c47a0C9141EB5B2aF52cC2987a336B70">0x2f685A31c47a0C9141EB5B2aF52cC2987a336B70</a></td></tr>
<tr><td>Core Blockchain Testnet</td><td><a href="https://scan.test.btcs.network/address/0x396BBaA9eFfDFFa790e53b1a6b93AA161d65Cb75">0x396BBaA9eFfDFFa790e53b1a6b93AA161d65Cb75</a></td></tr>
<tr><td>Linea Testnet</td><td><a href="https://sepolia.lineascan.build/address/0x9FC1eE65D0485F2CFeeC5237D765DE5Af3f3f31c">0x9FC1eE65D0485F2CFeeC5237D765DE5Af3f3f31c</a></td></tr>
<tr><td>Lumia Testnet</td><td><a href="https://testnet-explorer.lumia.org/address/0x5379742183018F098c160EeEf7DBe3187a23AA3A">0x5379742183018F098c160EeEf7DBe3187a23AA3A</a></td></tr>
<tr><td>Etherlink Testnet</td><td><a href="https://testnet.explorer.etherlink.com/address/0x3e84eB29Df33832DE7c0E65BE3cC23F07Cb2fBdf">0x3e84eB29Df33832DE7c0E65BE3cC23F07Cb2fBdf</a></td></tr>
<tr><td>IoTeX Testnet</td><td><a href="https://testnet.iotexscan.io/address/0xB7a2e1ffa0Aaef491d381ABA2e07668f98B02C49">0xB7a2e1ffa0Aaef491d381ABA2e07668f98B02C49</a></td></tr>
<tr><td>Chiado Testnet</td><td><a href="https://gnosis-chiado.blockscout.com/address/0xE161A02Da435F36EC5EbfEAE84a0B81616Fa5F22">0xE161A02Da435F36EC5EbfEAE84a0B81616Fa5F22</a></td></tr>
<tr><td>Minato Testnet</td><td><a href="https://explorer-testnet.soneium.org/address/0x219Eed0551cB8BCf55b61e1CFB353f4Ad1F5bcF7">0x219Eed0551cB8BCf55b61e1CFB353f4Ad1F5bcF7</a></td></tr>
<tr><td>AILayer Testnet</td><td><a href="https://testnet-explorer.ailayer.xyz/address/0x2210b037302Ea78CD424f484d70Db1a8E1118FfB">0x2210b037302Ea78CD424f484d70Db1a8E1118FfB</a></td></tr>
<tr><td>Polygon Amoy Testnet</td><td><a href="https://amoy.polygonscan.com/address/0xd7a077a983986d9b948ff76c2151ba7e9ada0b91">0xD7a077a983986D9B948FF76C2151ba7e9ADA0b91</a></td></tr>
<tr><td>Boba Sepolia Testnet</td><td><a href="https://testnet.bobascan.com/address/0xebEA88C5462f434174599dcE51D061695296543d">0xebEA88C5462f434174599dcE51D061695296543d</a></td></tr>
<tr><td>NERO Testnet</td><td><a href="https://testnet.neroscan.io/address/0x38453d36e5152feca8a44cd020c3c607bb68a436">0x38453d36e5152feca8a44cd020c3c607bb68a436</a></td></tr>
<tr><td>Camp Network Testnet V2</td><td><a href="https://camp-network-testnet.blockscout.com/address/0x0b43fc1C8fc373D3abDE9bb6bb8B7CfDc0Beb72A">0x0b43fc1C8fc373D3abDE9bb6bb8B7CfDc0Beb72A</a></td></tr>
<tr><td>5ireChain Testnet</td><td><a href="https://testnet.5irescan.io/contract/evm/0x756887E2E85339822b97A943Fc750F7E5f354F26">0x756887E2E85339822b97A943Fc750F7E5f354F26</a></td></tr>
<tr><td>Matchain Testnet</td><td><a href="https://testnet.matchscan.io/address/0x59904eBEE55bea1B683eC34D68134585671BedB9">0x59904eBEE55bea1B683eC34D68134585671BedB9</a></td></tr>
<tr><td>Neo X Testnet T4</td><td><a href="https://xt4scan.ngd.network/address/0xD5C278C3b58d6789Af4972cECBB5953c3837c2Cd">0xD5C278C3b58d6789Af4972cECBB5953c3837c2Cd</a></td></tr>
<tr><td>Berachain bArtio</td><td><a href="https://bartio.beratrail.io/address/0xf1284bb2e359Bf04ccca4FB3eBE4385376C2941a">0xf1284bb2e359Bf04ccca4FB3eBE4385376C2941a</a></td></tr>
<tr><td>Xprotocol Testnet</td><td><a href="https://explorer.testnet.xprotocol.org/address/0xf1284bb2e359Bf04ccca4FB3eBE4385376C2941a">0xf1284bb2e359Bf04ccca4FB3eBE4385376C2941a</a></td></tr>
<tr><td>Taiko Hekla</td><td><a href="https://hekla.taikoscan.io/address/0xe199ed86eC10AA7d11B90A0bC9D43886756B556C">0xe199ed86eC10AA7d11B90A0bC9D43886756B556C</a></td></tr>
<tr><td>Zytron Testnet</td><td><a href="https://explorer-testnet.zypher.network/address/0x85c06130E58EEC77694f9b968B533121F0D828dC">0x85c06130E58EEC77694f9b968B533121F0D828dC</a></td></tr>
<tr><td>Celo Testnet</td><td><a href="https://celo-alfajores.blockscout.com/address/0x1F2AFb2Ac6c0517f3896F095ED15f77bF9621388">0x1F2AFb2Ac6c0517f3896F095ED15f77bF9621388</a></td></tr>
<tr><td>Creator Testnet</td><td><a href="https://explorer.creatorchain.io/address/0xb4fa8033b3Ce474898a0874c3684D5f206949ee4">0xb4fa8033b3Ce474898a0874c3684D5f206949ee4</a></td></tr>
<tr><td>Monad Devnet</td><td><a href="https://explorer.monad-devnet.devnet101.com/address/0xCfCE087475c599D960c5e98d7Bba2bA6F039B894">0xCfCE087475c599D960c5e98d7Bba2bA6F039B894</a></td></tr>
<tr><td>0G Testnet</td><td><a href="https://chainscan-newton.0g.ai/address/0x17Aa53215cf8F2B6Ad7e63Eaa3a1B00c58f993A0">0x17Aa53215cf8F2B6Ad7e63Eaa3a1B00c58f993A0</a></td></tr>
<tr><td>Plume Devnet</td><td><a href="https://test-explorer.plumenetwork.xyz/address/0x9fa70a7f324b5ABf35b05De590489F9B9474550a">0x9fa70a7f324b5ABf35b05De590489F9B9474550a</a></td></tr>
<tr><td>Monad Testnet</td><td><a href="https://testnet.monadexplorer.com/address/0x75Db90AC980B9f93fF7Ab54cE5F5BbF479DC86dA">0x75Db90AC980B9f93fF7Ab54cE5F5BbF479DC86dA</a></td></tr>
<tr><td>Solo Testnet</td><td><a href="https://solo-testnet.explorer.caldera.xyz/address/0x4C56588BA8a3948D699D11e86cC97Ce97746795C">0x4C56588BA8a3948D699D11e86cC97Ce97746795C</a></td></tr>
<tr><td>Abstract Testnet</td><td><a href="https://sepolia.abscan.org/address/0xEE33B2502b2c0eE8d7e646ac78e668Ce198F49e5">0xEE33B2502b2c0eE8d7e646ac78e668Ce198F49e5</a></td></tr>
<tr><td>Lisk Testnet</td><td><a href="https://sepolia-blockscout.lisk.com/address/0x19D12695f55D8B9A26216d8807a04e1e19d9533f">0x19D12695f55D8B9A26216d8807a04e1e19d9533f</a></td></tr>
</tbody></table>
</div>
<h2 id="self-submission"><a class="header" href="#self-submission">Self Submission</a></h2>
<p>User will request the verifiable randomness from Orand service, they can submit the randomness themselves and control gas consumption. You must submit epoch by sequence and starting epoch or genesis must be epoch <code>0</code>.</p>
<pre class="mermaid">%%{init: {'theme':'neutral'}}%%
sequenceDiagram
    Game Backend-&gt;&gt;+Orand: Request randomness
    Orand-&gt;&gt;-Game Backend: VRF Epoch
    Game Backend-&gt;&gt;+Orand Contract: Publish VRF Epoch
    Orand Contract-&gt;&gt;-Game Backend: Transaction Receipt
</pre>
<h2 id="delegated-submission"><a class="header" href="#delegated-submission">Delegated Submission</a></h2>
<p>User will delegate the submission process to Orochi Network, first they need to deposit native token to operator address that provided by Orochi Network.</p>
<pre class="mermaid">%%{init: {'theme':'neutral'}}%%
sequenceDiagram
    Game Backend-&gt;&gt;+Orand: Request randomness
    Orand-&gt;&gt;+Orand Contract: Publish VRF Epoch
    Orand Contract-&gt;&gt;-Orand: Transaction Receipt
    Orand-&gt;&gt;-Game Backend: VRF Epoch + Tx Receipt
</pre>
<h2 id="request-submission"><a class="header" href="#request-submission">Request Submission</a></h2>
<p>dApp will request to Orochi Network's oracle contract for the randomness, Orand service will fulfill this request and submit the randomness to Orand provider contract.</p>
<pre class="mermaid">%%{init: {'theme':'neutral'}}%%
sequenceDiagram
    Game Frontend-&gt;&gt;+Oracle: Request randomness
    Orand-&gt;&gt;+Orand: Repeating Polling Request
    Orand-&gt;&gt;-Orand Contract: Fulfil Request
    Oracle-&gt;&gt;Game Frontend: Tx Receipt
</pre>
<h2 id="orand-v3-1"><a class="header" href="#orand-v3-1">Orand V3</a></h2>
<p>Orand V3 will focus on utilizing Multi Party Computation (MPC) to secure the randomness generation, allowing the whole system to act as one random oracle. It makes the process more dispersed. In this stage, we boot up <strong>Chaos Theory Alliance</strong> to preventing predictability. Everything is built up toward to the vision of <strong>Decentralized Random Number Generator</strong>. If you believe in the vision of <strong>Decentralized Random Number Generator</strong>, please send drop us an email to (<a href="orochi-network/contact@orochi.network">contact@orochi.network</a>) in order to participate in <strong>Chaos Theory Alliance</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="installation-1"><a class="header" href="#installation-1">Installation</a></h3>
<p>Installing <code>@orochi-network/contracts</code> will help you interactive with Orochi Network Oracle and VRF (Orand) much more easier.</p>
<pre><code class="language-bash">npm i --save-dev @orochi-network/contracts
</code></pre>
<h3 id="dice-game-example"><a class="header" href="#dice-game-example">Dice Game Example</a></h3>
<p>The game is quite easy. You roll the dice and <code>Orand</code> will give you the verifiable randomness so you can calculate the dice number. You can check the source code of the <a href="https://github.com/orochi-network/smart-contracts/blob/main/contracts/examples/DiceGame.sol">Dice Game</a>.</p>
<p>If you request via smart contract, you can skip <code>Orand Code Integration</code> and <code>API Reference</code>. Just need to check the example is enough, and request randomness from Oracle by using this code:</p>
<pre><code class="language-ts">// Request randomness from Orand
IOracleAggregatorV1(oracle).request(0, &quot;0x&quot;);
</code></pre>
<ul>
<li><code>oracle</code> is the address of Orochi Network's oracle</li>
<li><code>0</code> is Orand application id</li>
<li><code>&quot;0x&quot;</code> is null data</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<h2 id="initial"><a class="header" href="#initial">Initial</a></h2>
<p>We assume that you have an initialized instance of Orand.</p>
<pre><code class="language-ts">import { Orand } from &quot;@orochi-network/sdk&quot;;

let orand = await Orand.fromRPC(
  {
    user: &quot;YOUR_REGISTERED_USERNAME&quot;,
    secretKey: &quot;YOUR_REGISTERED_SECRET&quot;,
    url: &quot;https://orand-test.orochi.network&quot;,
    consumerAddress: &quot;YOUR_APPLICATION_SMART_CONTRACT_ADDRESS&quot;,
  },
  &quot;https://rpcv2-testnet.ancient8.gg/&quot;
);
</code></pre>
<p><strong>Properties:</strong></p>
<p>Orand instance will provide following properties:</p>
<ul>
<li><code>rpcProvider</code>: The instance of <code>ethers.JsonRpcProvider</code> that will be used for static call and publish new epoch</li>
<li><code>orandProviderV2</code>: The instance of <code>ethers.Contract</code> that represent for <code>OrandProviderV2</code> smart contract. You can access all static method and interactive with provider smart contract of Orand after connect wallet.</li>
</ul>
<p><strong>Note:</strong></p>
<p>To prevent replay attack, we're required you to input <code>consumerAddress</code>. It's a smart contract address that will consume the randomness. Each <code>consumerAddress</code> will have different epoch target, you only able to to submit the epoch which has the matched epoch with target epoch on <code>OrandProviderV2</code> smart contract.</p>
<p>Some results will be returned in <code>BigInt</code> due to new update from <code>ethers.js</code>.</p>
<h3 id="newprivateepoch-promiseorandepoch"><a class="header" href="#newprivateepoch-promiseorandepoch">.newPrivateEpoch(): Promise&lt;OrandEpoch&gt;</a></h3>
<pre><code class="language-ts">await orandInstance.newPrivateEpoch();
</code></pre>
<p>Allowed you to generate a new private epoch that bound to <code>consumerAddress</code>. The <code>consumerAddress</code> need to be registered on Orand V2 service.</p>
<p><strong>Result:</strong></p>
<ul>
<li><code>epoch</code>: Epoch number</li>
<li><code>alpha</code>: Seed of new epoch, <code>alpha</code> is the result of previous epoch</li>
<li><code>gamma</code>, <code>c</code>, <code>s</code>: Value of proof</li>
<li><code>y</code>: Result of new epoch</li>
<li><code>witnessAddress</code>, <code>witnessGamma</code>, <code>witnessHash</code>, <code>inverseZ</code>: Intermediate witness to prove given proof on smart contract.</li>
<li><code>signatureProof</code>: ECDSA proof that bound to new epoch.</li>
</ul>
<p><strong>Output:</strong></p>
<pre><code class="language-js">{
  epoch: 2,
  alpha: '6be9719911e75d8f9a889f13e7c8c703c859d8ff9c89dcf6aa8db219d5fc2d45',
  gamma: 'ef1408aa85d25157678b32423c467782a88fc9496a46d2adfef99019009eca3c278fa01773e51f6f72b27cf81e1eaf2e8a5855a7a705d87505734f2d1bf11e45',
  c: '0ab76c3ae301adae9fe4f4884c58e1c959f17d6ecbe8e0b1b9ed68353eebcf36',
  s: '2dc6a1202f37c91d373692d56754a9b8073ac298de3648080fa9483d8d5b2916',
  y: '5ba1272ccd60a4f450ded626d643611ef9419c7e7f4c9b742aca7688f7d3aa13',
  witnessAddress: '8495933d0449927c604dd6a855451feefa16013e',
  witnessGamma: '8797c2ef56f31ec34064de5a3df12d36b4db15dc0a97bd62d2687fff0e8acd46000dc045b4fa0d6fbc6325da0b80a2e5dd68623ecf03f5178e6adc89a442f530',
  witnessHash: '84b8797fad42b6851f9512be3222b10515edccd783f9a9505fe529e0aad5e96f3f6f21a38ead57ef1e61e61f95e1b5006f36a62b013db603da267c38303ce132',
  inverseZ: '336dd6497177819a37003c4b962c2196a41caf1649d9d397e13115dadbb1e373',
  signatureProof: '2c8d0c95decdadc5e7ebfb883956a66c3005de9beb95adc83da0d5882b0b7241086c833fde2898ea110fc86eb3d8a4fc2cd64d46c87a5966b3cb526475ced89e1b0000000000000000000000020f53d56bce68dc724687a1c89eea793fd67788811827aba56be6cb832e9eb3439919067afc8aec364399c6d155a6589cd67099b4',
  createdDate: '2024-01-29T05:17:33.536051'
}
</code></pre>
<h3 id="getprivateepochepoch-number-promiseorandepoch"><a class="header" href="#getprivateepochepoch-number-promiseorandepoch">getPrivateEpoch(epoch?: number): Promise&lt;OrandEpoch[]&gt;</a></h3>
<p><strong>Usage:</strong></p>
<pre><code class="language-ts">await orandInstance.getPrivateEpoch(0);
</code></pre>
<p>Get recent private epochs.</p>
<p><strong>Params:</strong></p>
<ul>
<li><code>epoch</code>: Allowed you to get a list of most recent public epochs that close to <code>epoch</code>, it will return an array of <code>OrandEpoch</code>. The result will be limited to 20 records to prevent Denial of Service. If <code>epoch</code> wasn't supplied it will return latest epochs.</li>
</ul>
<p><strong>Result:</strong></p>
<p>It will return an array of <code>OrandEpoch</code>.</p>
<pre><code class="language-js">[
  {
    epoch: 0,
    alpha: &quot;e6d494bec47311a7d792ec1fdad02e8f79125ff515ceafe304e8dff27286c21a&quot;,
    gamma:
      &quot;8be62be49e7ccb015e0df3e4326867f3e49187918a70b7350327f3d83d1e439022859a04162b2053f1dc7d3ce83c2be3ef1470fadfd58950d43b2031859bba64&quot;,
    c: &quot;fa9c9ee4923b02b1aabaacdb8b60e3f421e5e6b8930e7ee45e4d53668d18b210&quot;,
    s: &quot;3ed451751452a03443c46012c39ee68efedde1fd53d8ee81cb359cdae2d00b93&quot;,
    y: &quot;be15ac8e5bd156fe925f3a9879100593f9cd8179713b04ac0ad2ded57fc6b7e8&quot;,
    witnessAddress: &quot;7625d458345eba3a97b307315e517c341aa4eed4&quot;,
    witnessGamma:
      &quot;9470d583d5f5c246b8be72f72ac4a905b6e89d21ebbb4362338fde837f45af0e680d0cd0885b06fde511d1eeed5078d7cef502a3ad9dd7c5bf39eacb554f0a6c&quot;,
    witnessHash:
      &quot;d712ca266f9b43346aec040e61ec2be1ecf6beb9fe5276cc1e15286d37a635b919c124d8615cff81a0a8e81bf6e948e5c2b4678efc37c3febfbc71e4a0b106c6&quot;,
    inverseZ:
      &quot;18537553a604b09da948eaf7a5b2aee9833f649556e6c891ddc629d380d04337&quot;,
    signatureProof:
      &quot;1351bc757f1b3579afb04c60ef44b51ca9ec89da6141366bd030a3672b4928925aab4b31b4660fa3437d1ae55602c0474d9e5f0985d1a71c8b222670b3d9f7991b0000000000000000000000000f53d56bce68dc724687a1c89eea793fd677888151596c361cefc7f4781008cf9f0d044fcb2607515896666e20ab1eae18e9a63d&quot;,
    createdDate: &quot;2024-01-28T07:16:59.853007&quot;,
  },
];
</code></pre>
<h3 id="verifyepochepochecvrfproof-orandepoch-promiseverifyepochproofresult"><a class="header" href="#verifyepochepochecvrfproof-orandepoch-promiseverifyepochproofresult">verifyEpoch(epochECVRFProof: OrandEpoch): Promise&lt;VerifyEpochProofResult&gt;</a></h3>
<p><strong>Usage:</strong></p>
<pre><code class="language-ts">await orandInstance.verifyEpoch(epoch);
</code></pre>
<p>Validate an epoch is valid or not, it also check current epoch link status.</p>
<p><strong>Params:</strong></p>
<ul>
<li><code>epoch</code>: A epoch of Orand, it can obtain by <code>getPrivateEpoch()</code>, <code>newPrivateEpoch()</code></li>
</ul>
<p><strong>Result:</strong></p>
<ul>
<li><code>ecdsaProof</code>: Decomposed ECDSA proof
<ul>
<li><code>signer</code>: Signer address of given signature</li>
<li><code>receiverAddress</code>: Bound address to proof</li>
<li><code>receiverEpoch</code>: Bound epoch to proof</li>
<li><code>ecvrfProofDigest</code>: Digest of proof in <code>BigInt</code>, it can be convert to hex by <code>toString(16)</code></li>
</ul>
</li>
<li><code>currentEpochNumber</code>: Current epoch of given receiver</li>
<li><code>isEpochLinked</code>: Is this epoch linked to on-chain state</li>
<li><code>isValidDualProof</code>: Validity of dual proof</li>
<li><code>currentEpochResult</code>: On-chain epoch result, it will equal to <code>0n</code> if there is no genesis</li>
<li><code>verifiedEpochResult</code>: Result of verifying epoch</li>
</ul>
<p><strong>Output:</strong></p>
<pre><code class="language-js">{
  ecdsaProof: {
    signer: '0xED6A792F694b7a52E7cf4b7f02dAa41a7c92f362',
    receiverAddress: '0x3fc4344b63fb1AB35a406Cb90ca7310EC8687585',
    receiverEpoch: 0n,
    ecvrfProofDigest: 50338440222419549417414658096744085875859237350056663794916275947847078497254n
  },
  currentEpochNumber: 0n,
  isEpochLinked: false,
  isValidDualProof: true,
  currentEpochResult: 0n,
  verifiedEpochResult: 26822046345614045141848002846382424881390702704278990878694727729734354152825n
}
</code></pre>
<h3 id="publishproof-orandepoch-wallet-contractrunner-promisecontracttransactionresponse"><a class="header" href="#publishproof-orandepoch-wallet-contractrunner-promisecontracttransactionresponse">publish(proof: OrandEpoch, wallet: ContractRunner): Promise&lt;ContractTransactionResponse&gt;</a></h3>
<p><strong>Usage:</strong></p>
<pre><code class="language-ts">const wallet = Wallet.fromPhrase(
  &quot;YOUR_WALLET_PASSPHRASE&quot;
  orandInstance.rpcProvider
);

const newEpoch = await orandInstance.newPrivateEpoch();
console.log(newEpoch);
console.log(await orandInstance.publish(newEpoch, wallet));
</code></pre>
<p>Publish a new epoch to blockchain.</p>
<p><strong>Params:</strong></p>
<ul>
<li><code>proof</code>: A epoch of Orand, it can obtain by <code>getPrivateEpoch()</code>, <code>newPrivateEpoch()</code></li>
<li><code>wallet</code>: The wallet that going to pay for transaction fee</li>
</ul>
<p><strong>Result:</strong></p>
<p>This method will return <code>ethers.ContractTransactionResponse</code>.</p>
<p><strong>Output:</strong></p>
<pre><code class="language-js">{
  provider: JsonRpcProvider {},
  blockNumber: null,
  blockHash: null,
  index: undefined,
  hash: '0x9c9330c9eedb694c5a7a0f16fd90484cf6b341fe3ec37064707970fb7bb0bbcb',
  type: 2,
  to: '0xfB40e49d74b6f00Aad3b055D16b36912051D27EF',
  from: '0x7Ba5A9fA3f3BcCeE36f60F62a6Ef728C3856b8Bb',
  nonce: 27,
  gasLimit: 108996n,
  gasPrice: undefined,
  maxPriorityFeePerGas: 1000000n,
  maxFeePerGas: 1000210n,
  data: '0x7fcde1c20000000000000000000000003fc4344b63fb1ab35a406cb90ca7310ec868758516b9fc8b15a9860441e78da6667a2923c6dfb0e3b59edba90e237c216ba2e9fea8750d1a022cfb3479115336d90d8ba1392573791bb947681b755b23c8bfd0b0cc87f56c81b532b3878bcb44658ae06e2466f684c4b57dce4809e76462e0a827099620a1593ddb85f9d679649f992f4f519d8b963e2972d2ec2c0d6adbd7e1c23b4cbd80caafecc3a6da03fc49e01301bcd701f032569139c705bd9454832d79000000000000000000000000985b293668b106496f6787e540f4d5ea5ace41e9737afd298e5ef5e957781e5964c0622f76f1dc94d3447ebe0db9e3a21bfce2757a51418f22fc42d6f66ed26382577392cd48c75e77e316d43285185b4b92d09f3f102de22d018ee768af6b26c120a918993a7d740e9d10e3db3f26d1bdada402da2f3acb4e7eb037d496bb1b2ebd94c628f88bddec2324fce1f3d82d675b35184a578b8fe55e2c1ce1b0fe7181bb5a84fa50333889ff9bcc9bb86377c22f3237',
  value: 0n,
  chainId: 28122024n,
  signature: Signature { r: &quot;0xe41149214e6e78352f9b6cd371519edaecdc38684885d347458ddb2b0a7bc87d&quot;, s: &quot;0x7be900ca6af85244aeeb887c765f2fae869803f6ce74afd4cac3b09d9307fc14&quot;, yParity: 0, networkV: null },
  accessList: []
}
</code></pre>
<h3 id="getpublickey"><a class="header" href="#getpublickey">getPublicKey()</a></h3>
<pre><code class="language-ts">
</code></pre>
<h3 id="static-transformproofproof-orandepoch-orandproof"><a class="header" href="#static-transformproofproof-orandepoch-orandproof">static transformProof(proof: OrandEpoch): OrandProof</a></h3>
<p>This is a helper function that allow you to tranfor proof for smart contract parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verifiable-random-function-vrf"><a class="header" href="#verifiable-random-function-vrf">Verifiable Random Function (VRF)</a></h1>
<p>We present an overview of verifiable random functions (VRF) and describe a construction a VRF based on elliptic curves in [<a href="ecvrf/../bibliography.html#PWHVNRG17">PWHVNRG17</a>].</p>
<p>Informally speaking, a VRF is a function that generates values that looks indistinguishable from random, and these values can be verified if they were computed correctly. Later, we discuss a few cryptographic applications that VRF possibly plays an important building blocks in constructing them.</p>
<p>The chapter is separated into \(2\) two major parts. In the first part, we state the formal definition of VRF including its syntax and security properties. Then we talk about the history of VRFs to see its development. In the second major part, we describe the VRF based on elliptic curve and our implementation of the VRF. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-of-vrf"><a class="header" href="#overview-of-vrf">Overview of VRF</a></h1>
<p>In this chapter, we present an overview of VRFs. First, we give a short introduction of VRF including its intuition and importance in cryptography. After that, we discuss the formal definition of VRF and its security requirements. Finally, we talk about the history of VRF to see its development. </p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h3>
<p>In cryptography, a verifiable random function (VRF) is a public key version of a pseudorandom function. It produces a pseudorandom output and a proof certifying that the output is computed correctly. </p>
<p>A VRF includes a pair of keys, named public and secret keys. The secret key, along with the input is used by the holder to compute the value of a VRF and its proof, while the public key is used by anyone to verify the correctness of the computation.</p>
<p>The issue with traditional pseudorandom functions is that their output cannot be verified without the knowledge of the seed. Thus a malicious adversary can choose an output that benefits him and claim that it is the output of the function. VRF solves this by introducing a public key and a proof that can be verified publicly while the owner can keep secret key to produce numbers indistinguishable from randomly chosen ones.</p>
<p>VRF has applications in various aspects. Among them, in internet security, it is used to provide privacy against offline enumeration (e.g. dictionary attacks) on data stored in a hash-based data structure <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/">irtf-vrf15</a>. VRF is also used in lottery systems [<a href="ecvrf/ecvrf-summary/../../bibliography.html#MR02">MR02</a>] and E-cashes [<a href="ecvrf/ecvrf-summary/../../bibliography.html#BCKL09">BCKL09</a>].</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="vrf-algorithms"><a class="header" href="#vrf-algorithms">VRF Algorithms</a></h3>
<p>Formally, a Verifiable random function consists of three algorithms \( (\mathsf{Gen}, \mathsf{Eval}, \mathsf{Verify})\) where:</p>
<p><strong>\((pk,sk) \leftarrow \mathsf{Gen}(1^{\lambda})\):</strong> This algorithm takes as input as a security parameter \( \lambda \) and
outputs a key pair \( (pk,sk)\).</p>
<p><strong>\( (Y,\pi) \leftarrow \mathsf{Eval}(X,sk)\):</strong> This algorithm takes as input a secret key \(sk\) and a value \(X\)
and outputs a value \(Y \in {0,1}^{out(\lambda)} \) and a proof \( \pi \).</p>
<p><strong>\( b \leftarrow \mathsf{Verify}(pk,X,Y,\pi)\):</strong> This algorithm takes an input a public key \(pk \), a value \(X\), a value \(Y\), a proof \(\pi\) and outputs a bit \(b\) that determines whether \(Y=\mathsf{Eval}(X,sk)\).</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="vrf-security-properties"><a class="header" href="#vrf-security-properties">VRF Security Properties</a></h3>
<p>We need a VRF to satisfy the following properties:</p>
<p><strong>Correctness:</strong> If \((Y,\pi)=Eval(sk,X)\) then \(Verify(pk,X,Y,\pi)=1\)</p>
<p><strong>Uniqueness:</strong> There do not exist tuples \((Y,\pi)\) and \(Y',\pi'\) with \(Y \ne Y'\) and:
\(\mathsf{Verify}(pk,X,Y,\pi)=\mathsf{Verify}(pk,X,Y',\pi')=1\)</p>
<p><strong>Pseudorandomess:</strong> For any adversary \(\mathcal{A}\) the probability \(|Pr[ExpRand^A_{VRF}(\lambda)=1]-\dfrac{1}{2}|\) is negilible where \(ExpRand_{VRF}^{\mathcal{A}}(1^\lambda)\) is defined as follows:</p>
<p>\(ExpRand_{VRF}^{\mathcal{A}}(1^\lambda)\):</p>
<ul>
<li>\((sk,pk) \leftarrow \mathsf{Gen}(1^{\lambda})\)</li>
<li>\((X^*,st) \leftarrow \mathcal{A}^{\mathcal{O_{VRF}}(.)}(pk)\)</li>
<li>\(Y_0 \leftarrow \mathsf{Eval}(X*,sk)\)</li>
<li>\(Y_1 \leftarrow \{0,1\}^{out(\lambda)}\)</li>
<li>\(b {\stackrel{$}{\leftarrow}} \{0,1\}\)</li>
<li>\(b' \leftarrow \mathcal{A}(Y_b,st)\)</li>
<li>Return \(b=b'\)</li>
</ul>
<p>The oracle \(\mathcal{O_{VRF}}(.)\) works as follow: Given an input \(x\), it outputs the VRF value computed by \(x\) and its proof.</p>
<p>In the paper of [<a href="ecvrf/ecvrf-summary/../../bibliography.html#PWHVNRG17">PWHVNRG17</a>], the authors stated that a VRF must also be collision resistant. This property is formally defined below:</p>
<p><strong>Collision Resistant:</strong> <strong>Collision Resistant:</strong> For any adversarial prover \(\mathcal{A}=(\mathcal{A_1},\mathcal{A_2})\) the probability \(Pr\left[ExpCol_{VRF}^\mathcal{A}(1^\lambda)=1\right]\) is negligible where \(ExpCol_{VRF}^\mathcal{A}(1^\lambda)\) is defined as follows: </p>
<p>\(ExpCol_{VRF}^\mathcal{A}(1^\lambda)\):</p>
<ul>
<li>\((pk,sk) \leftarrow \mathcal{A_1}(\mathsf{Gen}(1^{\lambda}))\)</li>
<li>\((X,X',st) \leftarrow \mathcal{A_2}(sk,pk)\)</li>
<li>Return \(X \ne X'\) and \(\mathsf{Eval}(X,sk)=\mathsf{Eval}(X',sk)\)</li>
</ul>
<p>It is interesting to see that, VRF can be used for signing messages. However, several signing algorithms such as ECDSA cannot be used to build a VRF. For a given message and a secret key, there can be multiple valid signatures, thus an adversiral prover could produce different valid outputs from a given input, and chooses the one that benefits him. This contradicts the uniqueness property of VRF. </p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="history-of-verifiable-random-function"><a class="header" href="#history-of-verifiable-random-function">History of Verifiable Random Function</a></h3>
<p>Verifiable Random Function is introduced by Micali, Rabin and Vadhan [<a href="ecvrf/ecvrf-summary/../../bibliography.html#MRV99">MRV99</a>]. They defined a Verifiable Unpredictable Function (VUF) and gave a construction based on the RSA assumption [<a href="ecvrf/ecvrf-summary/../../bibliography.html#MRV99">MRV99</a>], then proved that a VRF can be constructed from a VUF [<a href="ecvrf/ecvrf-summary/../../bibliography.html#MRV99">MRV99</a>]. </p>
<p>In 2002, Lysyanskaya [<a href="ecvrf/ecvrf-summary/../../bibliography.html#Lysyanskaya02">Lysyanskaya02</a>] also followed the same path by constructing a VUF instead VRF. However, Lysyanskaya's VUF is based on Diffie-Hellman assumption instead, and it is the first construction that is based on Diffie-Hellman assumption. </p>
<p>In 2005, Dodis and Yampolsky [<a href="ecvrf/ecvrf-summary/../../bibliography.html#DY05">DY05</a>] gave a direct and efficient construction using bilinear map, then improved. Later, during the 2010s, many constructions [<a href="ecvrf/ecvrf-summary/../../bibliography.html#HW10">HW10</a>],[<a href="ecvrf/ecvrf-summary/../../bibliography.html#BMR10">BMR10</a>],[<a href="ecvrf/ecvrf-summary/../../bibliography.html#Jag15">Jag15</a>] also used bilinear map, all of them used non standard assumptions to prove the security of their VRF. </p>
<p>In 2015, Hofheinz and Jager [<a href="ecvrf/ecvrf-summary/../../bibliography.html#HJ15">HJ15</a>] constructed a VRF that is based on a constant-size complexity assumption, namely the \((n-1)\)-linear assumption. The \((n-1)\)-linear assumption is not easier to break as \(n\) grows larger, as opposed to all the assumptions used by previous constructions [Unknown bib ref: HS07].</p>
<p>In 2017, [<a href="ecvrf/ecvrf-summary/../../bibliography.html#PWHVNRG17">PWHVNRG17</a>] construct an efficient VRF based on elliptic curve that does not use bilinear map to produce output and verify, instead they only use hash functions and elliptic curve operations. In the other hand, their hash function is viewed as random oracle model in the construction.</p>
<p>In 2019, Nir Bitansky [<a href="ecvrf/ecvrf-summary/../../bibliography.html#Bit19">Bit19</a>] showed that VRF can be constructed from non-interactive witness-indistinguishable proof (NIWI).</p>
<p>In 2020, Esgin et al [<a href="ecvrf/ecvrf-summary/../../bibliography.html#EKSSZSC20">EKSSZSC20</a>] was the first to construct a VRF based on lattice based cryptography, which is resistant to attack from quantum computers. Thus, VRF remains as a good candidate for generating randomness in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vrf-based-on-elliptic-curves-ecvrf"><a class="header" href="#vrf-based-on-elliptic-curves-ecvrf">VRF Based on Elliptic Curves (ECVRF)</a></h2>
<p>In this chapter, we describe a VRF Based on Elliptic Curves in the paper of  [<a href="ecvrf/ecvrf-construction/../../bibliography.html#PWHVNRG17">PWHVNRG17</a>]. The Internet Research Task Force (IRTF) also describes this VRF in their Internet-Draft <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/">irtf-vrf15</a>. The security proof of the VRF is in [<a href="ecvrf/ecvrf-construction/../../bibliography.html#PWHVNRG17">PWHVNRG17</a>], we do not present it here. Then we will present our implementation of the VRF.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="why-using-ecvrf"><a class="header" href="#why-using-ecvrf">Why using ECVRF</a></h3>
<p>There are many VRF constructions, as listed in the history of VRF. However, ECVRF is chosen because its efficient in both proving and verification complexity, and can be make distributed. </p>
<p>For example, in the construction of Hohenberger and Waters [<a href="ecvrf/ecvrf-construction/../../bibliography.html#HW10">HW10</a>], the proof of the VRF contains \(\Theta(\lambda)\) group elements. The number of evaluation steps is \(\Theta(\lambda)\), because we need to compute \(\Theta(\lambda)\) group elements. Verification require \(\Theta(\lambda)\) computations using bilinear map, where \(\lambda\) is the security parameter. It is unknown whether this VRF can be made distributed or not.</p>
<p>On the other hand, the proof size and the number of evaluation and verification steps of ECVRF are all constant and can be make distributed, as in the paper of Galindo et al [<a href="ecvrf/ecvrf-construction/../../bibliography.html#GLOW20">GLOW20</a>]. The VRF construction of [<a href="ecvrf/ecvrf-construction/../../bibliography.html#DY05">DY05</a>] also have constant proof size, evaluation and verification steps, and can be make distributed. However, in their paper, they require a cyclic group whose order is a 1000 bit prime, while ECVRF require a cyclic group whose order is a 256 bit prime such that the Decisional Diffie-Hellman (DDH) assumption holds. Hence, we can implement the VRF using Secp256k1, a curve used by Ethereum for creating digital signature. The embeeding degree of Secp256k1 is large, thus the DDH assumption is believed to be true.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="public-parameters"><a class="header" href="#public-parameters">Public Parameters</a></h3>
<p>Let \(\mathbb{G}\) be a cyclic group of prime order \(p\) with generator \(g\). Denote \(\mathbb{Z}_p\) to be the set of integers modulo \(p\). Let \(\mathsf{EncodeToCurve}\) be a hash function mapping a bit string to an element in \(\mathbb{G}\). Let \(\mathsf{ChallengeGeneration}\) be a hash function mapping arbitary input length to a \(256\) bit integer.</p>
<p>Note that, in the paper of [<a href="ecvrf/ecvrf-construction/../../bibliography.html#PWHVNRG17">PWHVNRG17</a>], the functions \(\mathsf{EncodeToCurve}\) and \(\mathsf{ChallengeGeneration}\) are modeled as random oracle model. This is used to prove the security of the VRF. </p>
<p>The cofactor parameter mentioned in the irtf draft is set to \(1\).</p>
<p>The \(\mathsf{Eval}\) function is split into 2 functions: \(\mathsf{Prove}\) and \(\mathsf{ProofToHash}\). The \(\mathsf{Prove}\) function returns the proof of the ECVRF, and the \(\mathsf{ProofToHash}\), returns the ECVRF output.</p>
<h3 id="ecvrf-construction"><a class="header" href="#ecvrf-construction">ECVRF Construction</a></h3>
<p><strong>\(\mathsf{KeyGen}(1^{k})\):</strong> Choose a random secret value \(sk \in 
\mathbb{Z}_p\) and the secret key is set to be \(sk \). The public key
is  \(pk=g^{sk}\).</p>
<p><strong>\(\mathsf{Prove}(sk,X)\):</strong> Given the secret key \(sk\) and an input \(X\), the proof \(\pi\) of ECVRF is computed as follow:</p>
<ol>
<li>
<p>Compute \(h=\mathsf{EncodeToCurve}(X,pk)\).</p>
</li>
<li>
<p>Compute \(\gamma=h^{sk}\).</p>
</li>
<li>
<p>Choose a value \(k\) uniformly in \(\mathbb{Z}_p\).</p>
</li>
<li>
<p>Compute \(c=\mathsf{ChallengeGeneration}(h,pk,gamma,g^k,h^k)\).</p>
</li>
<li>
<p>Compute \(s \equiv k-c.sk \pmod{q}\).</p>
</li>
<li>
<p>The proof \(\pi\) of the VRF is computed as \(\pi=(\gamma,c,s)\). </p>
</li>
</ol>
<p><strong>\(\mathsf{ProofToHash}(gamma)\):</strong>  Given input \(\gamma\) that is calculated during the \(\mathsf{Prove}\) function, this function returns the output of ECVRF.</p>
<ol>
<li>
<p>Compute \(gammastr=\mathsf{PointToString}(\gamma)\).</p>
</li>
<li>
<p>Let \(gammastr=PointToString(\gamma)\).</p>
</li>
<li>
<p>Let \(suite-string\)=&quot;0x01&quot;.</p>
</li>
<li>
<p>Let \(separator-front\)=&quot;0x03&quot;.</p>
</li>
<li>
<p>Let \(separator-back\)=&quot;0x00&quot;.</p>
</li>
<li>
<p>Let \(Y=\mathsf{keccak}(suite-string || seperator-front || gammastr || seperator-back)\).</p>
</li>
<li>
<p>Return \(Y\).</p>
</li>
</ol>
<p><strong>\(\mathsf{Verify}(pk,X,Y,\pi)\):</strong> Given the public key \(pk\), the VRF input \(X\), the VRF output \(Y\) and its proof \(\pi=(\gamma,c,s)\), the verification step proceeds as follow:</p>
<ol>
<li>
<p>Check if \(\gamma\) and \(pk\) is on the curve.</p>
</li>
<li>
<p>Compute \(u=pk^cg^s\).</p>
</li>
<li>
<p>Compute \(h=\mathsf{EncodeToCurve}(X,pk)\).</p>
</li>
<li>
<p>Compute \(v=\gamma^ch^s\).</p>
</li>
<li>
<p>Check if \(c=\mathsf{ChallengeGeneration}(h,pk,gamma,g^k,h^k)\). If the check is valid, output \(Y=\mathsf{ProofToHash}(\gamma)\), otherwise output \(Invalid\).</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ecvrf-auxiliary-functions"><a class="header" href="#ecvrf-auxiliary-functions">ECVRF Auxiliary Functions</a></h3>
<p>In this section, we describe the construction of \(HashToCurve\) and \(HashPoint\) in the Internet-Draft of irtf. More details can be found in <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/">irtf-vrf15</a>. </p>
<p><strong>\(\mathsf{EncodeToCurve}(X,pk)\):</strong> Given two group elements \(X, pk \in \mathbb{G}\), the function output a hash value in \(\mathbb{Z}_p\) as follows:</p>
<ol>
<li>
<p>Let \(ctr=0\).</p>
</li>
<li>
<p>Let \(suite-string\)=&quot;0x01&quot;.</p>
</li>
<li>
<p>Let \(seperator-front\)=&quot;0x01&quot;.</p>
</li>
<li>
<p>Let \(seperator-back\)=&quot;0x00&quot;.</p>
</li>
<li>
<p>Compute \(pkstr=\mathsf{PointToString}(pk)\).</p>
</li>
<li>
<p>Define \(H\) to be <strong>&quot;INVALID&quot;</strong>.</p>
</li>
<li>
<p>While \(H\) is <strong>&quot;INVALID&quot;</strong> or \(H\) is the identity element of the group:</p>
<ul>
<li>
<p>Compute \(ctrstr=\mathsf{IntToString}(ctr)\).</p>
</li>
<li>
<p>Compute \(hstr=\mathsf{keccak}\)\(( suite-string || seperator-front || pkstr || X || ctrstr || seperator-back)\).</p>
</li>
<li>
<p>Compute \(H\)=\(\mathsf{StringToPoint}(hstr)\).</p>
</li>
<li>
<p>Increment \(ctr\) by \(1\).</p>
</li>
</ul>
</li>
<li>
<p>Output \(H\).</p>
</li>
</ol>
<p><strong>\(\mathsf{ChallengeGeneration}(P_1,P_2,...,P_n)\):</strong> Given n elements in  \(\mathbb{G}\), the hash value is computed as follows:</p>
<ol>
<li>
<p>Let \(suite-string\)=&quot;0x01&quot;.</p>
</li>
<li>
<p>Let \(seperator-front\)=&quot;0x02&quot;.</p>
</li>
<li>
<p>Initialize \(str=suite-string || seperator-front\).</p>
</li>
<li>
<p>For \(i=1,2,...,n\):</p>
<ul>
<li>Update \(str= str || \mathsf{PointToString}(P_i)\).</li>
</ul>
</li>
<li>
<p>Let \(separator-back\)=&quot;0x00&quot;.</p>
</li>
<li>
<p>Update \(str=str || separator-back\).</p>
</li>
<li>
<p>Update \(str=\mathsf{keccak}(str)\).</p>
</li>
<li>
<p>Compute \(c=\mathsf{StringToInt}(str)\).</p>
</li>
<li>
<p>Output \(c\).</p>
</li>
</ol>
<p>The function \(\mathsf{PointToString}\) converts a point of an elliptic curve to a string. Many programming supports this function. For example, in python, we can use \(str(G)\) to return the string representation of a point\(G\).</p>
<p>The function \(\mathsf{StringToPoint}\) converts a string to a point of an elliptic curve. It is specified in section 2.3.4 of [<a href="ecvrf/ecvrf-construction/../../bibliography.html#SECG1">SECG1</a>].</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ecvrf-implementation-in-python"><a class="header" href="#ecvrf-implementation-in-python">ECVRF implementation in Python</a></h3>
<p>The implememtation of the ECVRF in python. The steps and details are written on the comments of the implementation. Below are the global variables. We use the ecdsa library, but the curve curve_256 of the library is replaced with the curve secp256k1. Instead of using SHA256 as in <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/">irtf-vrf15</a>, we use the keccak hash function.</p>
<pre><code class="language-python">G = generator_256
ORDER = G.order()
order_minus_one=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140
INFINITY=Point(None,None,None)
suite_string=b&quot;0x01&quot;
</code></pre>
<h4 id="ecvrf-main-functions"><a class="header" href="#ecvrf-main-functions">ECVRF main functions</a></h4>
<p>The main functions of the ECVRF.</p>
<h5 id="the-key-generation-function"><a class="header" href="#the-key-generation-function">The Key generation function</a></h5>
<p>We create an ECVRF class and use the key generation function as the constructor of the class.</p>
<pre><code class="language-python">class ECVRF():

    def __init__(self,sk=None):
    if sk==None:
            self.sk = random.randint(0,order_minus_one)
            self.pk = G*self.sk
    else:
        self.sk = sk
        self.pk = G*self.sk
</code></pre>
<h5 id="the-prove-function"><a class="header" href="#the-prove-function">The Prove function</a></h5>
<p>The prove function of the ECVRF. The function closely follow the steps in Section 5.1 of <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/">irtf-vrf15</a></p>
<pre><code class="language-python">def prove(self, x):
        # the evaluation function, based on the paper [PWHVNRG17]
        # step 1 compute h

        H = ECVRF_encode_to_curve_try_and_increment(self.pk,x,suite_string)

        #step 2 let gamma=h^self.sk

        gamma = H*self.sk

        #step 3 choose a random k

        k = random.randint(0,order_minus_one)

        #step 4 compute c=Hash_point(g,h,g^sk,h^sk,g^k,h^k)

        point_list=[H, self.pk, gamma, G*k, H*k]
        c = ECVRF_challenge_generation(point_list)

        #step 5 compute s=k-c*sk (mod order)
        s = (k - c*sk)% ORDER

        # the proof consists of gamma, c and s
        pi = {'gamma': gamma, 'c': c,  's': s}

        # the output is the keccak hash of gamma
        y=proof_to_hash(gamma)

        return {'output': y, 'proof': pi, 'public key': self.pk}
</code></pre>
<h5 id="the-prooftohash-function"><a class="header" href="#the-prooftohash-function">The ProofToHash function</a></h5>
<p>The prove function of the ECVRF. The function closely follow the steps in Section 5.2 of <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/">irtf-vrf15</a></p>
<pre><code class="language-python">def proof_to_hash(gamma):

        # the output is the keccak hash of gamma
        hash = keccak.new(digest_bits=256)
        hash.update(b&quot;\x01&quot;)
        hash.update(b&quot;\x03&quot;)
        hash.update(str(gamma).encode())
        hash.update(b&quot;\x00&quot;)
        y = int(hash.hexdigest(), 16)

</code></pre>
<h5 id="the-verify-function"><a class="header" href="#the-verify-function">The Verify function</a></h5>
<p>The verify function of the ECVRF. The function closely follow the steps in Section 5.3 of <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/">irtf-vrf15</a></p>
<pre><code class="language-python">def verify(self, x, y, pi, pk):
        # this function, given an input x, a value y, a proof pi and 
        # the public key pk,
        # verify if the output y was calculated correctly from x

        gamma = pi['gamma']
        c = pi['c']
        s = pi['s']

        #step 1 compute U=c*pk+G*s

        U = c*pk + G*s

        #step 2 compute V=c*gamma+H*s

        H = ECVRF_encode_to_curve_try_and_increment(pk,x,suite_string)

        #step 3 compute V=c*gamma+h*s

        V = c*gamma + H*s

        #calculate the value Hash_point(G,H,pk,gamma,U,V)

        point_list=[H,pk,gamma,U,V]
        c2 = ECVRF_challenge_generation(point_list)

        #calculate the keccak hash of gamma

        hash = keccak.new(digest_bits=256)
        hash.update(str(gamma).encode())

        #step 4 check if c=Hash_point(g,h,pk,gamma,u,v) and y=keccak(gamma)

        return c == c2 and y == hash_to_proof(gamma)
</code></pre>
<h4 id="ecvrf-auxiliary-functions-1"><a class="header" href="#ecvrf-auxiliary-functions-1">ECVRF auxiliary functions</a></h4>
<p>The auxiliary functions  of the ECVRF.</p>
<h5 id="the-hashtocurve-function"><a class="header" href="#the-hashtocurve-function">The HashToCurve function</a></h5>
<p>The HashToCurve of the converts a 256 bit integer into a point of the curve secp256k1. We ignore the cofactor check in <a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-08">irtf-vrf08</a>, since the cofactor value is set to be 1.</p>
<pre><code class="language-python">def ECVRF_encode_to_curve_try_and_increment(pk, x, suite_string):
    #follow the ecvrf irtf draft

    ctr=0
    pk_string=str(pk).encode()
    one_string=int(0).to_bytes(1,'big')
    zero_string=int(1).to_bytes(1,'big')

    #because the == operation in the elliptic curve class only compare
    #two Points, we cannot use H==&quot;INVALID&quot; (can't compare a Point and a
    # string) but instead use H==INFINITY
    #because if H==INFINITY is also an invalid condition and it does not
    #change anything.

    H=INFINITY
    while  H==INFINITY:
        hash=keccak.new(digest_bits=256)
        ctr_string=str(ctr).encode()
        hash.update(suite_string)
        hash.update(one_string)
        hash.update(pk_string)
        hash.update(str(x).encode())
        hash.update(ctr_string)
        hash.update(zero_string)
        ctr+=1
        hash=hash.digest()
        H=string_to_curve(hash)
    return H
</code></pre>
<h5 id="the-hashpoint-function"><a class="header" href="#the-hashpoint-function">The HashPoint function</a></h5>
<p>The HashPoint function converts a list of point into a 256 bit integer. The function closely follow the steps in Section 5.4.3 of <a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-08">irtf-vrf08</a></p>
<pre><code class="language-python">def ECVRF_challenge_generation(point_list):
        # based on the irtf internet draft
        #we use the keccak instead of sha256

        hash = keccak.new(digest_bits=256)
        hash.update(b&quot;\x02&quot;)
        for i in point_list:
            hash.update(str(i).encode())
        hash.update(b&quot;\x00&quot;)
        return int(hash.hexdigest(), 16) % ORDER
</code></pre>
<h5 id="the-stringtocurve-function"><a class="header" href="#the-stringtocurve-function">The StringToCurve function</a></h5>
<p>The StringtoCurve converts a string into a point of secp256k1. We only need to implement Step 1, Step 2.2 and Step 2.4.1 in [<a href="ecvrf/ecvrf-construction/../../bibliography.html#SECG1">SECG1</a>], since we use the curve secp256k1.</p>
<pre><code class="language-python">def string_to_curve(string):
    #specified in 2.3.4 of https://www.secg.org/sec1-v2.pdf
    #since the curve is secp256k1, then q=p is an odd prime
    #we want to implement for secp256k1 therefore we will just implement step 1, 
    # 2.2 and 2.4.1

    #Step 1

    if string==int(2).to_bytes(1,'big'):
        return INFINITY

    #Step 2.2

    x=string_to_field(string)
    if x==&quot;INVALID&quot;:
        return INFINITY
    p=secp256k1._CurveFp__p

    #Step 2.4.1
    # let t=x^3+7 (mod p) 

    t=(pow(x,3,p)+secp256k1._CurveFp__a*x+secp256k1._CurveFp__b)%p
    QR=pow(t,(p-1)//2,p)
    if QR==(p-1):
        return INFINITY

    # because p=3 (mod 4), we see that y=t^((p+1)/4)

    beta=pow(t,(p+1)//4,p)
    if beta%2==0:
        return Point(secp256k1,x,beta)
    else:
        return Point(secp256k1,x,p-beta)
</code></pre>
<h5 id="the-stringtofield-function"><a class="header" href="#the-stringtofield-function">The StringToField function</a></h5>
<p>The StringtoCurve converts a string into an element in \(\mathcal{Z}_p\), where \(p=2^{256}-2^{32}-977\). We only need to implement Step 1 and Step 2.3.6 in [<a href="ecvrf/ecvrf-construction/../../bibliography.html#SECG1">SECG1</a>].</p>
<pre><code class="language-python">def string_to_field(string): 
    #specified in 2.3.6 of https://www.secg.org/sec1-v2.pdf
    #since i just want to implement for secp256k1, i will just implement step 1
    #in fact, step 1 is just the function string_to_integer in part 2.3.8 of the
    #same paper

    x=0
    for i in range (0,len(string)):
        x+=pow(256,len(string)-1-i)*int(hex(string[i]),16)
    if x&lt;secp256k1._CurveFp__p:
        return x
    return &quot;INVALID&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distributed-key-generation-dkg"><a class="header" href="#distributed-key-generation-dkg">Distributed Key Generation (DKG)</a></h1>
<p>We give an overview of Distributed Key Generation (DKG) and describe the DKG protocol used in the paper [<a href="dkg/../bibliography.html#GJKR99">GJKR99</a>]. This, along with the ECVRF, will be two main components for the Distributed Verifiable Random Function (DVRF) protocol used for generating pseudorandom values. First, we give an overview of DKG. Then, we mention Verifiable Secret Sharing (VSS), the main building block for a DKG protocol. Finally, we describe the DKG protocol of [<a href="dkg/../bibliography.html#GJKR99">GJKR99</a>].</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="overview-to-dkg"><a class="header" href="#overview-to-dkg">Overview to DKG</a></h2>
<p>Distributed key generation is a main component of threshold cryptosystems. It allows \(n\) participants to take part and generate a pair of public key and secret key required for the threshold cryptosystem without having to rely on a trusted party (dealer). Each participant in additional receive a partial secret key and a partial public key. While the public key and partial public keys is seen by everyone, the private key is maintained as a (virtual) secret of a \(t,n\) secret sharing scheme, where each share is the partial secret key of a participant [<a href="dkg/dkg-summary/../../bibliography.html#GJKR99">GJKR99</a>]. No adversary with limited computational power can learn any information of the secret key unless it control the required amount of participants.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="dkg-security-properties"><a class="header" href="#dkg-security-properties">DKG Security Properties</a></h3>
<p>As in [<a href="dkg/dkg-summary/../../bibliography.html#GJKR99">GJKR99</a>], we wish a \((t,n)\) DKG protocol to have the following properties:</p>
<p><strong>Correctness:</strong> </p>
<ol>
<li>There is an efficient algorithm that, given any \(t+1\) shares provided by honest parties, output the same unique secret key \(sk\).</li>
<li>All honest parties agree on the same value of the public key \(pk=g^{sk}\).</li>
<li>\(sk\) is uniformly distributed in \(\mathbb{Z}_p\).</li>
</ol>
<p><strong>Secrecy:</strong>: For any adversary who controls at most \(t\) participants, he cannot learn any additional information except the value \(pk=g^{sk}\).</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="applications"><a class="header" href="#applications">Applications</a></h3>
<p>DKG has been used in numerous aspects: </p>
<ol>
<li>
<p><strong>Threshold Encryption and Signatures</strong>: In threshold cryptosytems, one problem arises: single point of failure. If a single participant fails to follow the protocol, then the
entire system will abort. When applied as a component of a threshold cryptosystem, \((n,t)\)DKG solves this problem by ensuring that any \(t+1\) participants who behave honestly will allow the protocol to execute successfully.</p>
</li>
<li>
<p><strong>Identity based Cryptography (IBC)</strong>: In IBC, a private-key generator (PKG) is required to generate a secret, called the master key and provide private keys to clients using it. Since he know the private key of the client, he can decrypt the messages of the client. A \((n,t)\) DKG solve this by distributing the PKG into many participants where any adversary who control at most \(t\) parties cannot compute the master key, and the client receive his secret key by collecting \(t+1\) partial private keys from the participants.</p>
</li>
<li>
<p><strong>Distriuted Pseudo-random Functions</strong>: Pseudo-random Functions (PRF) and Verifiable Random Functions (VRF) is used to produce values that looks indistinguishable from random. Both require a secret key to compute the output. However, the secret key holder can select the value of the secret key to manipulate the output, or share the secret key with others to benefit himself. This can be prevented by applying a \((n,t)\) distributed version of PRF or VRF, thus no adversary can learn or affect the value of the secret key.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="verifiable-secret-sharing-vss"><a class="header" href="#verifiable-secret-sharing-vss">Verifiable Secret Sharing (VSS)</a></h2>
<p>In this chapter, we discuss about Verifiable Secret Sharing (VSS), the main building block for a DKG protocol. We state the syntax and security properties of a VSS, then describe the VSS construction due to Pedersen.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h3>
<p>Secret Sharing was first introducted by Shamir in 1979 [<a href="dkg/verifiable-secret-sharing/../../bibliography.html#Shamir79">Shamir79</a>]. It allows a person to share a secret \(s\) among \(n\) parties such that any \textit{authorized} subset of parties can use all their shares to reconstruct the secret, while any other (non-authorized) subset learns nothing about the secret from their shares. Shamir proposed a secret sharing scheme in his paper [<a href="dkg/verifiable-secret-sharing/../../bibliography.html#Shamir79">Shamir79</a>].  However, in Shamir's scheme, parties can commit wrong shares, leading the protocol to reconstruct the wrong secret, thus a verification process of the shares is required. To solve this problem, Chor et al. [<a href="dkg/verifiable-secret-sharing/../../bibliography.html#CGMA85">CGMA85</a>] introduced Verifiable Secret Sharing.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="syntax-and-properties"><a class="header" href="#syntax-and-properties">Syntax and Properties</a></h3>
<h4 id="syntax"><a class="header" href="#syntax">Syntax</a></h4>
<p>A \((t,n)\) Verifiable Secret Sharing consists of two phases: <strong>Share</strong> and <strong>Reconstruct</strong> as follow:</p>
<p><strong>Share:</strong> The dealer \(D\) has a secret value \(s\). Initially, there are \(n\) parties \(P_1, P_2, ..., P_n\). The sharing phase may consist of several rounds of interaction between parties. At the end
of the phase, each party \(P_i\) holds a share \(s_i\) that will be required to reconstruct the secret of the dealer later.</p>
<p><strong>Reconstruct:</strong> In this phase, each party \(P_i\) publishes its share \(s_i\) from the sharing phase. Then, from these shares, a reconstruction function will be applied to output the original secret.</p>
<h4 id="properties"><a class="header" href="#properties">Properties</a></h4>
<p>As in [<a href="dkg/verifiable-secret-sharing/../../bibliography.html#BKP11">BKP11</a>], a VSS need to have the following properties:</p>
<p><strong>Correctness</strong>: If \(D\) is honest, then the reconstruction function outputs \(s\) at the end of the <strong>Reconstruct</strong> phase and all honest parties agree on the value \(s\).</p>
<p><strong>Secrecy</strong>: If \(D\) is honest, then any adversary that control at most \(t\) parties does not learn any information about \(s\) during the <strong>Share</strong> phase.</p>
<p><strong>Commitment</strong>: If \(D\) is dishonest, then at the end of the sharing phase there exists a value \(s^* \in \mathbb{F}_p\) 
such that at the end of the <strong>Reconstruct</strong> phase all honest parties agree on \(s^*\).</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="pedersens-construction"><a class="header" href="#pedersens-construction">Pedersen's Construction</a></h3>
<p>We describe a VSS protocol from Pedersen [<a href="dkg/verifiable-secret-sharing/../../bibliography.html#Ped91">Ped91</a>]. This scheme provides perfect information theoretic security against any adversary with unbounded computational power.</p>
<p><strong>Share</strong> The dealer chooses two polynomials \(p(x)=a_0+a_1x+a_2x^2+...+a_tx^t\) and \(p'(x)=b_0+b_1x+b_2x^2+...+b_tx^t\) such that \(a_0=s\). Then he compute \(s_i=p(i)\) and \(s_i'=p'(i)\). The dealer then broadcasts \(C_i=g^{s_i}h^{s_i'}\). Then he gives the party \(P_i\) the tuple \((s_i,s_i')\). This allows \(P_i\) to check if \((s_i,s_i')\) is a valid share by checking that</p>
<p>$$g^{s_{i}}h^{s_{i}'} \stackrel{?}{=} \prod_{k=0}^{t}(C_{k})^{i^k} (*).$$</p>
<p>If a party \(P_i\) receives a share that does not satisfy \((*)\), he will complains against the dealer.
The dealer must reveal the share \((s_i,s_i')\) that satisfies  for each complaining party \(P_i\). If any of the revealed shares does not satisfy \((1)\) the equation, the dealer is marked invalid.</p>
<p><strong>Reconstruct</strong> Each participant submits  \((s_i,s_i')\). Everyone can verify if \(P_i\) submitted the correct shares by checking if \(1\) is satisfied. If \(P_i\) receives more than \(t\) complaints, then he is disqualified. Given \(t+1\) valid shares, \(s_1,s_2,...,s_{t+1}\) from parties \(P_{x_1},P_{x_2},...,P_{x_{t+1}}\), the secret \(s\) can be computed as: 
$$s= \sum_{i=0}^{t}s_i \left(\prod_{\substack{j=0 \ j\neq i}}^{t}\dfrac{x_j}{x_j-x_i}\right).$$</p>
<p>The security proof of the protocol can be found in [<a href="dkg/verifiable-secret-sharing/../../bibliography.html#Ped91">Ped91</a>].</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dkg-construction"><a class="header" href="#dkg-construction">DKG Construction</a></h2>
<p>In this chapter, we describe the DKG protocol in the paper Gennaro et al [<a href="dkg/dkg-construction/../../bibliography.html#GJKR99">GJKR99</a>]. The protocol can withstand up to \(\dfrac{n}{2}\) dishonest participants, where \(n\) is the number of participants. Despite the high communication cost, the protocol only need to be executed once in the first round of many threshold cryptosystems, making the DKG communication cost is not a serious matter in these cryptosystems.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="why-gennaro-et-als-construction"><a class="header" href="#why-gennaro-et-als-construction">Why Gennaro et al's Construction?</a></h3>
<p>Despite there are numerous constructions for DKG, namely [<a href="dkg/dkg-construction/../../bibliography.html#GJKR99">GJKR99</a>], there is a reason we choose the DKG protocol of Gennaro et al. </p>
<p>Previously, Pedersen was the first to propose a DKG construction [<a href="dkg/dkg-construction/../../bibliography.html#Ped91a">Ped91a</a>]. However, Gennaro et al. proved that in Pedersen's DKG, an attacker can manipulate the result of the secret key, making it not uniformly distributed [<a href="dkg/dkg-construction/../../bibliography.html#GJKR99">GJKR99</a>].</p>
<p>Canetti et al. [<a href="dkg/dkg-construction/../../bibliography.html#CGJKR99">CGJKR99</a>] give a construction of a DKG that is secure against an adaptive adversary. However, his construction has worse performance than Gennaro's, since each participant has to use Pedersen's VSS two times. In addition, no adaptive
adversary has been able to successfully attack the construction of Gennato et al.</p>
<p>Numerous attempts have been made to reduce the communication cost for a DKG [<a href="dkg/dkg-construction/../../bibliography.html#KG09">KG09</a>],[<a href="dkg/dkg-construction/../../bibliography.html#CS04">CS04</a>],[<a href="dkg/dkg-construction/../../bibliography.html#CZAPGD20">CZAPGD20</a>]. However, all these schemes require a trusted party. This quite contradict the goal of a DKG.</p>
<p>This make the DKG construction of Gennaro et al. remains a simple, efficient and secure DKG protocol.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="gennaro-et-als-construction"><a class="header" href="#gennaro-et-als-construction">Gennaro et al's Construction</a></h3>
<p>The DKG protocol consists of two phases, namely, generating and extracting, working as follows:</p>
<p><strong>Public Parameters:</strong> Let \(p\) be a prime number. Let \(G\) be a cyclic group of order \(p\) with generators \(g\) and \(h\). The public parameters of the system are \(p,G,g,h\).</p>
<p><strong>Generating:</strong> This process works as follows:</p>
<ol>
<li>Each participant \(P_i\) chooses two random polynomials \(f_i(z)=a_{i0}+a_{i1}z+...+a_{it}z^t\) and \(f_i'(z)=b_{i0}+b_{i1}z+...+b_{it}z^t\) and broadcasts \(C_{ij}=g^{a_{ij}}h^{b_{ij}}\) for \(j=0,1,...,t\).</li>
<li>The participant \(P_i\) then sends \(s_{ij}=f_i(j)\) and \(s'_{ij}=f_i'(j)\) to \(P_j\).</li>
<li>Each participant \(P_j\) verifies the shares he received from each \(P_i\) by checking whether</li>
</ol>
<p>$$g^{s_{ij}}h^{s_{ij}'}\stackrel{?}{=} \prod_{k=0}^{t}C_{ik}^{j^k}. (*)$$</p>
<p>If the check fails for some \(i\), \(P_j\) complains against \(P_i\).</p>
<ol>
<li>Each \(P_i\) who receives a complaint from \(P_j\) broadcasts \(s_{ij}\) and \(s_{ij}'\) that satisfy Equation \((*)\).</li>
<li>A participant \(P_i\) is disqualified if he receives at least \(t+1\) complaints or answers a complaint with value that does not satisfy Equation. Then a set \(\mathsf{QUAL}\) of qualified participants is determined.</li>
<li>For each \(i\), the secret key \(sk_i\) of \(P_i\) is equal to \( \sum_{j\in \mathsf{QUAL}} s_{ji}\). For any set \(\mathcal{V}\) of at least \(t+1\) participants, the secret key \(sk\) is equal to \( \sum_{i \in \mathcal{V}} sk_i\cdot\lambda_{i,\mathcal{V}}\).</li>
</ol>
<p><strong>Extracting:</strong> The process works as follows:</p>
<ol>
<li>Each participant \(P_i\) in the set \(\mathsf{QUAL}\) publishes \(A_{ij}=g^{a_{ij}}\) for \(j=0,1,2,\dots,t\).</li>
<li>Each participant \(P_j\) verifies \(A_{ij}\) for each \(i\). Specifically, \(P_j\) checks whether
$$g^{s_{ij}}\stackrel{?}{=} \prod_{k=0}^{t}A_{ik}^{j^k}.$$
If the check fails for some \(i\), \(P_j\) complains against \(P_i\).</li>
<li>For each \(i\) that \(P_i\) receives at least one valid complaint, all other parties run Pedersen VSS to reconstruct \(f_i(z)\), and restore \(s_{i0}\) and \(A_{ij}\) for \(j=0,1,...,t\). The public key is equal to \(pk= \prod_{i \in \mathsf{QUAL}}A_{i0}\). </li>
<li>The public key \(pk_i\) of \(P_i\) is calculated as 
\(pk_i=g^{sk_i}=\prod_{j \in \mathsf{QUAL}}g^{s_{ji}}= \prod_{j \in \mathsf{QUAL}}\prod_{k=0}^{t}A_{jk}^{i^k}\).</li>
</ol>
<p>The security proof of the DKG protocol can be found in [<a href="dkg/dkg-construction/../../bibliography.html#GJKR99">GJKR99</a>].</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threshold-signature"><a class="header" href="#threshold-signature">Threshold Signature</a></h1>
<p>In this chapter, we give an overview of threshold signatures and describe the threshold ECDSA construction of Canetti et al in [<a href="threshold-ecdsa/../bibliography.html#CGGMP21">CGGMP21</a>] and the FROST threshold signature scheme in [<a href="threshold-ecdsa/../bibliography.html#KG20">KG20</a>], which is a threshold version of Schnorr signature scheme, including its EdDSA (or <strong>ed25519</strong>) instatiation. The chapter is separated into \(5\) major parts below:</p>
<ul>
<li>
<p>First, we give a brief introduction to threshold signatures and state its syntax and security properties in <a href="threshold-ecdsa/./threshold-ecdsa-introduction/introduction.html">Introduction</a>. </p>
</li>
<li>
<p>Second, we state the syntax and security properties of threshold signatures in <a href="threshold-ecdsa/./threshold-ecdsa-introduction/definition.html">Definition and Security</a>.</p>
</li>
<li>
<p>Third, we describe the threshold ECDSA construction of [<a href="threshold-ecdsa/../bibliography.html#CGGMP21">CGGMP21</a>] in <a href="threshold-ecdsa/./threshold-ecdsa-construction/introduction.html">Canetti's Construction</a> to support the threshold ECDSA version for the curve <strong>secp256k1</strong>. </p>
</li>
<li>
<p>Fourth, we describe the FROST threshold signature construction of [<a href="threshold-ecdsa/../bibliography.html#KG20">KG20</a>] in <a href="threshold-ecdsa/./frost-construction/introduction.html">FROST Construction</a> to support the threshold signature version of <strong>ed25519</strong> and <strong>sr25519</strong>.</p>
</li>
<li>
<p>Finally, we briefly specify our instatiation and analyse the security for the threshold ECDSA construction of Canetti et al using  <strong>secp256k1</strong> parameters and FROST threshold signature construction using <strong>ed25519</strong> and <strong>sr25519</strong> parameters as follows:</p>
<ul>
<li>
<p>In <a href="threshold-ecdsa/./intended-implementation/threshold-ecdsa-for-secp256k1.html">Threhold signature for secp256k1</a>, we discuss and analyse the security of the threshold ECDSA signature of Canneti et al. when instatiated using the parameters of <strong>secp256k1</strong>.</p>
</li>
<li>
<p>In  <a href="threshold-ecdsa/./intended-implementation/threshold-eddsa-for-ed25519.html">Threhold signature for ed25519</a> we discuss and analyse the security of the FROST threshold signature when instatiated using the parameters of <strong>ed25519</strong>.</p>
</li>
<li>
<p>In <a href="threshold-ecdsa/./intended-implementation/threshold-eddsa-for-sr25519.html">Threhold signature for sr25519</a> we discuss and analyse the security of the FROST threshold signature when instatiated using the parameters of <strong>sr25519</strong>.</p>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>A \((n,t)\) threshold signature protocol allows distributed signing among \(n\) participants  such that any group of \(t+1\) participants can produce a valid signature, while any group of fewer that \(t\) participants cannot. The goal is to produce signatures that are compatible with an existing centralized signature scheme so that we can verify the signatures without any modification in the existing digital signature algorithms. Compared to an ordinary signature scheme, the setup and signing algorithms  are replaced by interactive protocol between participants, while the verification algorithm remains identical to the verification of a signature issued by a centralized party. </p>
<p>With the advance of blockchain technology, threshold signature has received increasing attention from the community. This is because transactions in blockchain are made possible via digital signatures, and it is dangerous to trust the whole signing process in a single individual, who might be compromised, leading to single point of failure. Hence many stakeholders are looking to perform signature generation in a distributed way. In a threshold signature scheme, an adversary cannot learn the actual secret key if it does not control enough number of participants, and any \(t+1\) participants will be able to deliver a valid signature, hence preventing the &quot;single point of failure&quot; attack above.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="definition-and-security"><a class="header" href="#definition-and-security">Definition and Security</a></h2>
<p>In this section, we describe the syntax and security properties of a threshold signature scheme.</p>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<p>We describe the syntax of a threshold signature scheme. A \((n,t)\) threshold signature consists of two interactive protocols <strong>KeyGen</strong>, <strong>Sign</strong> and an algorithm <strong>Verify</strong> as follows: </p>
<p><strong>Keygen \((1^\lambda)\langle \{P_i\}_{i=1}^n\rangle\):</strong> This is an interactive protocol between \(n\) participants \(P_1,P_2,\dots,P_n\). If the interaction suceeds, each participant \(P_i\) receives a partial secret key \(sk_i\). In addition, all participants output a common public key \(pk\). </p>
<p><strong>Sign\((M,\mathcal{S})\langle \{P_i(sk_i)\}_{i \in \mathcal{S}}\rangle\):</strong> This is an interactive protocol with common input \(M\) between a set \(\mathcal{S}\) of \(t+1\)  participants \(\{P_i\}_{i \in \mathcal{S}}\), where each participant \(P_i\) holds a partial secret key \(sk_i\) only known to him. If the interaction suceeds, the protocol outputs a signature \(\sigma\).</p>
<p><strong>Verify\((M,\sigma,pk)\):</strong> This is an algorithm run by an external verifier to check the correctness of the signature. On input a message \(M\), a signature \(\sigma\), a common public key \(pk\), it outputs a bit \(b\) indicating the validity of the signature.</p>
<h3 id="security-properties"><a class="header" href="#security-properties">Security Properties</a></h3>
<p>A threshold signature scheme should satisfy the following properties:</p>
<p><strong>Correctness:</strong> For any set \(\mathcal{S} \subset \{1,\dots,n\}\) with \(|\mathcal{S}|=t+1\), if \(P_i\) follows the protocol for all \(i \in \mathcal{S}\) and 
\(\sigma \leftarrow\) <strong>Sign\((M,\mathcal{S})\langle \{P_i(sk_i)\}_{i \in \mathcal{S}}\rangle\)</strong>, then it holds that <strong>Verify\(((M,\sigma,pk)=1\)</strong>.</p>
<p><strong>Unforgability:</strong> A \((t-n)\) threshold signature scheme is unforgeable if for any adversary \(\mathcal{A}\) who corrupts up to \(t\) participants and given previous signatures \(\sigma_1,\dots,\sigma_k\) of previous messages \(M_1,\dots,M_k\), the probability that \(\mathcal{A}\) can produce a signature \(\sigma\) on an unsigned message \(M\) such that <strong>Verify\(((M,\sigma,pk)=1\)</strong> is negligible.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cannetis-construction"><a class="header" href="#cannetis-construction">Canneti's Construction</a></h2>
<p>In this section we briefly describe the threshold ECDSA protocol of Canneti etal in [<a href="threshold-ecdsa/threshold-ecdsa-construction/../../bibliography.html#CGGMP21">CGGMP21</a>], in which we assume that the readers have some familiarity to ECDSA signature scheme. Recall that the ordinary ECDSA signature scheme \(\sigma=(r,s)\) of a message \(M\) is generated as follow</p>
<p>$$r=R.\mathsf{x},\ R=g^{k^{-1}},\ m=\mathsf{H}(M)\ \text{and}\ s=k(m+r\cdot sk),$$</p>
<p>where \(k \leftarrow \mathbb{Z}_p\) and \(sk\) is the signer's secret key. Canneti's protocol aims to provide a valid ECDSA signature of \(M\) above via a threshold manner. In addition, the protocol also provide the following features:</p>
<ul>
<li>
<p><strong>Universal Composable Security:</strong> Canneti etal's protocol achieve security in the Universal Composable Security framework. The framework is better in realizing the security of protocol, compared to traditional game based definitions.</p>
</li>
<li>
<p><strong>Proactive Key Refresh:</strong> Canneti etal's protocol allow participants to refresh their partial secret keys after every epoch while not changing the grand secret key and public key. The goal of key refresh is to achieve security against proactive adversaries, who might corrupt participants for a certain period of time during the execution of the protocol. </p>
</li>
<li>
<p><strong>Non Interactive online phase:</strong> Canneti etal's protocol achieves non-interactive in the following sense: The signing protocol consists of a preprocessing phase before the  message \(M\) is known, followed by a non-interactive signing phase, where each participant can generate his own signature of \(M\) using the preprocessed information.</p>
</li>
<li>
<p><strong>Identifiable Abort:</strong> The protocol contains additional mechanisms that allow participants to detect any signers who fail to participate in the signing process, or deviate from it. Identifying misbehaving signers can be crucial for some applications. In most applications, being able to identify rogue servers is a convenience, allowing reboot the whole system.</p>
</li>
</ul>
<p>To see how the protocol achieve the abovementioned properties, we now move to the actual construction of Canneti and describe it.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="key-generation"><a class="header" href="#key-generation">Key Generation</a></h3>
<p>In this section, we describe the key generation process in the construction of Canetti et al. The key generation process is divided into two sub protocols: the initial key generation process and the key refresh process.
The initial key generation process is executed exactly once to produce a public-secret key pair \(pk,sk\), while the key refresh process is executed whenever participants would like to change their partial secret keys in the way that \(pk\) and \(sk\) remains the same.
Before moving to the protocol, we provide several notations that will be used in the protocol description below.</p>
<p><strong>Notation:</strong> Let \(\lambda\) to be the security parameter. Let \(\mathbb{G}\) to be a cyclic group whose order is a prime number. Let \(p \in (2^{\lambda-1},2^\lambda)\) to be the order of \(\mathbb{G}\) and let \(g,h\) to be two generators of \(\mathbb{G}\). We denote \(\mathsf{Com}\) to be a secure binding and information theoretic hiding commitment scheme and \(\mathsf{H}\) to be a cryptographic hash function. For any set \(\mathcal{S}\) and for any \(i \in \mathcal{S}\) we denote \(\lambda_{i,S}=\prod_{j\in \mathcal{S},j \neq i}\dfrac{j}{j-i}\) to be the Lagrange coefficient w.r.t \(S\).</p>
<p>Now, the initial key generation and key-refresh process are as follows:</p>
<p><strong>Keygen \((1^\lambda)\langle \{P_i\}_{i=1}^n\rangle\):</strong></p>
<p><strong>Initial Key Generation:</strong>
The initial key generation is executed once at the beginning.</p>
<ol>
<li>
<p>Each participant \(P_i\) selects \(s_i \in Z_p \) and compute \(C_i=\mathsf{Com}(g^{s_i})\).</p>
</li>
<li>
<p>Each participant \(P_i\) broadcasts \(y_i=g^{s_i}\). The public key \(pk\) is set to be \(pk=\prod_{i=1}^ny_i\). \(P_i\) then performs Feldman's Verifiable Secret Sharing scheme (see <a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/./supporting-algorithms.html">Supporting Protocols</a>) to share \(s_i\) to other participants.  Each \(P_j\) add the secret shares received as his secret key, i.e, \(sk_j=\sum_i s_{ij}\). The values \(sk_i\) are the shares of a \((t-n)\) Shamir secret sharing of the secret key \(sk\).</p>
</li>
<li>
<p>Finally, each participant uses Schnorr's protocol [<a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/../../../bibliography.html#S91">S91</a>] (see <a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/./supporting-algorithms.html">Supporting Protocols</a>) to prove in zero knowledge that he knows the secret key \(sk_i\), </p>
</li>
</ol>
<p><strong>Key Refresh:</strong>
The key refreshment process is executed after a certain number of epochs whenever participants have to reset their partial secret keys.</p>
<ol>
<li>
<p>Each participant \(P_i\) samples \(E_i=(N_i,h_{i1},h_{i2})\), the public key of Pallier Cryptosystem [Unknown bib ref: P91] satisfying \(N_i&gt;2^{8\lambda}\).</p>
</li>
<li>
<p>Each participant \(P_i\) performs Feldman's Verifiable Secret Sharing scheme to distribute the shares \(s_{ij}'\) of \(0\) to other participants. Each participant \(P_i\) set his new secret key to be \(sk_i'=sk_i+\sum_i s_{ji}'\). The secret key \(sk\) remains the same and are unknown to other participants and the values \(sk_i'\) are still the shares of a \((t-n)\) Shamir secret sharing of the secret key \(sk\)</p>
</li>
<li>
<p>Finally, each participant does the following:</p>
<ol>
<li>
<p>Use Schnorr's protocol to prove in zero knowledge that he knows the new secret key \(sk_i'\).</p>
</li>
<li>
<p>Prove that \(N_i\) is a product of two primes \(p_i,q_i\) s.t \(p_i \equiv q_i \equiv 3 \pmod {4}\) and \(N_i\) admits no small factors (see <a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/./supporting-algorithms.html">Supporting Protocols</a>)</p>
</li>
<li>
<p>Prove that \((h_{i1},h_{i2})\) generates the same multiplicative group modulo \(N_i\) using Schnorr protocol for Ring (see <a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/./supporting-algorithms.html">Supporting Protocols</a>).</p>
</li>
</ol>
</li>
</ol>
<p>By the property of Feldman's VSS, it can be proven that the public key \(pk\) is also equal to \(g^{sk}\), hence the key pair \((pk,sk)\) generated using the key generation protocol above has the same form of a key pair in an ECDSA signature scheme. </p>
<p><strong>Note:</strong> Note that after the key generation process, we see that each \(P_i\) is now equipped with a Pallier encryption scheme with public key \(E_i=(N_i,h_{i1},h_{i2})\), which we denote the encryption and decryption algorithm by \(\mathsf{Enc}_i\) and \(\mathsf{Dec}_i\) respectively. The encryption algorithm receives two inputs: the message \(M\) and a randomness \(\rho\). In most cases, for simplicity we will ignore the input randomness \(\rho\) in our description. The encryption scheme will be used in the signing process.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="signing"><a class="header" href="#signing">Signing</a></h3>
<p>In this section, we describe the signing process of the protocol. For any set \(S \in \{1,\dots,n\}\) of \(t+1\) participants who participate to sign a message \(M\), let \(w_i=\lambda_{i,S}\cdot sk_i \pmod{p}\). Note that by Feldman's VSS, \(sk=\sum_{i \in S} w_i\). Note that since \(pk_i=g^{sk_i} \) is public after the key generation process, hence the value \(W_i=g^{w_i}=pk_i^{\lambda_{i,\mathcal{S}}}\) can also be publicly computed. The signing protocol follows a  \(6\) steps process below:</p>
<p><strong>Sign\((M)\langle \{P_i(sk_i)\}_{i=1}^n\rangle\):</strong> </p>
<ol>
<li>
<p>Each participant \(P_i\) choose \(k_i,\gamma_i \in \mathbb{Z}_p\) and does the following:</p>
<ol>
<li>
<p>Compute \(K_i=\mathsf{Enc}_i(k_i), G_i=\mathsf{Enc}_i(\gamma_i)\) </p>
</li>
<li>
<p>Compute a proof \(\pi_i\) certifying \(k_i \in [1,2^{3\lambda}]\) (see <a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/./supporting-algorithms.html">Supporting Protocols</a>).</p>
</li>
<li>
<p>Send \((K_i,G_i,\pi_i)\) to all participants. </p>
</li>
</ol>
</li>
</ol>
<p>Define \(k=\sum_i k_i\) and \(\gamma=\sum_i \gamma_i\). We see that 
\(k\gamma=\sum _{i,j} k_i \gamma_j \pmod{p}\) and \(k\cdot sk=\sum _{i,j} k_i w_j \pmod{p}\).</p>
<ol start="2">
<li>
<p>For each \(j \neq i\), each participant \(P_i\) does the following:</p>
<ol>
<li>
<p>Verify the validity of \(\pi_j\). If any check fails, the protocol aborts.</p>
</li>
<li>
<p>Sample \(\beta_{ij},v_{ij} \in [1,\dots,2^{7\lambda}]\)</p>
</li>
<li>
<p>Comute \(C_{ji}=\mathsf{Enc_j}(\gamma_ik_j-\beta_{ij})=\gamma_i\cdot K_j-\mathsf{Enc_j}(\beta_{ij})\) and \(C_{ji}'=\mathsf{Enc_j}(w_ik_j-v_{ij})=w_i\cdot K_j-\mathsf{Enc_j}(v_{ij})\)</p>
</li>
<li>
<p>Compute \(F_{ji}=\mathsf{Enc_i}(\beta_{ij})\), \(F_{ji}'=\mathsf{Enc_i}(v_{ij})\), \(\Gamma_i=g^{\gamma_i}\) and a proof \(\pi_i^1\) which proves that \(G_i=\mathsf{Enc_j}(\gamma_i)\), \(\Gamma_i=g^{\gamma_i}\) and \(\gamma_i&lt;2^{3\lambda}\).  The generation of \(\pi_1^i\) can be seen in <a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/./supporting-algorithms.html">Supporting Protocols</a></p>
</li>
<li>
<p>Compute the proof \(\pi_i^2\) which prove that \((C_{ji},W_i,K_j,F_{ji},\gamma_i,\beta_{ij})\) satisfy the following relations</p>
<ul>
<li>\(C_{ji}=\gamma_i\cdot K_j-\mathsf{Enc_j}(\beta_{ij}) \)</li>
<li>\(\Gamma_i=g^{\gamma_i} \)</li>
<li>\(F_{ji}=\mathsf{Enc_2}(\beta_{ij}) \)</li>
<li>\(\beta_{ij} \le 2^{7\lambda} \)</li>
<li>\(\gamma_i \le 2^{3\lambda} \)</li>
</ul>
</li>
</ol>
<p>The generation of \(\pi_i^2\) can be seen in <a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/./supporting-algorithms.html">Supporting Protocols</a>.</p>
<ol start="6">
<li>Compute the proof \(\pi_i^3\), which prove that \((C_{ji}',\Gamma_i,K_j,F_{ji}',w_i,v_{ij})\) satisfy the following relations 
<ul>
<li>\(C_{ji}'=w_i\cdot K_j-\mathsf{Enc_j}(v_{ij}) \)</li>
<li>\(W_i=g^{w_i}\)</li>
<li>\(F_{ji}'=\mathsf{Enc_2}(v_{ij})\)</li>
<li>\(v_{ij}&lt;2^{7\lambda} \)</li>
<li>\(w_i \le 2^{3\lambda}  \)</li>
</ul>
</li>
</ol>
<p>The generation of \(\pi_i^3\) can be seen in <a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/./supporting-algorithms.html">Supporting Protocols</a>.</p>
<ol start="7">
<li>Send \(C_{ji},C_{ji}',F_{ji},F_{ji}',\Gamma_i,\pi_i^1,\pi_i^2, \pi_i^3\) to all participants.</li>
</ol>
</li>
<li>
<p>For each \(j \neq i\), each participant \(P_i\) does the following:</p>
<ol>
<li>
<p>Verify the validity of \(\pi_j^1,\pi_j^2,\pi_j^3\). If any check fails, then the protocol aborts.</p>
</li>
<li>
<p>Compute \(\alpha_{ij}=\mathsf{Dec_i}(C_{ij})\) and \(u_{ij}=\mathsf{Dec_i}(C_{ij}') \). Note that \(\alpha_{ij}+\beta_{ij}=\gamma_i k_j\pmod{p}\) and \(u_{ij}+v_{ij}=w_i k_j \pmod{p}\).</p>
</li>
<li>
<p>Set \(\delta_i=k_i\gamma_i+\sum_{j \neq i}(\alpha_{ij}+\beta_{ij}) \pmod{p}\) and \(\sigma_i=k_iw_i+\sum_{j \neq i}(u_{ij}+v_{ij})\pmod{p}\). Note that \(k\gamma=\sum_i\delta_i \pmod{p}\) and \(k\cdot sk=\sum_i \sigma_i \pmod{p}\).</p>
</li>
</ol>
</li>
<li>
<p>Each participant \(P_i\) computes \(\Gamma=\prod_i \Gamma_i=g^\gamma\), \(\Delta_i=\Gamma^{k_i}=g^{\gamma k_i}\) and send \(\delta_i,\Delta_i\) to all participants.</p>
</li>
<li>
<p>Each participant \(P_i\) sets \(\delta=\sum_i\delta_i=k\gamma\) and verify that \(g^{\delta}=\sum_i\Delta_i\). If any check fails, the protocol aborts. Otherwise, set \(R=\Gamma^{\delta^{-1}}=g^{\gamma(k\gamma)^{-1}}=g^{k^{-1}}\) and \(r=R.\mathsf{x}\).</p>
</li>
<li>
<p>Each participants \(P_i\) computes \(m=\mathsf{H}(M)\), then broadcasts \(s_i=m k_i+r \sigma_i \pmod{p}\). and set \(s=\sum_{i} s_i=k(m+r\cdot sk) \pmod{p}\). If <strong>Verify\(((M,(r,s),pk)=1\)</strong> then \((r,s)\) is a valid signature of \(M\), otherwise aborts.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="verification"><a class="header" href="#verification">Verification</a></h3>
<p>Recall that the verification algorithm in threshold ECDSA remain identical to an ordinary ECDSA verification algorithm. Hence, it is sufficient to describe the <strong>Verify</strong> algorithm of the threshold ECDSA below.</p>
<p><strong>Verify\((M,\sigma=(r,s),pk)\):</strong> This is just the standard ECDSA verify algorithm, which can be publicly run by anyone. It works as follows: </p>
<ol>
<li>
<p>Compute \(m=\mathsf{H}(M)\).</p>
</li>
<li>
<p>Compute \(u_1=m\cdot s^{-1} \pmod{p}\) and \(u_2=r\cdot s^{-1} \pmod{p}\).</p>
</li>
<li>
<p>Compute \(R=g^{u_1}pk^{u_2}\).</p>
</li>
<li>
<p>Check if \(r=R.\mathsf{x}\). If the check passes, return \(1\), otherwise return \(0\).</p>
</li>
</ol>
<p>One can see that, if \((r,s)\) is a valid ECDSA signature scheme, which has the form \(r=g^{k^{-1}}.\mathsf{x}\) and \(s=k(m+r\cdot sk)\), then the verification algorithm above returns \(1\) since \(R=g^{u_1}pk^{u_2}=g^{s^{-1}(m+r\cdot sk)}=g^{k^{-1}}\). The converse direction also holds, i.e, if the verify algorithm above return \(1\), then \((r,s)\) must be  a valid ECDSA signature which have the form above.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="supporting-protocols"><a class="header" href="#supporting-protocols">Supporting Protocols</a></h3>
<p>In this section, we specify the supporting protocols that support the signing protocol described in the previous section.</p>
<h4 id="feldmans-vss"><a class="header" href="#feldmans-vss">Feldman's VSS</a></h4>
<p>Recall that in Step 2 of the key generation protocol, each participant \(P\) has to perform Feldman's VSS to share his secret \(s\) to other participants \(P_i\). The process of Feldman's VSS is described as follow:</p>
<ol>
<li>
<p>\(P\) generate a random degree \(t\) polynomial \(f(x)=a_0+a_1x+\dots+a_tx^t\) such that \(a_0=s\), then broadcast \(A_i=g^{a_i}\) for \( i \in \{0,1,\dots,t\}\). Finally \(P\) secretly send the share \(s_i=f(i)\) to the \(i\)-th participant \(P_i\). </p>
</li>
<li>
<p>Each participant \(P_i\) can verify the correctness of his share \(s_i\) by checking \(g^{s_i}=\prod_{j=0}^tA_j^{i^j}\). If the check fails, \(P_i\) broadcasts a complaint to \(P\). If \(P\) receives a complaint he will be disqualified. </p>
</li>
</ol>
<h4 id="zero-knowledge-proofs"><a class="header" href="#zero-knowledge-proofs">Zero Knowledge Proofs</a></h4>
<p><strong>Schnorr Protocol:</strong></p>
<p>In Step 3 of the initial key generation process, a participant who broadcasts \(pk_i=g^{sk_i}\) must prove the knowledge of \(sk_i\) using Schnorr protocol. Schnorr protocol can be described as follow:</p>
<ol>
<li>
<p>The prover chooses \(a \in \mathbb{Z}_p\) and sends \(\alpha=g^a\).</p>
</li>
<li>
<p>The verifier sends a challenge \(c \in \mathbb{Z}_p\).</p>
</li>
<li>
<p>The prover sends \(u=a+c\sigma\).</p>
</li>
<li>
<p>The verifier checks if \(g^u=\alpha\cdot pk_i^c\).</p>
</li>
</ol>
<p><strong>Schnorr Protocol for Ring:</strong></p>
<p>In Step 3.3 of the key refresh process, a participant who broadcasts \(h_1,h_2\) must prove that there is a value \(s\) such that \(h_2=h_1^s \pmod{N}\) The protocol can be described as follow:</p>
<ol>
<li>
<p>For each \(i=1,\dots,\lambda\), the prover chooses \(a_1 \in \mathbb{Z_{\phi(N)}}\) and sends \(A_i=h_1^{a_i} \pmod{N}\) to the verifier.</p>
</li>
<li>
<p>The verifier sends a challenge \(e_i \in {0,1}\) for each \(i=1,\dots,\lambda\).</p>
</li>
<li>
<p>For each \(i=1,\dots,\lambda\), the prover sends \(z_i=a_i+e_i s \pmod{\phi(N)}\) and send \(z_i\) to the verifier.</p>
</li>
<li>
<p>The verifier checks if \(h_1^{z_i}=A_i\cdot h_2^c \pmod{N}\) for each \(i=1,\dots,\lambda\).</p>
</li>
</ol>
<p><strong>Proof of Product of Two Primes:</strong></p>
<p>In Step 3.2 of the key refresh process, a participant must prove that the RSA modulus \(N\) is a product of two primes \(p,q\) such that \(N=pq\) and \(p \equiv q \equiv 3 \pmod{4}\) and \(gcd(N,\phi(N))=1\). The protocol process as follow:</p>
<ol>
<li>
<p>The prover samples \(w \in \mathbb{Z_N}\) s.t \(\left(\dfrac{w}{N}\right)=-1\) where \(\left(\dfrac{w}{N}\right)\) denotes the Jacobian symbol.</p>
</li>
<li>
<p>The verifier samples \(y_1,\dots,y_{\lambda} \in \mathbb{Z_N}\) and send them to the prover.</p>
</li>
<li>
<p>The prover proceed as follows:</p>
<ul>
<li>
<p>Set \(x_i=(y_i')^{1/4} \pmod{N}\) where \(y_i'=(-1)^{a_i}w^{b_i}y_i\) such that \(x_i\) is well defined.</p>
</li>
<li>
<p>Compute \(z_i=y_i^{-N} \pmod{N}\)</p>
</li>
<li>
<p>Send \((x_i,a_i,b_i,z_i)_{i=1}^\lambda\) to verifier.</p>
</li>
</ul>
</li>
<li>
<p>The verifier checks that \(N\) is not a prime, \(z_i^N \equiv y_i \pmod{N}\) and \(x_i^4 \equiv (-1)^{a_i}w^{b_i}y_i \pmod{N}\). Accept if and only if all checks pass.</p>
</li>
</ol>
<p><strong>Pallier Encryption Range Proof:</strong> </p>
<p>In Step 1.2 of the signing process, each participant given \(K_i=\mathsf{Enc_i}(k_i)\) has to provide a proof \(\pi\) certifying \(k_i&lt;2^{3\lambda}\). The protocol for providing \(\pi\)  proceeds as follow:</p>
<ol>
<li>
<p>The protocol chooses \(N,h_1,h_2\) to be the auxiliary set-up parameter for the protocol, where \(N\) is a product of two safe prime and \(h_1,h_2\) generate the same multiplicative group modulo \(N\).</p>
</li>
<li>
<p>The prover samples \(\alpha \in [-2^{3\lambda},\dots,2^{3\lambda}]\), \(\delta \in [-2^{3\lambda}\cdot N,\dots,2^{3\lambda}\cdot N]\), \(u \in [-2^{\lambda}\cdot N,\dots,2^{\lambda}\cdot N]\), \(r \in \mathbb{Z_{N_1}}\)</p>
</li>
<li>
<p>The prover computes \(S=h_1^k h_2^u \pmod{N}\), \(A=(1+N_1)^\alpha r^{N_1} \pmod {N_1^2}\) and \(C=h_1^\alpha h_2^\delta \pmod{N}\)</p>
</li>
<li>
<p>The prover sends \((S,A,C)\) to the verifier.</p>
</li>
<li>
<p>The verifier chooses a challenge \(e \in [-p,\dots,p]\) and sends \(e\) to the prover.</p>
</li>
<li>
<p>The prover computes \(z_1=\alpha+ek\), \(z_2=r\rho^e \pmod{N_1}\) and \(z_3=\delta+eu\)</p>
</li>
<li>
<p>The prover sends \(\pi=(z_1,z_2,z_3)\) to the verifier</p>
</li>
<li>
<p>The verifier checks if \((1+N_1)^{z_1}z_2^{N_1}=AK^e \pmod{N_1^2}\) and \(h_1^{z_1}h_2^{z_3}=CS^e \pmod{N}\)</p>
</li>
</ol>
<p>9 The verifier checks that \(z_i \in [-2^{3\lambda},\dots,2^{3\lambda}]\)</p>
<p><strong>Proof of Paillier Encryption given Group Commitment:</strong></p>
<p>In Step 2.4 of the signing process, each participant has public input \((C,X)\) and secret input \(x\) and has to provide a proof \(\pi\) which proves that \(((C,X),x) \in \mathcal{R}\), where</p>
<p>\(\mathcal{R}=\{((C,X),(x,\rho))\ |\ X=g^{x}\ \land\ C=\mathsf{Enc_1}(x,\rho)\ \land\ x \le 2^{3\lambda}\}\). The protocol for providing \(\pi\) proceeds as follow:</p>
<ol>
<li>
<p>The protocol chooses \(N,h_1,h_2\) to be the auxiliary set-up parameter for the protocol, where \(N\) is a product of two safe prime and \(h_1,h_2\) generate the same multiplicative group modulo \(N\).</p>
</li>
<li>
<p>The prover samples \(\alpha \in [-2^{3\lambda},\dots,2^{3\lambda}]\), \(\delta \in [-2^{3\lambda}\cdot N,\dots,2^{3\lambda}\cdot N]\), \(u \in [-2^{\lambda}\cdot N,\dots,2^{\lambda}\cdot N]\), \(r \in \mathbb{Z_{N_1}}\)</p>
</li>
<li>
<p>The prover computes \(S=h_1^xh_2^u \pmod{N}\), \(A=(1+N_1)^\alpha r^N_1 \pmod{N_1^2}\), \(Y=g^\alpha\), \(D=h_1^\alpha h_2^\gamma \pmod{N}\)</p>
</li>
<li>
<p>The prover sends \(S,A,Y,D,F\) to the verifier.</p>
</li>
<li>
<p>The verifier chooses a challenge \(e \in [-p,\dots,p]\) and sends \(e\) to the prover.</p>
</li>
<li>
<p>The prover computes \(z_1=\alpha+ek\), \(z_2=r\rho^e \pmod{N_1}\) and \(z_3=\gamma+eu\)</p>
</li>
<li>
<p>The prover sends \(\pi=(z_1,z_2,z_3)\) to the verifier.</p>
</li>
<li>
<p>The verifier checks that \((1+N_1)^{z_1}z_2^{N_1}=AC^e \pmod{N_1^2}\), \(g^{z_1}=YX^e\) and \(h_1^{z_1}h_2^{z_3}=DS^e \pmod{N}\)</p>
</li>
<li>
<p>The verifier check that \(z_1 \in [-2^{3\lambda},\dots,2^{3\lambda}]\)</p>
</li>
</ol>
<p><strong>Proof of Paillier Operation given Group Commitment:</strong></p>
<p>In Step 2.5 and 2.6 of the signing process, each participant has public input \((C,X,K,Y)\) and secret input \((x,y)\) and has to provide a proof \(\pi\) which proves that \(((C,X,K,Y),(x,y)) \in \mathcal{R}\), where</p>
<p>\(\mathcal{R}=\{((C,X,K,Y),(x,y,\rho,\rho_y))\ |\ C=x\cdot K-\mathsf{Enc_1}(y,\rho)\ \land\ X=g^{x}\ \land\ Y=\mathsf{Enc_2}(y,\rho_y)\ \land\ x&lt;2^{3\lambda}\ \land \ y \le 2^{7\lambda}\}\) The protocol for providing \(\pi\) proceeds as follow:</p>
<ol>
<li>
<p>The protocol chooses \(N,h_1,h_2\) to be the auxiliary set-up parameter for the protocol, where \(N\) is a product of two safe prime and \(h_1,h_2\) generate the same multiplicative group modulo \(N\).</p>
</li>
<li>
<p>The prover samples \(\alpha\in [-2^{3\lambda},\dots,2^{3\lambda}]\), \(\beta\in [-2^{7\lambda},\dots,2^{7\lambda}]\), \(\gamma, \delta \in [-2^{3\lambda}\cdot N,\dots,2^{3\lambda}\cdot N]\), \(m, u \in [-2^{\lambda}\cdot N,\dots,2^{\lambda}\cdot N]\), \(r \in \mathbb{Z_{N_1}}\) and \(r_y \in \mathbb{Z_{N_2}}\)</p>
</li>
<li>
<p>The prover computes \(A=K^\alpha((1+N_1)^\beta r^{N_1}) \pmod {N_1^2}\), \(B_x=g^\alpha\), \(B_y=(1+N_2)^\beta r_y\), \(E=h_1^\alpha h_2^\gamma \pmod{N}\), \(F=h_1^\beta h_2^\gamma \pmod{N}\), \(S=h_1^xh_2^m \pmod{N}\), \(T=h_1^yh_2^u \pmod{N}\)</p>
</li>
<li>
<p>The prover sends \(S,T,A,B_x,B_y,E,F\) to the verifier.</p>
</li>
<li>
<p>The verifier chooses a challenge \(e \in [-p,\dots,p]\) and sends \(e\) to the prover.</p>
</li>
<li>
<p>The prover compute \(z_1=\alpha+ex\), \(z_2=\beta+ey\), \(z_3=\gamma+em\), \(z_4=\delta+eu\), \(w=r \rho^e \pmod{N_1}\), \(w_y=r \rho_y^e \pmod{N_2}\)</p>
</li>
<li>
<p>The prover sends \(\pi=(z_1,z_2,z_3,z_4,w,w_y)\) to the verifier.</p>
</li>
<li>
<p>The verifier checks that \(K^{z_1}(1+N_1)^{z_2}w^{N_1} = A C^e \pmod{N}\), \(g^{z_1}=B_xX^e\), \((1+N_2)^{z_2}w_y^{N_2}=B_yY^e \pmod{N_2}\), \(h_1^{z_1}h_2^{z_3}=ES^e \pmod{N}\), \(h_1^{z_2}h_2^{z_4}=FT^e \pmod{N}\)</p>
</li>
<li>
<p>The verifier check that \(z_1 \in [-2^{3\lambda},\dots,2^{3\lambda}]\) and \(z_1 \in [-2^{7\lambda},\dots,2^{7\lambda}]\)</p>
</li>
</ol>
<h4 id="commitment-scheme"><a class="header" href="#commitment-scheme">Commitment Scheme</a></h4>
<p>In Step 1 of the Key Generation protocol, we require participants to commit their messages using a commitment scheme \(\mathsf{Com}\). In practice, one can use a cryptographic hash function \(\mathsf{H}\) and define the commitment of \(X\) to be \(\mathsf{H}(X,r)\) where \(r\) is chosen uniformly. </p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="identifying-aborts"><a class="header" href="#identifying-aborts">Identifying Aborts</a></h2>
<p>Identifying misbehaving participants efficiently is a key contribution of “CGMP21”. An abort will happen if any player deviates from the protocol in a clearly identifiable way by not complying with instructions. In the case of such an abort, the guilty party would have to be identified and removed. In this section, we analyse how the protocol can identify abortion and remove mmisbehaving participants.</p>
<h3 id="abort-instances"><a class="header" href="#abort-instances">Abort Instances</a></h3>
<p>Within the signing protocol, there are 3 instances that the protocol can abort. They can be summarized as follows:</p>
<ol>
<li>
<p>In step 2 of the signing process, when an invalid proof \(\pi_i\) is detected.</p>
</li>
<li>
<p>In step 3 of the signing process, when an invalid proof \(\pi_i^1\) or \(\pi_j^2\) or \(\pi_k^3\) is detected for some \(i,j,k\).</p>
</li>
<li>
<p>In step 5 of the signing proces, when \(g^{\delta}=\sum_i\Delta_i\)</p>
</li>
<li>
<p>In step 6 of the signing process, when \((r,s)\) is not a valid signature of \(M\)</p>
</li>
</ol>
<h3 id="how-to-identify-abortions"><a class="header" href="#how-to-identify-abortions">How to Identify Abortions</a></h3>
<p>Now, we show that how to identify the misbehaving participants that cause the protocol to abort in each cases above.</p>
<ol>
<li>
<p>The first and second instances are straightforward. Whoever submits the wrong proof will be identified as malicious.</p>
</li>
<li>
<p>The third and fourth instance are much more complicated. At a high level, the identification of these two instances proceed as follow:</p>
<ol>
<li>
<p>Each participant \(P_i\) is asked to reprove that the ciphertexts \(C_{ij}\) are well formed for each \(j \neq i\). </p>
</li>
<li>
<p>Each participant \(P_i\) is asked to reveal \(H_i=\mathsf{Enc_i}(k_i \gamma_i)\) and \(H_i'=\mathsf{Enc_i}(k_i w_i)\) and prove their correctness given \(K_i,G_i\) and \(X_i\).</p>
</li>
<li>
<p>Each participant \(P_i\) prove that \(\delta_i\) is the plaintext obtained via the ciphertext \(U_i=H_i\prod_{j \neq i}C_{ij}F_{ji}=\mathsf{Enc_i}(k_i\gamma_i+\sum_{j \neq i}(\alpha_{ij}+\beta_{ij}))\)</p>
</li>
<li>
<p>Similarly, each participant \(P_i\) prove that \(s_i\) is the plaintext obtained via the ciphertext \(V_i=K_i^m(H_i'\prod_{j \neq i}C_{ij}'F_{ji}')^r=\mathsf{Enc_i}(mk_i+r(k_iw_i+\sum_{j \neq i}(u_{ij}+v_{ij})))=\mathsf{Enc_i}(mk_i+r\sigma_i)\)</p>
</li>
<li>
<p>Whoever fails to prove will be identified as the malicious participant.</p>
</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="security-consideration"><a class="header" href="#security-consideration">Security Consideration</a></h3>
<p>Finally, since there has been numerous pracical attacks performed on threshold ECDSA implementations, we would like to discuss several concerns that should be noted when implementing the threshold ECDSA protocol. </p>
<ul>
<li>
<p><strong>Proving the Discrete Log Relation in Composite Modulus:</strong> Recall that in Step 3 of the key refresh process, we require the participants \(P_i\) to prove the discrete log relation between \(h_{i1}\) and \(h_{i2}\) in modulo \(N_i\). This can be done using Schnorr's protocol for Ring, as specified in (see <a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/./supporting-algorithms.html">Supporting Protocols</a>). The protocol uses binary challenge \(c \in \{0,1\}\), which has soundness error \(1/2\). It is repeated \(\lambda\) times to achieve soundness error \(1/2^\lambda\). When the order of the group is a prime number \(p\), one can <strong>extend the challenge set</strong> to be \(\mathbb{Z}_p\) and execute the protocol <strong>only once</strong>, this is the case of an ordinary Schnorr protocol. However, we cannot do the same thing for the group \(\mathbb{Z}^*_N\), since its order is divisible by \(2\). <a href="https://www.verichains.io/tsshock/">Verichain</a> showed that doing so can leak the secret key of the protocol. Hence, we need to <strong>repeat the Schnorr protocol for Ring</strong> \(\lambda\) <strong>times when proving the discrete log relation in modulo</strong> \(N_i\) for each \(i\).</p>
</li>
<li>
<p><strong>The Requirement of Range Proof:</strong> Recall that in step 2 of the signing protocol, we require that each participant has to prove that some of their secret range must lie in a specified value (we require \(k_i,\lambda_i,w_i, \le 2^{3\lambda}\) and \(\gamma_{ij},v_{ij}&lt;2^{7\lambda}\)). The range proof might looks unnecessary at the first glance, however it is shown in [<a href="threshold-ecdsa/threshold-ecdsa-construction/actual-construction/../../../bibliography.html#TS21">TS21</a>] that the lack of these range proofs can break the security of the protocol. The reason for this is that range proofs ensure that the encrypted values are within a specified range, and prevent attackers from tampering with the values or sending invalid data. Hence it is necessary to <strong>ensure that these range proofs are done</strong> in the protocol.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="frosts-construction"><a class="header" href="#frosts-construction">FROST's Construction</a></h2>
<p>In this section we briefly describe the FROST threshold Schnorr protocol in [<a href="threshold-ecdsa/frost-construction/../../bibliography.html#KG20">KG20</a>], in which we assume that the readers have some familiarity to Schnorr signature scheme. Recall that the ordinary Schnorr signature scheme, the signature \(\sigma=(R,z)\) of a message \(M\) is generated as follow</p>
<p>$$R=g^r,\ c=\mathsf{H}(R||\mathsf{pk}||M)\ \text{and}\ z=r+c\cdot sk,$$</p>
<p>where \(r \leftarrow \mathbb{Z}_p\) and \(sk\) is the signer's secret key. Note that the EdDSA signature scheme also produces the signature with the exact form above, with the <strong>only difference</strong> is that the nonce \(r\) is produced deterministically.  FROST aims to provide a valid Schnorr signature (as well as EdDSA signature) of \(M\) above via a threshold manner. Compared to its threshold ECDSA counterpart, the FROST threshold Schnorr signature is much simplier, has much less features to describe and analyse.  We now move to the actual construction of FROST and describe it.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="key-generation-1"><a class="header" href="#key-generation-1">Key Generation</a></h3>
<p>In this section, we describe the key generation process in the construction of FROST below. </p>
<p><strong>Notation:</strong> Let \(\lambda\) to be the security parameter. Let \(\mathbb{G}\) to be a cyclic group whose order is a prime number. Let \(p \in (2^{\lambda-1},2^\lambda)\) to be the order of \(\mathbb{G}\) and let \(g,h\) to be two generators of \(\mathbb{G}\). We denote \(\mathsf{Com}\) to be a secure binding and information theoretic hiding commitment scheme and \(\mathsf{H}\) to be a cryptographic hash function. For any set \(\mathcal{S}\) and for any \(i \in \mathcal{S}\) we denote \(\lambda_{i,S}=\prod_{j\in \mathcal{S},j \neq i}\dfrac{j}{j-i}\) to be the Lagrange coefficient w.r.t \(S\).</p>
<p><strong>Keygen \((1^\lambda)\langle \{P_i\}_{i=1}^n\rangle\):</strong></p>
<p>The key generation process is executed once at the beginning.</p>
<ol>
<li>
<p>Each participant \(P_i\) selects \(s_i \in Z_p \) and compute \(C_i=\mathsf{Com}(g^{s_i})\).</p>
</li>
<li>
<p>Each participant \(P_i\) broadcasts \(y_i=g^{s_i}\). The public key \(pk\) is set to be \(pk=\prod_{i=1}^ny_i\). \(P_i\) then performs Feldman's Verifiable Secret Sharing scheme (see <a href="threshold-ecdsa/frost-construction/./supporting-algorithms.html">Supporting Protocols</a>) to share \(s_i\) to other participants.  Each \(P_j\) add the secret shares received as his secret key, i.e, \(sk_j=\sum_i s_{ij}\). The values \(sk_i\) are the shares of a \((t-n)\) Shamir secret sharing of the secret key \(sk\).</p>
</li>
<li>
<p>Finally, each participant uses Schnorr's protocol [<a href="threshold-ecdsa/frost-construction/../../bibliography.html#S91">S91</a>] (see <a href="threshold-ecdsa/frost-construction/./supporting-algorithms.html">Supporting Protocols</a>) to prove in zero knowledge that he knows the secret key \(sk_i\), </p>
</li>
</ol>
<p>By the property of Feldman's VSS, it can be proven that the public key \(pk\) is also equal to \(g^{sk}\), hence the key pair \((pk,sk)\) generated using the key generation protocol above has the same form of a key pair in a Schnorr signature scheme. </p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="signing-1"><a class="header" href="#signing-1">Signing</a></h3>
<p>In this section, we describe the signing process of the protocol. For any set \(S \in \{1,\dots,n\}\) of \(t+1\) participants who participate to sign a message \(M\), let \(w_i=\lambda_{i,S}\cdot sk_i \pmod{p}\). Note that by Feldman's VSS, \(sk=\sum_{i \in S} w_i\). Note that since \(pk_i=g^{sk_i} \) is public after the key generation process, hence the value \(W_i=g^{w_i}=pk_i^{\lambda_{i,\mathcal{S}}}\) can also be publicly computed. The signing protocol follows a  \(6\) steps process below:</p>
<p><strong>Sign\((M)\langle \{P_i(sk_i)\}_{i=1}^n\rangle\):</strong> </p>
<ol>
<li>
<p>Each participant \(P_i\) chooses \(d_{i},e_{i} \in \mathbb{Z_p}\) and broadcasts \((D_{i},E_{i})=(g^{d_{i}},g^{e_{i}})\). Denote \(B=\{(i,D_i,E_i)\}_{i \in S}\).</p>
</li>
<li>
<p>For each \(j \neq i\), each \(P_i\) uses Schnorr protocol (see <a href="threshold-ecdsa/frost-construction/./supporting-algorithms.html">Supporting Algorithms</a>) to check the validity of \((D_i,E_i)\). If any check fails then the protocol aborts.</p>
</li>
<li>
<p>Each \(P_i\) computes \(\rho_j=\mathsf{H}(j,M,B)\) for all \(j \in S\). Each \(P_i\) then computes the group commitment \(R=\prod_{j \in S} D_jE_j^{\rho_j}\) and the challenge \(c=\mathsf{H}(R,\mathsf{pk},M)\), then broadcasts \((\rho_i,R,c)\). </p>
</li>
<li>
<p>Each \(P_i\) computes \(z_i=d_i+e_i\rho_i+\lambda_{i,S}\cdot \mathsf{sk_i} \cdot c\) and broadcasts \(z_i\).</p>
</li>
<li>
<p>Each \(P_i\) computes \(R_i=D_iE_i^{\rho_i}\) and broadcasts \(R_i\).</p>
</li>
<li>
<p>For each \(i\), participants check if \(R=\prod_{i\in S}R_i\) and \(g_i=R_i\mathsf{pk_i}^{c \lambda_{i,S}}\). If any check fails, report the misbehaving \(P_i\) and the protocol is aborted. Otherwise, compute \(z=\sum_{i \in S}z_i\) and returns \(\sigma=(R,z)\).</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="verification-1"><a class="header" href="#verification-1">Verification</a></h3>
<p>Recall that the verification algorithm in threshold Schnorr remain identical to an ordinary Schnorr verification algorithm. Hence, it is sufficient to describe the <strong>Verify</strong> algorithm of the Schnorr signature scheme below.</p>
<p><strong>Verify\((M,\sigma=(R,z),\mathsf{pk})\):</strong> This is just the standard Schnorr verify algorithm, which can be publicly run by anyone. It works as follow: </p>
<ol>
<li>
<p>Compute \(c=\mathsf{H}(R||\mathsf{pk}||M)\).</p>
</li>
<li>
<p>Compute \(R'=g^z \mathsf{pk}^{-c}\).</p>
</li>
<li>
<p>Check if \(R'=R\). If the check passes, return \(1\), otherwise return \(0\).</p>
</li>
</ol>
<p>One can see that, if \((R,z)\) is a valid Schnorr signature scheme, which has the form \(R=g^r, c=\mathsf{H}(R||\mathsf{pk}||M)\) and \(z=r+c \cdot \mathsf{sk})\), then the verification algorithm above returns \(1\) since \(R'=g^{z-\mathsf{sk}\cdot c}=g^r=R\). The converse direction also holds, i.e, if the verify algorithm above return \(1\), then \((R,c,z)\) must be  a valid Schnorr signature which have the form above.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="supporting-protocols-1"><a class="header" href="#supporting-protocols-1">Supporting Protocols</a></h3>
<p>In this section, we specify the supporting protocols that support the signing protocol described in the previous section.</p>
<h4 id="feldmans-vss-1"><a class="header" href="#feldmans-vss-1">Feldman's VSS</a></h4>
<p>Recall that in Step 2 of the key generation protocol, each participant \(P\) has to perform Feldman's VSS to share his secret \(s\) to other participants \(P_i\). The process of Feldman's VSS is described as follows:</p>
<ol>
<li>
<p>\(P\) generate a random degree \(t\) polynomial \(f(x)=a_0+a_1x+\dots+a_tx^t\) such that \(a_0=s\), then broadcast \(A_i=g^{a_i}\) for \( i \in \{0,1,\dots,t\}\). Finally \(P\) secretly send the share \(s_i=f(i)\) to the \(i\)-th participant \(P_i\). </p>
</li>
<li>
<p>Each participant \(P_i\) can verify the correctness of his share \(s_i\) by checking \(g^{s_i}=\prod_{j=0}^tA_j^{i^j}\). If the check fails, \(P_i\) broadcasts a complaint to \(P\). If \(P\) receives a complaint he will be disqualified. </p>
</li>
</ol>
<h4 id="zero-knowledge-proofs-1"><a class="header" href="#zero-knowledge-proofs-1">Zero Knowledge Proofs</a></h4>
<p><strong>Schnorr Protocol:</strong></p>
<p>In Step 3 of the initial key generation process, a participant who broadcasts \(pk_i=g^{sk_i}\) must prove the knowledge of \(sk_i\) using Schnorr protocol. Schnorr protocol can be described as follows:</p>
<ol>
<li>
<p>The prover chooses \(a \in \mathbb{Z}_p\) and sends \(\alpha=g^a\).</p>
</li>
<li>
<p>The verifier sends a challenge \(c \in \mathbb{Z}_p\).</p>
</li>
<li>
<p>The prover sends \(u=a+c\sigma\).</p>
</li>
<li>
<p>The verifier checks if \(g^u=\alpha\cdot pk_i^c\).</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="threshold-signature-instatiations"><a class="header" href="#threshold-signature-instatiations">Threshold Signature Instatiations</a></h2>
<p>In this section, we are going to discuss our concrete instatiations for the construction of Canneti et al and FROST. More specifically, we will discuss and analyse the security when instatiating the construction of Canneti et al using <strong>secp256k1</strong> parameters and FROST with <strong>ed25519</strong> and <strong>sr25519</strong> parameters to support the MPC version for these concrete variants.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="threshold-signature-for-secp256k1"><a class="header" href="#threshold-signature-for-secp256k1">Threshold signature for secp256k1</a></h3>
<p>Bitcoin, the first and most well-known cryptocurrency, relies on the curve <strong>secp256k1</strong> for its public key cryptography. Specifically, it uses the ECDSA algorithm with <strong>secp256k1</strong> as the underlying elliptic curve. Many other cryptocurrencies, including Ethereum have since adopted this curve for their digital signature schemes. Since the curve can be used for the orinary ECDSA algorithm, it can also be used for the threshold ECDSA version as well. Below we describe the curve parameter and its security and efficiency analysis.</p>
<p>The secp256k1 curve parameters \(E:y^2=x^3+ax+b\) defined over \(\mathbb{F}_p\) with order \(n\), cofactor \(f\) and base point \(G\) are as follows:</p>
<ul>
<li>
<p>\(p=0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\)</p>
</li>
<li>
<p>\(a=0x00\)</p>
</li>
<li>
<p>\(b=0x07\)</p>
</li>
<li>
<p>\(n=0xfffffffffffffffffffffffffffffffebaaedce6af48a03Bbfd25e8cd0364141\)</p>
</li>
<li>
<p>\(f=1\)</p>
</li>
<li>
<p>\(G=(0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,\)
\(0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8)\)</p>
</li>
</ul>
<p>For security analysis, this curve is chosen by Satoshi Nakamoto because unlike the popular NIST curves, <strong>secp256k1</strong>'s constants were selected in a predictable way, which significantly reduces the possibility that the curve's creator inserted any sort of backdoor into the curve. In addition, it is implied in [<a href="threshold-ecdsa/intended-implementation/../../bibliography.html#SECG1">SECG1</a>] that the curve has a security level of \(128\) bits, which is considered secure.</p>
<p>We intend to implement the threshold ECDSA construction of [<a href="threshold-ecdsa/intended-implementation/../../bibliography.html#CGGMP21">CGGMP21</a>] using <strong>secp256k1</strong> parameters. We would like to use the library <a href="https://github.com/paritytech/libsecp256k1">libsecp256k1</a> for curve operations, which has been tested extensively and undergone thorough optimitation, making it very fast to produce signatures. </p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="threshold-signature-for-ed25519"><a class="header" href="#threshold-signature-for-ed25519">Threshold signature for ed25519</a></h3>
<p><strong>Ed25519</strong> is the most popular instance of the Edwards-curve Digital Signature Algorithm (EdDSA) standardized in <a href="https://datatracker.ietf.org/doc/html/rfc8032">RFC 8032</a>. In the paper, the authors <strong>instatiatied the Schnorr signature scheme with the curve curve25519 in its twisted Edward form</strong> instead of an ordinary elliptic curve such as secp256k1. The used curve in the scheme is popular due to its high speed compared to other curves without sacrificing security. Below we describe the curve parameters and its security and efficiency analysis.</p>
<p>The curve parameters \(E: ax^2+y^2=1+bx^2y^2\) defined over \(\mathbb{F}_p\) with order \(n\), cofactor \(f\) and base point \(G\) are as follows:</p>
<ul>
<li>
<p>\(p=0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed\)</p>
</li>
<li>
<p>\(a=0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec\)</p>
</li>
<li>
<p>\(b=0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3\)</p>
</li>
<li>
<p>\(n= 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed\)</p>
</li>
<li>
<p>\(f=8\)</p>
</li>
<li>
<p>\(G=(0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a,\)
\(0x6666666666666666666666666666666666666666666666666666666666666658)\)</p>
</li>
</ul>
<p>For security analysis, the provable security of the instatiation of ed25519 parameters has been well studied in [<a href="threshold-ecdsa/intended-implementation/../../bibliography.html#BCJZ20">BCJZ20</a>]. In addition, it has been confirmed in [<a href="threshold-ecdsa/intended-implementation/../../bibliography.html#BDLSY12">BDLSY12</a>] that the curve achieves \(128\) bit security level, the same security level as secp256k1, which is considered secure. However, due to having the cofactor of \(8\), the scheme could be potentially vulnerable to a <a href="threshold-ecdsa/intended-implementation/./https://www.getmonero.org/2017/05/17/disclosure-of-a-major-bug-in-cryptonote-based-currencies.html">double spend exploit</a>.</p>
<p>Recall that <strong>ed25519 is just a variant of Schnorr signature instatiatied with a a twisted Edward curve</strong>, and its signature form \(R,c,z\) is identical to an ordinary Schnorr signature scheme, we can instatiate the FROST threshold signature scheme of [<a href="threshold-ecdsa/intended-implementation/../../bibliography.html#KG20">KG20</a>] with the parameters of <strong>ed25519</strong> described in to achieve the MPC version of <strong>ed25519</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="threshold-signature-for-sr25519"><a class="header" href="#threshold-signature-for-sr25519">Threshold signature for sr25519</a></h3>
<p>The term <strong>sr25519</strong> refers to the instatiation of Schnorr signature using the curve <strong>curve25519</strong>, the same curve as of EdDSA, which is specified in <a href="https://github.com/w3f/schnorrkel">Schnorrkel</a>. However, it additionally employs the method of point compression due to  <a href="https://ristretto.group">Ristretto</a> to make makes Schnorr signatures over the Edward's curve more secure. Below we describe the curve parameter and its security and efficiency analysis.</p>
<p>The <strong>sr25519</strong> scheme supports both forms of <strong>curve25519</strong>, i.e, its twisted Edward form and Montomery form. The twisted Edward form of <strong>curve25519</strong> has been described in the previous Section. For the Montomery form, the curve can be written as \(E:by^2=x^3+ax^2+x\) over \(\mathbb{F}_p\) with order \(n\), cofactor \(f\) and base point \(G\) are as follows:</p>
<ul>
<li>
<p>\(p=0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed\)</p>
</li>
<li>
<p>\(a=0x76d06\)</p>
</li>
<li>
<p>\(b=0x01\)</p>
</li>
<li>
<p>\(n=0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed\)</p>
</li>
<li>
<p>\(cofactor=1\)</p>
</li>
<li>
<p>\(G=(0x09,0x20ae19a1b8a086b4e01edd2c7748d14c923d4d7e6d7c61b229e9c5a27eced3d9)\)</p>
</li>
</ul>
<p>For security analysis, recall that the curve <strong>curve25519</strong> achieves \(128\) bit security level, as specified in the previous Section. However, since <strong>sr25519</strong> additionally uses the point compression due to Ristretto, it is safe from the bug could lead to a double spend expoit of <a href="threshold-ecdsa/intended-implementation/./https://www.getmonero.org/2017/05/17/disclosure-of-a-major-bug-in-cryptonote-based-currencies.html">Monero</a></p>
<p>Finally, because <strong>sr25519 is actually the Schnorr signature instatiatied with the  curve25519</strong> and FROST is a threshold Schnorr signature scheme that can be instatiated by any curve where the discrete log problem is hard, we can instatiate the FROST threshold signature scheme of [<a href="threshold-ecdsa/intended-implementation/../../bibliography.html#KG20">KG20</a>] with the parameters of <strong>sr25519</strong> described in  to achieve the MPC version of <strong>sr25519</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="isogeny-based-cryptography"><a class="header" href="#isogeny-based-cryptography">Isogeny based cryptography</a></h1>
<p>We introduce Isogeny based cryptography, one of the possible candidates for post-quantum cryptography. People may have heard the SIKE protocol have been broken [<a href="isogeny-based-crypto/../bibliography.html#CD22">CD22</a>], but many other isogeny based cryptosystems, such as the CLG hash function  [<a href="isogeny-based-crypto/../bibliography.html#CGL06">CGL06</a>] and SQISign [Unknown bib ref: SKLPW20] remains secure against the attack on SIDH. We begin with supersingular isogeny graph and its properties, then we describe several isogeny based cryptosystems.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="overview-of-supersingular-isogeny-graph"><a class="header" href="#overview-of-supersingular-isogeny-graph">Overview of Supersingular Isogeny Graph</a></h2>
<p>In this chapter, we introduce supersingular isogeny graph and its properties to see why this graph is used in isogeny based cryptography. The vertices of the graph represent the supersingular elliptic curves, and the edges of the graph represent the isogenies between these curves. We will state the definitions of supersingular elliptic curves and isogenies, then describe the structure of the graph and its nice properties in cryptography.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="elliptic-curves"><a class="header" href="#elliptic-curves">Elliptic Curves</a></h3>
<h4 id="definition-1"><a class="header" href="#definition-1">Definition</a></h4>
<p>Let \(K\) be a field. An <strong>elliptic curve</strong> \(E\) is a plane curve defined over the field \(K\) as follows:
$$E(K)=\{y^2=x^3+ax+b : (x,y) \in K^2\} \cup \{O\}$$
where \((a,b) \in K^2\). The point \(O\) is called the infinity point of the curve. The set \(E(K)\) forms an abelian group with identity element \(O\).</p>
<p>In addition, we need the curve to have no cusps, self-intersections, or isolated points. Algebraically, this can be defined by the condition \(4a^3+27b^2 \neq 0\) in the field \(K\).</p>
<p>The <strong>\(j-\) invariant</strong> of an elliptic curve is defined to be \(-1728\frac{4a^3}{4a^3+27b^2}\). Two elliptic curves are isomorphic to each other if and only if they have the same \(j-\) invariant value.</p>
<p>The <strong>endomorphism ring</strong> of \(E\) is denoted \(End(E)\). The structure of \(End(E)\) can be found in Chapter 3.9 of Silverman's book.</p>
<p>For an integer \(n\), we define \(E[n]=\{(x,y) \in E(K) | n*(x,y)=O\}\)</p>
<p>Over a field \(\mathbb{F}_p\), there are two types of curves: <strong>Ordinary</strong> and <strong>Supersingular</strong>, based on the set \(E[p]\). We are interested in studying Supersingular curves, since the isogeny graph on these curves has nice structure and properties. </p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="isogenies"><a class="header" href="#isogenies">Isogenies</a></h3>
<h4 id="definition-2"><a class="header" href="#definition-2">Definition</a></h4>
<p>[[<a href="isogeny-based-crypto/supersingular-isogeny-graph/background/../../../bibliography.html#Was08">Was08</a>], Chapter XII.1] Let \(E_1:y^2=x^3+a_1x+b_1\) and \(E_2:y^2=x^3+a_2x+b_2\) be elliptic curves over a field \(K\). An <strong>isogeny</strong> from \(E_1\) to \(E_2\) is a nonconstant homorphism \(\alpha:E_1 \rightarrow E_2\) that is given by rational functions such that \(\alpha(O)=O\). </p>
<p>This means \(\alpha(P+Q)=\alpha(P)+\alpha(Q)\) for all \(P,Q \in E_1\) and there exists rational functions \(P, Q\) such that if \(\alpha(x_1, y_1)=(P(x_1, y_1),Q(x_1, y_1))\).</p>
<p>In fact, it can be proved that we can write \(\alpha\) in the form \(\alpha(x_1, y_1)=(p(x_1), y_1q(x_1))\).</p>
<p>If \(p(x)=\dfrac{r(x)}{s(x)}\) for polynomials 
\(r\) and \(s\) without common roots, define the degree of \(\alpha\) to be \(Max(deg(r(x)),deg(s(x)))\). </p>
<p>We say an isogeny is <strong>seperable</strong> if \(s(x)\) have no repeated roots.</p>
<h4 id="example-2"><a class="header" href="#example-2">Example</a></h4>
<p>Consider two curves \(E_1:y^2=x^3+x\) and \(E_2:y^2=x^3-4x\) over \(\mathbb{F}_{11}\). Then the map
$$\alpha: E_1 \rightarrow E_2$$
$$(x,y) \mapsto \left(\dfrac{x^2+1}{x},\dfrac{y(x^2-1)}{x}\right)$$
is an isogeny from \(E_1\) to \(E_2\).</p>
<h4 id="properties-1"><a class="header" href="#properties-1">Properties</a></h4>
<p>We mention several important properties of isogenies.</p>
<ol>
<li>
<p>Isogenies are uniquely determined by their kernel: Given an elliptic curve \(E\) and a subgroup \(L\), there is an unique elliptic curve \(E'\) and an isogeny \(\alpha: E \rightarrow E'\) such that the kernel of \(\alpha\) is \(L\).</p>
</li>
<li>
<p>[[<a href="isogeny-based-crypto/supersingular-isogeny-graph/background/../../../bibliography.html#Sil09">Sil09</a>], Chapter III.6, Theorem 6.2] For every isogeny \(\alpha: E \rightarrow E'\) of degree \(l\), there exists an unique dual isogeny \(\hat{\alpha}: E' \rightarrow E\) such that \(\alpha \hat{\alpha}= \hat{\alpha} \alpha=l\)</p>
</li>
<li>
<p>[[Unknown bib ref: Gha21], Proposition 2.2] (<strong>Decomposition of isogenies</strong>)  Let \(\alpha: E \rightarrow E'\) be a seperable isogeny. Then there exists an integer \(k\) elliptic curves \(E=E_0, E_1,...,E_n=E'\) and isogenies \(\beta_i: E_i \rightarrow E_{i+1}\) of prime degree such that \(\alpha=\beta_{n-1} \beta_{n-2} ... \beta_{0} [k]\)</p>
</li>
</ol>
<p>The edges of Supersingular isogeny graphs are determined by isogenies between the curves, we will talk about it later in the definition of the graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="supersingular-elliptic-curves"><a class="header" href="#supersingular-elliptic-curves">Supersingular Elliptic Curves</a></h3>
<h4 id="definition-3"><a class="header" href="#definition-3">Definition</a></h4>
<p>Let \(p\) is a prime and let \(q\) be a power of \(p\). Let \(E\) be an elliptic curve over \(\mathbb{F}_q\). If \(E[p]=O\), then \(E\) is a <strong>Supersingular elliptic curve</strong>, if \(E[p]=\mathbb{Z}/p\mathbb{Z}\) then \(E\) is an <strong>Ordinary elliptic curve</strong>.</p>
<h4 id="example-3"><a class="header" href="#example-3">Example</a></h4>
<p>For \(p=3\), the curve \(E: y^2=x^3-x\) is supersingular over the field \(\bar{F}_3\). <a href="https://math.stackexchange.com/questions/3607389/find-all-points-order-3-on-an-elliptic-curve">Here</a> we see that \([3]*(x,y)=O\) for \((x,y) \neq O\) if and only if \(3x^4-6x^2-1=0\), but such \(x\) does not exist since \(\bar{F}_3\) has characteristic \(3\). Thus \(E[3]=O\)</p>
<h4 id="properties-2"><a class="header" href="#properties-2">Properties</a></h4>
<p><strong>Theorem</strong> [[<a href="isogeny-based-crypto/supersingular-isogeny-graph/background/../../../bibliography.html#Sil09">Sil09</a>], Chapter V.3, Theorem 3.1] These following conditions are equivalent:</p>
<ol>
<li>
<p>\(E[p^r]=0\) for all \(r \geq 1\).</p>
</li>
<li>
<p>\(End(E)\) is an order in a quaternion algebra.</p>
</li>
<li>
<p>The map \([p]: E \rightarrow E\) is purely inseperable and \(j(E) \in \mathbb{F}_{p^2}\).</p>
</li>
</ol>
<p>As we see, all Supersingular elliptic curves are isomorphic to a curve in \(F_{p^2}\), up to isomorphism, therefore the number of these curves are finite. It is natural that we want to count the number of these curves. Fortunately, we have a formula for the number of supersingular elliptic curves, as stated below:</p>
<p><strong>Theorem</strong>. [[<a href="isogeny-based-crypto/supersingular-isogeny-graph/background/../../../bibliography.html#Sil09">Sil09</a>], Chapter V.4, Theorem 4.1] The number of supersingular elliptic curves up to isomorphism is \(\left\lfloor \dfrac{p}{12} \right\rfloor+z\), where </p>
<ul>
<li>
<p>\(z=0\) if \(p \equiv 1 \pmod{ 12}\)</p>
</li>
<li>
<p>\(z=1\) if \(p \equiv 5,7 \pmod{ 12}\)</p>
</li>
<li>
<p>\(z=2\) if \(p \equiv 11 \pmod{ 12}\)</p>
</li>
</ul>
<p>In the next chapter, we introduce the graph where the vertices are the Supersingular elliptic curves (up to isomorphism). This graph has several interesting properties that make it a candidate for constructing post quantum cryptosystems.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="supersingular-isogeny-graphs-pizer-graphs"><a class="header" href="#supersingular-isogeny-graphs-pizer-graphs">Supersingular Isogeny Graphs (Pizer Graphs)</a></h3>
<h4 id="definition-4"><a class="header" href="#definition-4">Definition</a></h4>
<p>Let \(p\) be a prime number. For a prime \(l \neq p\), a <strong>Supersingluar isogeny graph</strong>  \(\mathcal{G} _l (\mathbb{F} _{p ^2})\) is a graph whose vertices are the j-invariants of supersingular elliptic curves in \(\mathbb{F} _{p ^2}\), and such that there is an edge from \(j(E _1)\) to \(j(E _2)\) if and only if there is an isogeny of degree \(l\) from \(E_1\) to \(E_2\). There can be multiple edges from \(j(E_1)\) to \(j(E_2)\), the number of such edges is equal to the number of isogenies from  \(j(E_1)\)  to \(j(E_2)\).</p>
<p>Since each vertex represents a supersingular elliptic curve, the number of vertices in \(\mathcal{G} _l (\mathbb{F} _{p ^2})\) is equal to \(\lfloor \frac{p}{12} \rfloor + \epsilon\), where \(\epsilon\) is defined in.</p>
<p>For these graph, we require \(p \equiv 1 \pmod{ 12} \) so that we can pair an isogeny with its dual to make the graph regular and undirected [Unknown bib ref: Gha21]. </p>
<h4 id="properties-3"><a class="header" href="#properties-3">Properties</a></h4>
<p>The reason why Supersingular Isogeny Graphs are important lies in the following theorems:</p>
<p><strong>Theorem</strong>. [[Unknown bib ref: CGL09], Theorem 4.1] For \(p \equiv 1 \pmod{ 12} \) and \(l \neq p\) , the graph \(\mathcal{G} _l(\mathbb{F} _{p^2})\) is connected, and is a \(l+1\) regular graph.</p>
<p><strong>Theorem</strong>. [[Unknown bib ref: CGL09], Theorem 4.2] For \(p \equiv 1 \pmod{ 12} \) and \(l \neq p\) the graph  \(\mathcal{G} _l(\mathbb{F} _{p^2})\) are Ramanujan graphs.</p>
<p>We give an overview about Ramanujan graphs. They are optimal expander graph. There are two nice properties of this type of graph. First, relatively short walk on this graph approximate the uniform distribution, which is good for a source of randomness. This can be seen by the following theorem:</p>
<p><strong>Theorem</strong>. Let \(N_{l,p}\) denote the number of vertices of \(\mathcal{G} _l(\mathbb{F} _{p ^2})\) .Fix a supersingular \(j_1 \in \mathbb{F} _{p^2}\), and let \(j_2\) be the endpoint of a walk of length \(e\) orginating at \(j_1\). Then for all \(j \in \mathbb{F} _{p^2}\):</p>
<p>$$|Pr[j=j_2]-N_{l,p}^{-1}| \leq \left(\dfrac{2\sqrt{l}}{l+1}\right)^e$$</p>
<p>The other nice property of Ramanujan graph is that the path-finding problem is assumed to be hard on this graph, which is good for constructing a cryptographic hash function. Two types of Ramanujan are proposed in [<a href="isogeny-based-crypto/supersingular-isogeny-graph/graph/../../../bibliography.html#CGL06">CGL06</a>], LPS Graph and Supersingular Isogeny Graphs. However, the LPS hash function was attacked and broken in 2008 [<a href="isogeny-based-crypto/supersingular-isogeny-graph/graph/../../../bibliography.html#TZ08">TZ08</a>] [<a href="isogeny-based-crypto/supersingular-isogeny-graph/graph/../../../bibliography.html#PLQ08">PLQ08</a>], leaving the Supersingular Isonegy Graph as the ruling graph. </p>
<p>The adjacency matrix of \(\mathcal{G} _l(\mathbb{F} _{p^2})\) is the Brandt matrix \(B(l)\). More informations of the matrix can be found in Voight's book. The matrix allow us to specify all primes \(p\) so that the graph does not have short cycles [Unknown bib ref: Gha21], an important property to ensure the hardness of the path-finding problem of the graph [<a href="isogeny-based-crypto/supersingular-isogeny-graph/graph/../../../bibliography.html#CGL06">CGL06</a>].</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="applications-of-pizer-graphs"><a class="header" href="#applications-of-pizer-graphs">Applications of Pizer Graphs</a></h3>
<p>Supersingular Isogeny Graph has applications in both mathematics and cryptography. We list several of their applications below.</p>
<ol>
<li>
<p><strong>In mathematics</strong> Supersingular Isogeny Graph is used in the following computational problems:</p>
<ol>
<li>The endomorphism ring computation problem: Given \(p\) and a
supersingular \(j\)-invariant \(j\), compute the endomorphism ring of \(E(j)\) [<a href="isogeny-based-crypto/supersingular-isogeny-graph/graph/../../../bibliography.html#EHLMP18">EHLMP18</a>].</li>
<li>The Deuring correspondence problem: Given a maximal order<br />
\(A \in B_{p,\inf}\), return a supersingular j-invariant such that the endomorphism ring \(E(j)\) is isomorphic to \(A\) [<a href="isogeny-based-crypto/supersingular-isogeny-graph/graph/../../../bibliography.html#EHLMP18">EHLMP18</a>].</li>
</ol>
</li>
<li>
<p><strong>In cryptography</strong> Supersingular Isogeny Graph is used in encryption scheme [<a href="isogeny-based-crypto/supersingular-isogeny-graph/graph/../../../bibliography.html#MOT20">MOT20</a>], signature scheme [Unknown bib ref: SKLPW20], hash function [<a href="isogeny-based-crypto/supersingular-isogeny-graph/graph/../../../bibliography.html#CGL06">CGL06</a>], verifiable delay function [Unknown bib ref: LMPS19]. These schemes are secure against the attack on SIKE.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kzg-polynomial-commitment-scheme"><a class="header" href="#kzg-polynomial-commitment-scheme">KZG Polynomial Commitment Scheme</a></h1>
<p>KZG polynomial commitment scheme [<a href="kzg-polynomial-commitment-scheme/../bibliography.html#KZG10">KZG10</a>] plays an important role in making the polynomial constraints of PlonK's arithmetization become a zkSNARK [<a href="kzg-polynomial-commitment-scheme/../bibliography.html#GWC19">GWC19</a>].</p>
<p>In this section, we provide the syntax and security requirements of a polynomial commitment scheme (PCS) in <a href="kzg-polynomial-commitment-scheme/./pcs_definition/section.html">Polynomial Commitment Scheme - Definition</a>. Then, we show some instantiations of the scheme by discussing its technical overview in <a href="kzg-polynomial-commitment-scheme/./technical_overview/section.html">Technical Overview</a>.</p>
<p><strong>Author(s):</strong> <a href="https://github.com/khaihanhtang">khaihanhtang</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polynomial-commitment-scheme---definition"><a class="header" href="#polynomial-commitment-scheme---definition">Polynomial Commitment Scheme - Definition</a></h1>
<p>In this section, we provide the definition of polynomial commitment scheme including syntax and security requirements. Syntax describes how the scheme works through algorithms while security requirements enforce the scheme to satisfy in order to make it secure.</p>
<p>Syntax is presented in <a href="kzg-polynomial-commitment-scheme/pcs-definition/syntax.html">Syntax</a> and security requirements are presented in <a href="kzg-polynomial-commitment-scheme/pcs-definition/security_requirement.html">Security Requirements</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h1>
<p>A polynomial commitment scheme, for polynomials over a field \(\mathbb{F}\), is a tuple of \(5\) algorithms
\[(\mathsf{Setup}, \mathsf{Commit}, \mathsf{VerifyPoly}, \mathsf{CreateWitness}, \mathsf{VerifyEval})\]
working as follows:</p>
<ul>
<li>\(\mathsf{Setup}(1^\kappa, t):\) On inputs security parameter \(1^\kappa\) and a degree bound \(t\), this algorithm returns a commitment key \(ck\). The key \(ck\) allows to commit any polynomial in \(\mathbb{F}[X]\) whose degree is at most \(t\).</li>
</ul>
<blockquote>
<p>Above we use the notation \(\mathbb{F}[X]\) to denote the field extension of \(\mathbb{F}\). For intuition, this field extension contains every polynomial of the form \(f(X) = \sum_{j = 0}^{\deg(f)} c_j \cdot X^j\) where \(\deg(f)\) is the degree of \(f(X)\) and \(c_j \in \mathbb{F}\) for all \(j \in \{0, \dots, \deg(f)\}\). Hence, with the algorithm \(\mathsf{Setup}\) on input \(t\), we can assume that it allows to commit to any polynomial \(f\) satisfying \(\deg(f) \leq t\). </p>
<p>We may have a question about what will happen if we try to use \(ck\) to commit to a polynomial whose degree is larger than \(t\). In this case, the execution and correctness of the algorithms below or the security of the scheme are not guaranteed.</p>
</blockquote>
<ul>
<li>
<p>\(\mathsf{Commit}\left(ck, f(X)\right):\) On inputs commitment key \(ck\) and polynomial \(f(X) \in \mathbb{F}[X]\), this algorithm returns a commitment \(c\) and an opening (or decommitment) \(d\). We note that \(f(X)\) here is recommended to have degree at most \(t\) with respect to \(ck\) output by \(\mathsf{Setup}(1^\kappa, t)\).</p>
</li>
<li>
<p>\(\mathsf{VerifyPoly}(ck, f(X), c, d):\) On inputs commitment key \(ck\), polynomial \(f(X) \in \mathbb{F}[X]\), commitment \(c\) and opening \(d\), this algorithm deterministically returns a bit \(b \in \{0, 1\}\) to specify whether \(c\) is a correct commitment to \(f(X)\). If \(c\) is such a correct commitment, then \(b = 1\). Otherwise, \(b = 0\).</p>
</li>
</ul>
<blockquote>
<p>At this moment, we may wonder why \(\mathsf{Commit}\) does output both \(c, d\) and \(\mathsf{VerifyPoly}\) does use both \(c, d\). In fact, when participating in an interactive protocol, one party may commit to some secret by exposing commitment \(c\) to other parties. This commitment \(c\) guarantees that the secret behind, namely, polynomial \(f(X)\) in this case, is still secret, guaranteed the hiding property to be discussed later. </p>
<p>On the other hand, since we abuse the word <strong>commit</strong>, it means that the party publishing \(c\) has only one opening, namely, \(d\), to show that \(c\) is a correct commitment to \(f(X)\). It is extremely hard for this party to show that \(c\) is correct commitment to some other polynomial \(f'(X) \not= f(X)\). This is guaranteed by the binding property of the polynomial commitment scheme, to be discussed later. </p>
</blockquote>
<ul>
<li>\(\mathsf{CreateWitness}(ck, f(X), i, d):\) On inputs commitment key \(ck\), polynomial \(f(X)\), index \(i\) and opening \(d\), this algorithm returns a witness \(w_i\) to ensure that \(c\), related to opening \(d\), is commitment to \(f(X)\) whose evaluation at index \(i\) is equal to \(f(i)\).</li>
</ul>
<blockquote>
<p>Let us explain in detail the use of \(\mathsf{CreateWitness}\). Assume that a party published \(c\) which is a commitment to \(f(X)\). It then publishes a point \((i, v)\) and claims that \(f(i) = v\) without exposing \(f(X)\). By using the algorithm \(\mathsf{VerifyEval}\) defined below, this claim is assured if \(f(i)\) is actually equal to \(v\). Moreover, for all other indices \(i' \) satisfying \(i' \not= i\), if \(f(i')\) has not been opened before, then \(f(i')\) is unknown to any party who does not know \(f(X)\).</p>
<p>We also remark that, from basic algebra, if we know evaluations at \(\deg(f) + 1\) distinct indices, we can recover the polynomial \(f(X)\). Therefore, the above claim assumes that other parties do not know up to \(\deg(f) + 1\) distinct evaluations.</p>
</blockquote>
<ul>
<li>\(\mathsf{VerifyEval}(ck, c, i, v, w_i):\) On inputs commitment key \(ck\), commitment \(c\), index \(i\), evaluation \(v\) and witness \(w_i\), this algorithm returns \(\{0, 1\}\) deciding whether \(c\) is a commitment key \(f(X)\) satisfying \(f(i) = v\).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-requirements"><a class="header" href="#security-requirements">Security Requirements</a></h1>
<p>In this section, we briefly discuss the security requirement for polynomial commitment schemes. </p>
<p>A polynomial commitment scheme is said to be secure if it satisfies the following properties:</p>
<ul>
<li>
<p><strong>Correctness.</strong> The correctness property says that if the scheme is executed honestly then the verification algorithms, namely, \(\mathsf{VerifyPoly}\) and \(\mathsf{VerifyEval}\), always returns \(1\). In particular, assume that \(ck \leftarrow \mathsf{Setup}(1^\kappa, t)\) and \((c, d) \leftarrow \mathsf{Commit}(ck, f(X))\). Then, \(\mathsf{VerifyPoly}(ck, f(X), c, d)\) always returns \(1\). And, for any \(w_i\) output by \(\mathsf{CreateWitness}(ck, f(i), i, d)\), algorithm \(\mathsf{VerifyEval}(ck, c, i, f(i), w_i)\) always returns \(1\).</p>
</li>
<li>
<p><strong>Polynomial Binding.</strong> For a given commitment key \(ck\) output by \(\mathsf{Setup}(1^\lambda, t)\), this property says that it is hard to output commitment \(c\) and two tuples \((f(X), d)\) and \((f'(X), d')\) such that \(f(X)\) and \(f'(X)\) are distinct and have degrees at most \(t\), and \(c\) is commitment to both \(f(X)\) and \(f'(X)\) with respect to openings \(d\) and \(d'\), respectively.  More precisely, it is hard to make \(\mathsf{VerifyPoly}(ck, f(X), c, d) = 1\) and \(\mathsf{VerifyPoly}(ck, f'(X), c, d') = 1\) if \(f(X) \not= f'(X)\), \(\deg(f) \leq t\) and \(\deg(f') \leq t\).</p>
</li>
<li>
<p><strong>Evaluation Binding.</strong> The evaluation binding property says that a committed polynomial evaluating on an index \(i\) cannot produce two different outcomes \(v\) and \(v'\). More precisely, an adversary cannot provide an index \(i\) and \(2\) tuples \((v, w_i)\) and \((v', w'_i)\) satisfying \(v \not= v'\) such that \(\mathsf{VerifyEval}(ck, c, i, v, w_i) = 1\) and \(\mathsf{VerifyEval}(ck, c, i, v', w'_i) = 1\).</p>
</li>
<li>
<p><strong>Hiding.</strong> An adversary \(\mathcal{A}\) who knows at most \(\deg(f)\) evaluations of a committed polynomial \(f(X)\) cannot determine any evaluation that it does not know before. </p>
</li>
</ul>
<blockquote>
<p>We remind that knowing \(\deg(f) + 1\) different evaluations helps to determine polynomial, and hence all other evaluations. Therefore, we use the bound \(\deg(f)\) here as a maxmimum number of evaluations that the adversary is allowed to know in order not to correctly obtain the evaluations of all other indices.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="technical-overview"><a class="header" href="#technical-overview">Technical Overview</a></h1>
<p>From the syntax of polynomial commitment scheme presented in <a href="kzg-polynomial-commitment-scheme/technical-overview/./../pcs_definition/syntax.html">Polynomial Commitment Scheme - Syntax</a>, a realization, or equivalently, a construction, can be separated into \(2\) components:</p>
<ul>
<li>Commiting polynomial includes the algorithms \(\mathsf{Commit}\) and \(\mathsf{VerifyPoly}\).</li>
<li>Evaluating polynomial includes the algorithms \(\mathsf{CreateWitness}\) and \(\mathsf{VerifyEval}\).</li>
</ul>
<p>Based on those components, we present the high level idea of \(2\) constructions, namely, conditional and unconditional, of polynomial commitment scheme separated into \(3\) little parts. The first and second parts, to be presented in <a href="kzg-polynomial-commitment-scheme/technical-overview/./commitment_without_hiding.html">Commitment to Polynomial Without Hiding Property</a> and <a href="kzg-polynomial-commitment-scheme/technical-overview/./correct_evaluation_from_commitment.html">Correct Evaluation from the Commitment</a>, respectively, focus on constructing the realization of conditional version. And, in the third part, to be presented in <a href="kzg-polynomial-commitment-scheme/technical-overview/./dealing_with_hiding.html">Dealing with Hiding</a>, regarding condition and unconditional hidings, we discuss the modification of conditional version to achieve the unconditional one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commitment-to-polynomial-without-hiding-property"><a class="header" href="#commitment-to-polynomial-without-hiding-property">Commitment to Polynomial Without Hiding Property</a></h1>
<p>In the construction of [<a href="kzg-polynomial-commitment-scheme/technical-overview/../../bibliography.html#KZG10">KZG10</a>], the main idea to commit a polynomial is to evaluate it on a secret index. For example, assume that \(f(X) = a_0 + a_1 X + \dots + a_d X^d \in \mathbb{F}[X]\). The secret index can be thought of as some value \(x\) that the committer does not know. So, how can committer evaluate \(f(x)\) on that secret index without any knowledge about it? In fact, cryptography can magically help you do that. For instance, by putting \(1, x, x^2, \dots, x^n \) into the form of powers to some base element \(g\), e.g., \(g^1, g^x, g^{x^2}, \dots, g^d\), it helps to hide those values \(1, x, x^2, \dots, x^d\). Moreover, it alows you to evaluate \(g^{f(x)}\) as desired by computing
$$ (g^1)^{a_0} \cdot (g^x)^{a_1} \cdot (g^{x^2})^{a_2} \cdot \dots \cdot (g^{x^d})^{a_d} = g^{a_0 + a_1x + \dots a_d x^d} = g^{f(x)}.$$
Thus, \(g^{f(x)}\) is computed without any knowledge about \(x\). Hence, that is whatever the committer needs to do in the commit step, namely, executing the algorithm \(\textsf{Commit}\) to output the commitment \(g^{f(x)}\). So the commitment key \(ck\) for this algorithm is the hidden indices wrapped under powers of \(g\), namely, the set sequence \((g^1, g^{x}, g^{x^2}, \dots, g^{x^d})\). And, therefore, \((g^1, g^{x}, g^{x^2}, \dots, g^{x^d})\) is also the output of the algorithm \(\textsf{Setup}\). At this point, we might think about a few things:</p>
<ol>
<li>How to verify the commitment \(c = g^{f(x)}\) by executing \(\textsf{VerifyPoly}\).</li>
<li>How to guarantee that the commitment satisfies the polynomial binding property.</li>
</ol>
<p>For the first question, to verify \(c\), the decommitment of the construction is \(f(X)\) itself. Committer simply send the entire polynomial \(f(X)\) to verifier, namely, by sending coefficients \(a_0, \dots, a_d\). Having the polynomial and the commitment key \(ck\), the verifier can check easily by repeating steps similar to the algorithm \(\textsf{Commit}\). </p>
<p>For the second question, to show the satisfaction of binding property, we can assume that the committer is able to break the binding property by introducing another polynomial \(f'(X) = a'_0 + a'_1X + \dots + a'_dX^d\) where \(f'(X) \not= f(X)\). So we have \(g^{f(x)} = c = g^{f'(x)}\).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="correct-evaluation-from-the-commitment"><a class="header" href="#correct-evaluation-from-the-commitment">Correct Evaluation from the Commitment</a></h1>
<blockquote>
<p><strong>Warning.</strong> This part explains by the use of algebra. You may skip if you feel it is complicated.</p>
</blockquote>
<p>For an index \(i\) given to the committer, since committer knows \(f(X)\), he can compute \(f(i)\) definitely. The \(\mathsf{CreateWitness}\) algorithm is constructed based on the fact that \(X - i\) divides \(f(X) - f(i)\). At this point, there is something difficult to realize here since it regards to the use of algebra. However, we know that \(f(i)\) is the output of \(f(X)\) on input \(i\). Therefore, we see that \(i\) is among the roots of \(g(X) = f(X) - f(i)\), i.e., \(g(i) = 0\) which says that \(i\) is a root of \(g(X)\). Therefore, \(X - i\) divides \(f(X) - f(i)\). Hence, to guarantee the evaluation binding property, committer needs to show that \(f(X) - f(i)\) is divisible by \(X - i\).</p>
<blockquote>
<p><strong>Example.</strong> Consider polynomial \(f(X) = 6X^3 + 25X^2 + 16X + 19\) in \( \mathbb{Z}_{31}\). Let \(i = 28\). Then, \(f(28) = 151779 = 3\) in \( \mathbb{Z} _{31} \). Hence, \(X - 28 = X + 3\) divides \(f(X) - 3\). In fact, 
$$ f(X) - 3 = 6X^3 + 25X^2 + 16X + 16 = (3X + 5)(2X + 30)(X + 3)\text{ in } \mathbb{Z} _{31}.$$
It is obvious that \(X + 3\) is a factor of \(f(X) - 3\).</p>
</blockquote>
<p>Equivalently, we can say that \(v = f(i)\) if and only if \(X - i\) divides \(f(X) - f(i)\).</p>
<p>To show such divisibility holds, we can compute \(\psi(X) = \frac{f(X) - v_i}{X - i}\), where \(v_i\) is assumed to be \(f(i)\), and define witness \(w_i = g^{\psi(x)}\) by using \(g^1, g^x, \dots, g^{x^d}\) output by the algorithm \(\textsf{Setup}\). </p>
<p>At this point, for the verifier to verify, committer needs to show that \(\psi(x) \cdot (x - i) + v_i = f(x)\). Let's closely take a look at this formula. We observe the followings:</p>
<ol>
<li>No one knows \(x\). Hence, \(\psi(x)\) is not known to anyone. </li>
<li>Committer and verifier know \(g^{\psi(x)}\) which is equal to the commitment \(c\). Moreover, they also know \(g^x, g^i, g^{v_i}\) since \(g^x\) belongs to commitment key \(ck\), \(i\) is public and \(v_i\) is publicly claimed by committer.</li>
<li>Verifier can easily compute \(g^{x - i} = g^x / g^i\).</li>
</ol>
<p>Clearly, having \(g^{\psi(x)},g^{x - i}, g^{v_i}\) and \(g^{f(x)}\), we do not know any efficient way to compute \(g^{\psi(x)\cdot (x - i) + v_i}\) since computing \(g^{\psi(x)\cdot (x-i)}\) is hard due to Diffie-Hellman assumption.</p>
<h2 id="using-bilinear-pairing-to-handle-correct-multiplications"><a class="header" href="#using-bilinear-pairing-to-handle-correct-multiplications">Using Bilinear Pairing to Handle Correct Multiplications</a></h2>
<blockquote>
<p>Recall the bilinear pairing \(e : \mathbb{G}\times \mathbb{G} \to \mathbb{G}_T\) where \(\mathbb{G}\) and \(\mathbb{G}_T\) are some groups of the same cardinality. This bilinear pairing has \(2\) properties: bilinearity and non-degeneracy. However, to avoid confusion, we only care about the bilinearity and temporarily skip the notice to non-degeneracy. </p>
<ul>
<li><strong>Bilinearity.</strong>  For \(g \in \mathbb{G}\) and \(g_T \in \mathbb{G}_T\), \(e(g^a, g^b) = e(g, g)^{ab}\) for any \(a, b \in \mathbb{Z}_p\) where \(p=|\mathbb{G}|\).</li>
</ul>
</blockquote>
<p>The validity of the witness can be check easily by using pairing, namely, $$e(w_i, g^x / g^i)\cdot e(g,g)^{v_i} \stackrel{?}{=}e(c, g),$$ where \(c\) is the commitment to \(f(X)\).
If the above identity holds, with non-negligible probability, it says that \(v_i = f(i)\).</p>
<p>To show identity implies \(v_i = f(i)\) with non-negligible probability, we consider \(w_i = g^{\psi(x)} = g^{\frac{f(x) - v_i}{x - i}}\). Hence, 
$$
\begin{align}
e(w_i, g^x / g^i)\cdot e(g, g)^{v_i} &amp;= e\left(g^{\frac{f(x) - v_i}{x - i}}, g^x / g^i\right)\cdot e(g, g)^{v_i}\\
&amp;= e(g, g)^{f(x) - v_i}\cdot e(g, g)^{v_i} = e(g^{f(x)}, g) = e(c, g).
\end{align}
$$</p>
<p>Notice that, if the person providing \(w_i\) and \(v_i\) does not know \(f(X)\), then we have the following possibilities:</p>
<ul>
<li>This person correctly guesses \(w_i\) and \(v_i\). This happens with negligible probability if we assumes that field cardinality, namely, number of elements in field \(\mathbb{F}\), is large.</li>
<li>The person incorrectly provides \(w_i\) and \(v_i\). Specificially, either \(v_i\) is not equal to \(f(i)\) or \(w_i\) is incorrect. Assume that \(w_i = g^{h_i}\). This case happens when \(x\) is the root of \(h_i\cdot (X - i) \cdot v_i = f(X)\). By Schwartz–Zippel lemma, this case also happens with negligible probability if the field cardinality is large and that person does not know \(x\), as \(x\) at the beginning was assumed to be hidden index.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dealing-with-hiding"><a class="header" href="#dealing-with-hiding">Dealing with Hiding</a></h1>
<p>In the previous sections, namely, <a href="kzg-polynomial-commitment-scheme/technical-overview/./commitment_without_hiding.html">Commitment to Polynomial Without Hiding Property</a> and <a href="kzg-polynomial-commitment-scheme/technical-overview/./correct_evaluation_from_commitment.html">Correct Evaluation from the Commitment</a>, we discussed the high level idea of the construction of algorithms as well as the polynomial and evaluation binding properties. One remaining thing is the hiding property. In [<a href="kzg-polynomial-commitment-scheme/technical-overview/../../bibliography.html#KZG10">KZG10</a>], the authors proposed \(2\) constructions from discrete logarithm assumption, for conditional hiding, and Pedersen commitment, for unconditional hiding.</p>
<blockquote>
<p><strong>Remark.</strong> We now make clear the \(2\) notions here, namely, conditional hiding and unconditional hiding.</p>
<p>Conditional hiding of a commitment \(c\) to a polynomial \(f(X)\) is the property protecting the polynomial \(f(X)\) from being compromised with a condition that some assumption employed is assumed to be hard. Usually, the hardness of the assumption is against probabilistic polynomial-time adversaries. Here, probabilistic polynomial-time adversaries stand for the machines that attack the scheme with limited amount of time, and this amount of time is upper-bounded by a polynomial on input the security parameter given to the scheme. Probabilistic polynomial time is a notion in the theory of computation. If you would like to know more about the detail, we prefer to check some textbooks. For example, we prefer [<a href="kzg-polynomial-commitment-scheme/technical-overview/../../bibliography.html#Sipser2012-introduction-to-theory-of-computation">Sipser2012-introduction-to-theory-of-computation</a>] in this blog.</p>
<p>On the other hand, unconditional hiding means that we cannot extract any information about the polynomial behind. For example, if \(f(X) = a_0 + a_1X + \dots + a_dX^d\) and \(r(X) = r_0 + r_1X + \dots + r_dX^d\), given that \(r_0, \dots, r_d\) are independently and uniformly sampled from \(\mathbb{F}\), then \(f(X) + r(X) = (a_0 + r_0) + (a_1 + r_1)X + \dots + (a_d + r_d)X^d\) completely hides \(f(X)\) since \(a_0 + r_0, a_1 + r_1, \dots, a_d + r_d\) are uniform in \(\mathbb{F}\).</p>
</blockquote>
<h2 id="conditional-hiding-from-discrete-logarithm-assumption"><a class="header" href="#conditional-hiding-from-discrete-logarithm-assumption">Conditional hiding from discrete logarithm assumption</a></h2>
<p>The former, namely, discrete logarithm assumption, guarantees the hiding by its own hardness assumption. In particular, given \(g\) and \(g^v\) for some secret integer \(v\), there is no way to extract any piece of information about \(v\) from \(g\) and \(g^v\) due to hardness of discrete logarithm problem. Therefore, the hiding here is conditional, i.e., discrete logarithm assumption is hard. </p>
<h2 id="unconditional-hiding-from-pedersen-commitment"><a class="header" href="#unconditional-hiding-from-pedersen-commitment">Unconditional hiding from Pedersen commitment</a></h2>
<p>The latter, namely, using Pedersen commitment, exploits the use of an additional part to achieve unconditional hiding property, which is secure against powerful adversaries and not limited to PPT ones. Roughly speaking, the external part can be informally thought of as a commitment to a random polynomial with conditional hiding. To perform this, we extend the commitment key \(ck\) to contain additional elements \(h^1, h^x, \dots, h^{x^d}\) where \(h\) is another generator of \(\mathbb{G}\) different from \(g\). Hence, the commitment key \(ck\) now is the tuple \((g^1, \dots, g^{x^d}, h^1, \dots, h^{x^d})\). Therefore, whenever committing to a polynomial \(f(X) = a_0 + a_1X + \dots + a_dX^d\), we additionally sample a polynomial \(r(X) = r_0 + r_1X + \dots + r_dX^d\in \mathbb{F}[X]\). The sampling process can be conducted easily by sampling each \(r_i\) uniformly and independently from \(\mathbb{Z}_{|F|} = \{0, \dots, |F| - 1\}\).</p>
<p>The algorithm \(\textsf{Commit}\) now can be evaluated by computing
$$
c = \prod_{i = 0}^d (g^{x^i})^{a_i} \cdot \prod_{i = 0}^d (h^{x^i})^{r_i} = g^{f(x)}\cdot h^{r(x)},
$$
namely, the original conditional-hiding commitment to \(f(X)\) multiplying with the condition-hiding commitment to random polynomial \(r(X)\) becomes an unconditional commitment \(c\) where auxiliary information \(\textsf{aux}\) can be set to be the tuple \((f(X), r(X))\). Hence, now, the adversary knows nothing about the evaluations of any index in \(\mathbb{F}\). We can see clearly that the commitment \(c\) hides \(f(X)\) unconditionally since \(r_0\) is chosen uniformly from \(\mathbb{Z}_{|\mathbb{F}|}\) and, hence, \((h^{x^0})^{r_0}\) is uniform in \(\mathbb{F}\). It also implies that \(c\) is uniform in \(\mathbb{F}\).</p>
<p>Since \(c = g^{f(x)}\cdot h^{r(x)}\), we can say that \(c\) is the multiplication of two parts, namely, the message part \(g^{f(x)}\) and the randomness part \(h^{r(x)}\).</p>
<p>We now discuss how algorithms \(\textsf{CreateWitness}\) and \(\textsf{VerifyEval}\) work with respect to introductory of the additional part, namely, \(h^{r(x)}\). </p>
<!-- Then, we discuss the unconditional hiding once at most \\(d\\) evaluations of \\(f(X)\\) with respective witnesses are known. -->
<h3 id="creating-witness-in-unconditional-hiding-mode"><a class="header" href="#creating-witness-in-unconditional-hiding-mode">Creating witness in unconditional hiding mode</a></h3>
<p>For a given index \(i\), the witness output by algorithm \(\textsf{CreateWitness}\) is also a multiplication of \(2\) parts. We simply call the message evaluation and randomness evaluation parts. </p>
<p>The message evaluation part is computed identically to the conditional version of the commitment scheme. That is, we compute the formula \(g^{\psi(x)}\) where \(\psi(X) = \frac{f(X) - f(i)}{X - i}\).</p>
<p>The randomness evaluation part is also conducted similarly. Notice that, since we employ \(r(X)\) as a polynomial of degree \(d\), we can compute witness for the correct evaluation on the same index \(i\), namely, \(r(i)\). This randomness evaluation part is equal to \(h^{\varphi(x)}\) where \(\varphi(X) = \frac{r(X) - r(i)}{X - i}\).</p>
<blockquote>
<p><strong>Remark.</strong> As previously said, \(x\) is unknown to committer. Therefore, the computation of \(g^{\psi(x)}\) and \(h^{\varphi(x)}\) must depend on the commitment key \(ck\) by employing the elements \(g^1, \dots, g^{x^{d - 1}}, h^1, \dots, h^{x^{d - 1}}\). Notice that we do not you \(g^{x^d}\) and \(h^{x^d}\) since \(\psi(X)\) and \(\varphi(X)\) are polynomials of degrees at most \(d - 1\).</p>
</blockquote>
<p>The output of algorithm \(\textsf{CreateWitness}\) is then equal to \(w_i = (w^\star_i, s_i)\) where \(w^\star_i = g^{\psi(x)} \cdot h^{\varphi(x)}\) is the multiplication of message evaluation and randomness evaluation parts and \(s_i = r(i)\). Notice that \(r(i)\) is attached to witness in order to help the evaluation verification algorithm, to be described below, work.</p>
<h3 id="verifying-correct-evaluation-in-unconditional-mode"><a class="header" href="#verifying-correct-evaluation-in-unconditional-mode">Verifying correct evaluation in unconditional mode</a></h3>
<p>The evaluation verification algorithm \(\textsf{VerifyEval}\) receives as inputs the commitment key \(ck = (g^1, \dots, g^{x^d}, h^1, \dots, h^{x^d})\), commitment \(c\) to \(f(X)\), index \(i\), value \(v_i \in \mathbb{F}\) assumed to be equal to \(f(i)\) and \(w_i = (w^\star_i, s_i)\). This algorithm is expected to return \(1\) is \(v_i\) is equal to \(f(i)\) with the use of associated witness \(w_i\).</p>
<p>To verify whether \(v_i = f(i)\), it is worth to verify both correct computations of \(f(i)\) and \(r(i)\). More precisely, verifier needs to confirm that \(v_i = f(i)\) and \(s_i = r(i)\). To this end, again, we imitate the verification process of the conditional hiding case. Hence, we employ again bilinear pairing \(e : \mathbb{G}\times \mathbb{G} \to \mathbb{G}_T\) which maps \((g^a, g^b)\) to \(e(g, g)^{ab}\). However, there is an obstacle here. Observe that, in this pairing, we use only \(1\) generator \(g\) while our commitment employs \(2\) different generators \(g\) and \(h\) both generating \(G\). In order to enable the bilinear pairing, we enforce \(h = g^\gamma\) for some hidden \(\gamma\). This enforcement works because \(g\) is the generator of \(\mathbb{G}\) and \(h\) belongs to \(\mathbb{G}\). Hence, our commitment \(c\) can be alternatively written as 
$$
c = g^{f(x)}\cdot h^{r(x)} = g^{f(x)}\cdot g^{\gamma \cdot r(x)} = g^{f(x) + \gamma\cdot r(x)}
$$
which is a conditional commitment to \(f(X) + \gamma\cdot r(X)\) with \(\gamma\) unknown to both committer and verifier.</p>
<p>Moreover, the witness \(w^\star_i = g^{\psi(x)}\cdot h^{\varphi(x)}\) can also be interpreted as 
$$
w^\star_i = g^{\psi(x)}\cdot h^{\varphi(x)}=g^{\psi(x)} \cdot g^{\gamma\cdot \varphi(x)} = g^{\psi(x) + \gamma\cdot \varphi(x)}
$$ 
which is also a witness for correct evaluation at index \(i\) with respect to polynomial \(f(X) + \gamma\cdot r(X)\) whose \(\gamma\) is not known to both parties, namely, committer and verifier.</p>
<p>We now observe that \(\psi(X) + \gamma\cdot \varphi(X) = \frac{f(X) - f(i)}{X - i} + \gamma\cdot \frac{r(X) - r(i)}{X - i}\). Hence, it is worth to guarantee the following equation holds:
$$
\left(\frac{f(X) - f(i)}{X - i} + \gamma\cdot \frac{r(X) - r(i)}{X - i}\right)\cdot\left(X - i\right) - (f(i) + \gamma\cdot r(i)) = f(X) + \gamma \cdot r(X).
$$</p>
<p>We now describe the process for verifying the above equation by employing the bilinear pairing function \(g : \mathbb{G}\times \mathbb{G} \to \mathbb{G}_T\). Since the above equation has a multiplication, we apply the bilinear pairing by checking 
$$
e\left(g^{\frac{f(x) - v_i}{x - i} + \gamma\cdot \frac{r(x) - s_i}{x - i}}, g^{x - i}\right)\cdot e\left(g^{-\left(v_i + \gamma\cdot s_i\right)}, g\right) = e\left(g^{f(x) + \gamma\cdot r(x)},g\right)
$$
where \(x\) and \(\gamma\) are unknown to both parties. Since \(x\) and \(\gamma\) are not known to both parties, it is inconvenient to evaluate the bilinear pairing function. However, since \(ck = (g^1, \dots, g^{x^d}, h^1, \dots, h^{x^d})\) and \(h = g^\gamma\) are public inputs, we can replace the appearances of \(x\) and \(\gamma\) in the above equation by those of \(ck\) and \(h\). The above computation of bilinear pairing hence becomes
$$
e\left(w^\star, g^x / g^i\right)\cdot e\left(g^{-v_i}\cdot h^{-s_i}, g\right) = e(c, g)
$$
since \(c = g^{f(x)}\cdot h^{r(x)} = g^{f(x) + \gamma\cdot r(x)}\).</p>
<!-- ### Unconditional hiding once at most \\(d\\) evaluations are known -->
<!-- We now assume that the committer allows the adversary to know \\(d\\) different evaluations on \\(f(X)\\), i.e., the evaluations are
$$ \\{(i_1, f(i_1), w_1), \dots, (i_d, f(i_d), w_d)\\}$$
where, for each \\(j \in \\{1, \dots, d\\}\\), \\(\textsf{VerifyEval}(ck, c, i_j, f(i_j), w_j) = 1\\) and \\(w_j = (w_j^\star, s_j)\\).

As we discussed previously, if we know at least \\(d + 1\\) evaluations of \\(f(X)\\) of distinct indices, we can recover \\(f(X)\\) entirely, e.g., by using Lagrange interpolation. On the other hand, knowing evaluations of at most \\(d\\) different indices is insufficient for predicting evaluations of other indices. The unrevealed evaluation of any index, other than those \\(d\\) different indices, would look uniform in \\(\mathbb{F}\\). Hence, since adversary knows at \\(d + 1\\) evaluations of \\(f(X)\\) and the corresponding witnesses \\(w_1, \dots, w_d\\), adversary also knows \\(d + 1\\) different evaluations of \\(r(X)\\). Assume that \\(i_{d + 1} \not\in \\{i_1, \dots, i_d\\}\\). We argue that \\(f(i_{d + 1})\\) and \\(r(i_{d + 1})\\) are unknown to adversary. In fact, assume that there exist \\(f'(X) \not= f(X)\\) and \\(r'(X) \not= r(X)\\) satisfying
$$
    f'(i_j) = f(i_j) = v_j \text{ and } r'(i_j) = r(i_j) = s_j 
$$
for all \\(j \in \\{1, \dots, d\\}\\). Roughly speaking, \\(f'(X)\\) is different from \\(f(X)\\) yet shares the same evaluations at those queried indices, namely, \\(i_1, \dots, i_d\\). A similar explanation applies to \\(r'(X)\\) and \\(r(X)\\). Hence, we argue that \\(w_1, \dots, w_d\\) are the same both pairs \\((f(X), r(X))\\) and \\((f'(X), r'(X))\\) for \\(x\\) fixed in advance. In fact, for any \\(j \in \\{1, \dots, d\\}\\), let's consider the equation described above, with \\(X\\) and \\(i\\) replaced by \\(x\\) and \\(i_j\\), respectively, 
$$
    \left(\frac{f(x) - f(i_j)}{x - i_j} + \gamma\cdot \frac{r(x) - r(i_j)}{x - i_j}\right)\cdot\left(x - i_j\right) - (f(i_j) + \gamma\cdot r(i_j)) = f(x) + \gamma \cdot r(x).
$$
We see clearly that \\(\frac{f(x) - f(i_j)}{x - i_j} + \gamma\cdot \frac{r(x) - r(i_j)}{x - i_j}\\) is uniquely determined by computing 
$$\begin{align}
\frac{f(x) + \gamma\cdot r(x) + f(i_j) + \gamma\cdot r(i_j)}{x - i_j} \&= \frac{f(x) - \gamma\cdot r(x) + v_j + \gamma\cdot s_j}{x - i_j}\\\\
\&= \frac{f'(x) + \gamma\cdot r'(x) + f(i_j) + \gamma\cdot r(i_j)}{x - i_j}
\end{align}$$<span style="color:red">continue here</span> --><div style="break-before: page; page-break-before: always;"></div><h1 id="plonk"><a class="header" href="#plonk">PlonK</a></h1>
<p>In this chapter, we will present the construction of [<a href="plonk/../bibliography.html#GWC19">GWC19</a>], i.e., permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge.</p>
<p>PlonK is a succinct non-interactive zero-knowledge argument (SNARK) system that proves the correct execution of a program, i.e., in this case, an arithmetic circuit with only addition \((+)\) and multiplication \((\cdot)\) operations.</p>
<p>As an overview of the construction, we separate it into \(2\) parts. First, we transform the arithmetic circuit into a set of constraints, called arithmetization and represented under some form of polynomials. Then, by applying some proof technique, it compiles the arithmetization into the proof.</p>
<p><strong>Author(s):</strong> <a href="https://github.com/khaihanhtang">khaihanhtang</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plonks-arithmetization"><a class="header" href="#plonks-arithmetization">Plonk's Arithmetization</a></h1>
<p>PlonK's arithmetization [<a href="plonk/arithmetization/../../bibliography.html#GWC19">GWC19</a>] breaks the circuit into a batch of gates, namely, multiplications, additions, multiplications with constants and additions with constants. For each gate, the operation is transformed into a unified form with respective selectors, uniquely determined by the gate without assigned inputs and output. On the other hand, since breaking circuit into gates introduces the inconsistencies among wires, we additionally apply copy constraints to wires to guarantee that such inconsistencies unavailable.</p>
<p>We describe circuit specification in <a href="plonk/arithmetization/./circuit_specification.html">Circuit Specification</a>. Then, we discuss how to break the circuit into gates and label wires in <a href="plonk/arithmetization/./breaking_circuit.html">Breaking Circuit</a>. Then we present unified form of gate constraints in <a href="plonk/arithmetization/./gate_constraints.html">Gate Constraints</a> and handling copy constraints in <a href="plonk/arithmetization/./copy_constraints.html">Copy Constraints</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit-specification"><a class="header" href="#circuit-specification">Circuit Specification</a></h1>
<p>Let \(\mathbb{F}\) be a finite field. In this section, we describe the arithmetic circuit whose operations are over \(\mathbb{F}\). </p>
<p>Let \(\ell_{\mathsf{in}} \in \mathbb{N}\) be the number of input wires of the circuit \(\mathcal{C}\). Assume that \(\mathcal{C}\) has exactly \(n\) gates. Each gate takes at most \(2\) wires as inputs and returns \(1\) output wires. In particular,</p>
<ul>
<li>Addition and multiplications gates takes \(2\) inputs and return \(1\) output.</li>
<li>Gates of additions and multiplications with constants take \(1\) input and return \(1\) output.</li>
</ul>
<p>Let's take a look at the following example.</p>
<blockquote>
<p>Assume that \(f(u, v) = u^2 + 3uv + v + 5\). Then the sequence are arranged in the following constraints, wrapped as below.
$$
\begin{cases}
z_1 = u \cdot u &amp;\text{(multiplication)},\\
z_2 = u \cdot v &amp;\text{(multiplication)},\\
z_3 = z_2 \cdot 3 &amp;\text{(multiplication with constant)},\\
z_4 = z_1 + z_3 &amp;\text{(addition)},\\
z_5 = z_4 + v &amp;\text{(addition)},\\
z_6 = z_5 + 5 &amp;\text{(addition with constant)}.
\end{cases}
$$
The input size is \(\ell_{\mathsf{in}} = 2\) for variables \(u, v\) and the output is \(z_6\).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="breaking-circuit"><a class="header" href="#breaking-circuit">Breaking Circuit</a></h1>
<p>To break the circuit into gates with wires separated, namely, no wire involves to \(2\) or more gates, we use a set of labels \(\mathcal{I} = \{a_1, \dots, a_n, b_1, \dots, b_n, c_1, \dots, c_n\}\) to denote the wire label of each gate. Let \(x : \mathcal{I} \to \mathbb{F}\) be the function mapping wires to their respective wire values. Hence, \(x(id)\) represents the value at wire \(id \in \mathcal{I}\) For simplicity, we write \(x_{id}\), in place of \(x(id)\), for any \(id \in \mathcal{I}\).</p>
<p>Specifically, for each \(i \in \{1, \dots, n\}\), we denote by</p>
<ul>
<li>\(x_{c_i} = x_{a_i}\circ x_{b_i}\) to denote the computation where \(\circ\) is either addition or multiplication.</li>
<li>\(x_{c_i} = x_{a_i}\circ c\) to denote the computation where \(\circ\) is either addition or multiplication with constant and \(c\) is the constant.</li>
</ul>
<blockquote>
<p>At this point, we may be curious what value \(x_{b_i}\) takes if \(\circ\) is operation with constant. In fact, in this case x_{b_i} can be seen as garbage and can take any value from \(\mathbb{F}\). This value will affect neither security nor correctness of the system since the constraints in PlonK's arithmetization guarantee that such a compromise will not happen.</p>
</blockquote>
<p>Let's take a look at the following example, taken from <a href="plonk/arithmetization/./subsection_circuit_specification.html">Circuit Specification</a>. </p>
<blockquote>
<p>We have \(f(u, v) = u^2 + 3uv + v + 5\) and the constraints below.
$$
\begin{cases}
z_1 = u \cdot u &amp;\text{(multiplication)},\\
z_2 = u \cdot v &amp;\text{(multiplication)},\\
z_3 = z_2 \cdot 3 &amp;\text{(multiplication with constant)},\\
z_4 = z_1 + z_3 &amp;\text{(addition)},\\
z_5 = z_4 + v &amp;\text{(addition)},\\
z_6 = z_5 + 5 &amp;\text{(addition with constant)}.
\end{cases}
$$
By breaking circuit, we have the following constraints with respect to the above format, namely, using \(\mathcal{I} = \{a_1, \dots, a_6, b_1, \dots, b_6, c_1, \dots, c_6\}\), where \(n = 6\), and \(x : \mathcal{I}\to \mathbb{F}\).
$$
\begin{cases}
x_{c_1} = x_{a_1} \cdot x_{b_1},\\
x_{c_2} = x_{a_2} \cdot x_{b_2},\\
x_{c_3} = x_{a_3} \cdot 3,\\
x_{c_4} = x_{a_4} + x_{b_4},\\
x_{c_5} = x_{a_5} + x_{b_5}, \\
x_{c_6} = x_{a_6} + 5
\end{cases}\text{ where }
\begin{cases}
u = x_{a_1} = x_{a_2} = x_{b_1},\\
v = x_{b_2} = x_{b_5},\\
z_1 = x_{a_4} = x_{c_1},\\
z_2 = x_{a_3} = x_{c_2},\\
z_3 = x_{b_4} = x_{c_3},\\
z_4 = x_{a_5} = x_{c_4},\\
z_5 = x_{a_6} = x_{c_5},\\
z_6 = x_{c_6}.\<br />
\end{cases}
$$
Notice that \(v_{b_3}\) and \(v_{b_6}\) are dismissed. These values can be any elements from \mathbb{F} and do not have any effect to the arithmetization.</p>
</blockquote>
<p>For equations in the system guaranteeing the correct computation of the operation, we call them <em>gate constraints</em>.</p>
<p>For equations in the system guaranteeing the equalities, or consistencies, among wires, we call them <em>copy constraints</em>.</p>
<p>We first discuss the transformation of gate constraints into a common unified form with publicly determined selectors in <a href="plonk/arithmetization/./subsection_gate_constraints.html">Gate Constraints</a>. Then, we discuss the method for guaranteeing copy constraints in <a href="plonk/arithmetization/./subsection_copy_constraints.html">Copy Constraints</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gate-constraints"><a class="header" href="#gate-constraints">Gate constraints</a></h1>
<p>At this stage, for each \(i \in \{1,\dots, n\}\), we need to transform the computation of each gate to a unified form as follows:
$$q^O_i \cdot x_{c_i} + q^L_i \cdot x_{a_i} + q^R_i \cdot x_{b_i} + q^M_i \cdot (x_{a_i} \cdot x_{b_i}) + q^C_i = 0$$
where \(q_i^O, q_i^L, q_i^R, q_i^M, q_i^C\) are selectors uniquely determined by the corresponding gate. In particular,</p>
<ul>
<li>
<p>For addition gate, \((q_i^O, q_i^L, q_i^R, q_i^M, q_i^C) = (-1, 1, 1, 0, 0)\) since \((-1) \cdot x_{c_i} + 1 \cdot x_{a_i} + 1 \cdot x_{b_i} + 0 \cdot (x_{a_i} \cdot x_{b_i}) + 0 = 0\) is equivalent to \(x_{c_i} = x_{a_i} + x_{b_i}\).</p>
</li>
<li>
<p>For multiplication gate, \((q_i^O, q_i^L, q_i^R, q_i^M, q_i^C) = (-1, 0, 0, 1, 0)\) since \((-1) \cdot x_{c_i} + 0 \cdot x_{a_i} + 0 \cdot x_{b_i} + 1 \cdot (x_{a_i} \cdot x_{b_i}) + 0 = 0\) is equivalent to \(x_{c_i} = x_{a_i} \cdot x_{b_i}\).</p>
</li>
<li>
<p>For gate of addition with constant, \((q_i^O, q_i^L, q_i^R, q_i^M, q_i^C) = (-1, 1, 0, 0, c)\) since \((-1) \cdot x_{c_i} + 1 \cdot x_{a_i} + 0 \cdot x_{b_i} + 0 \cdot (x_{a_i} \cdot x_{b_i}) + c = 0\) is equivalent to \(x_{c_i} = x_{a_i} + c\).</p>
</li>
<li>
<p>For gate of multiplication with constant, \((q_i^O, q_i^L, q_i^R, q_i^M, q_i^C) = (-1, c, 0, 0, 0)\) since \((-1) \cdot x_{c_i} + c \cdot x_{a_i} + 0 \cdot x_{b_i} + 0 \cdot (x_{a_i} \cdot x_{b_i}) + 0 = 0\) is equivalent to \(x_{c_i} = x_{a_i} \cdot c\).</p>
</li>
</ul>
<blockquote>
<p>We now take a look at the example achieved above, i.e.,
$$
\begin{cases}
x_{c_1} = x_{a_1} \cdot x_{b_1},\\
x_{c_2} = x_{a_2} \cdot x_{b_2},\\
x_{c_3} = x_{a_3} \cdot 3,\\
x_{c_4} = x_{a_4} + x_{b_4},\\
x_{c_5} = x_{a_5} + x_{b_5}, \\
x_{c_6} = x_{a_6} + 5.
\end{cases}
$$ In this example, we can transform the above system of equation into the unified form as follows:
$$ 
\begin{cases}
(-1) \cdot x_{c_1} + 0 \cdot x_{a_1} + 0 \cdot x_{b_1} + 1 \cdot (x_{a_1} \cdot x_{b_1}) + 0 = 0,\\
(-1) \cdot x_{c_2} + 0 \cdot x_{a_2} + 0 \cdot x_{b_2} + 1 \cdot (x_{a_2} \cdot x_{b_2}) + 0 = 0,\\
(-1) \cdot x_{c_3} + 3 \cdot x_{a_3} + 0 \cdot x_{b_3} + 0 \cdot (x_{a_3} \cdot x_{b_3}) + 0 = 0,\\
(-1) \cdot x_{c_4} + 1 \cdot x_{a_4} + 1 \cdot x_{b_4} + 0 \cdot (x_{a_4} \cdot x_{b_4}) + 0 = 0,\\
(-1) \cdot x_{c_5} + 1 \cdot x_{a_5} + 1 \cdot x_{b_5} + 0 \cdot (x_{a_5} \cdot x_{b_5}) + 0 = 0,\\
(-1) \cdot x_{c_6} + 1 \cdot x_{a_6} + 0 \cdot x_{b_6} + 0 \cdot (x_{a_6} \cdot x_{b_6}) + 5 = 0.
\end{cases}
$$</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-constraints"><a class="header" href="#copy-constraints">Copy Constraints</a></h1>
<p>Recall that gate constraints do not enforce the equalities of wire values making inconsistencies across the circuit. We generalize copy constraints to the following problem.</p>
<p>Let \(k \in \{1, \dots, 3n\}\) and \(\{i_1, \dots, i_k\} \subseteq \mathcal{I}\) satisfying \(i_1 &lt; i_2 &lt; \dots &lt; i_k\). We would like to show that
$$
x_{i_1} = x_{i_2} = \dots = x_{i_k}.
$$</p>
<p>The technique for proving this problem is tricky. We form the pairs of index-value and make them into a sequence 
$$
\big((i_1, x_{i_1}), (i_2, x_{i_2}), \dots, (i_k, x_{i_k})\big).
$$
It can be observed that if \(x_{i_1} = x_{i_2} = \dots = x_{i_k}\), then, if we rotate the indices among the pairs, we achieve a sequence<br />
$$
\big((i_k, x_{i_1}), (i_1, x_{i_2}), \dots, (i_{k - 1}, x_{i_k})\big)
$$
that is permutation of the previous sequence. Notice that we just rotated the indices \(1\) step to the left and this is the recommended rotation. This fact helps imply the other direction of the fact. For more details, we use the following observation</p>
<p><strong>Observation.</strong> \(\big((i_1, x_{i_1}), (i_2, x_{i_2}), \dots, (i_k, x_{i_k})\big)\) is a permutation of \(\big((i_k, x_{i_1}), (i_1, x_{i_2}), \dots, (i_{k - 1}, x_{i_k})\big)\) if and only if \(x_{i_1} = x_{i_2} = \dots = x_{i_k}\).</p>
<p><em>Proof.</em> The proof is as follows:</p>
<p>&quot;\(\Leftarrow\)&quot;: This direction is straightforward.</p>
<p>&quot;\(\Rightarrow\)&quot;: Since the two sequences are permutation of each other, for \(j \in \{1, \dots, k\}\) we consider \((i_j, x_{i_j})\) from the first sequence. It can be seen that \((i_j, x_{i_{(j \mod k) + 1}})\) from the second sequence is the only one that is equal \(j \in \{1, \dots, k\}\) since they share the unique prefix \(i_j\). Hence, \(x_{i_j} = x_{i_{(j \mod k) + 1}}\). Following this argument, we see that \(x_{i_1} = x_{i_2}, x_{i_2} = x_{i_3}, \dots, x_{i_{k - 1}} = x_{i_k}, x_{i_k} = x_{i_1}\). Thus, \(x_{i_1} = x_{i_2} = \dots = x_{i_k}\).</p>
<h4 id="general-paradigm-for-proving-copy-constraints-of-the-entire-circuit"><a class="header" href="#general-paradigm-for-proving-copy-constraints-of-the-entire-circuit">General paradigm for proving copy constraints of the entire circuit</a></h4>
<p>Recall that \(x : \mathcal{I} \to \mathbb{F}\). We can deterministically determine a partition of \(\mathcal{I}\) such that 
$$
\mathcal{I} = \bigcup_{j = 1}^{\ell_{\mathsf{in}} + n} \mathcal{I}_j
$$ </p>
<p>where \(\ell_{\mathsf{in}} + n\) is the number of wires of the original circuits, namely, \(\ell_{\mathsf{in}}\) input wires and \(n\) output wires of all gates. Hence each subset \(\mathcal{I}_j\) is the set of wire labels whose value are all equal to the same wire value of the original circuit. We hence obtain a rotation of indices for each subset \(\mathcal{I}_j\). By unifying all those rotations, we achieve a permutation \(\sigma : \mathcal{I}\to\mathcal{I}\) such that</p>
<p>$$
\big((a_1, x_{a_1}), \dots, (a_n, x_{a_n}), (b_1, x_{b_1}), \dots, (b_n, x_{b_n}), (c_1, x_{c_1}), \dots, (c_n, x_{c_n})\big)
$$</p>
<p>is a permutation of</p>
<p>$$
\big((\sigma(a_1), x_{a_1}), \dots, (\sigma(a_n), x_{a_n}), (\sigma(b_1), x_{b_1}), \dots, (\sigma(b_n), x_{b_n}), (\sigma(c_1), x_{c_1}), \dots, (\sigma(c_n), x_{c_n})\big).
$$
Such guaranteed permutation relation implies the consistencies among wires of the circuit.</p>
<blockquote>
<p>Recall the example in <a href="plonk/arithmetization/./subsection_breaking_circuit.html">Breaking Circuit</a> with the following copy constraints.
$$
\begin{cases}
u = x_{a_1} = x_{a_2} = x_{b_1},\\
v = x_{b_2} = x_{b_5},\\
z_1 = x_{a_4} = x_{c_1},\\
z_2 = x_{a_3} = x_{c_2},\\
z_3 = x_{b_4} = x_{c_3},\\
z_4 = x_{a_5} = x_{c_4},\\
z_5 = x_{a_6} = x_{c_5},\\
z_6 = x_{c_6}.\<br />
\end{cases}
$$
We achieve the partition
$$
\big\{\{a_1, a_2, b_1\}, \{b_2, b_5\}, \{a_4, c_1\}, \{a_3, c_2\}, \{b_4, c_3\}, \{a_5, c_4\}, \{a_6, c_5\}, \{c_6\}\big\}.
$$
We hence can achive the permutation \(\sigma: \mathcal{I}\to\mathcal{I}\) as follows:
$$
\begin{array}[ccc]\\
\sigma(a_1) = b_1, &amp;\sigma(a_2) = a_1, &amp;\sigma(b_1) = a_2,\\
\sigma(b_2) = b_5, &amp;\sigma(b_5) = b_2,\\
\sigma(a_4) = c_1, &amp;\sigma(c_1) = a_4,\\
\sigma(a_3) = c_2, &amp;\sigma(c_2) = a_3,\\
\sigma(b_4) = c_3, &amp;\sigma(c_3) = b_4,\\
\sigma(a_5) = c_4, &amp;\sigma(c_4) = a_5,\\
\sigma(a_6) = c_5, &amp;\sigma(c_5) = a_6,\\
\sigma(c_6) = c_6.
\end{array}
$$</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="halo-2-for-dummies"><a class="header" href="#halo-2-for-dummies">Halo 2 for Dummies</a></h1>
<p><a href="https://zcash.github.io/halo2/">Halo 2</a> is succint non-interactive zero-knowledge argument of knowledge (zkSNARK) library for developing applications with an associated zkSNARK in order to prove their honesty in computing the programs. In this chapter, I present a simple implementation of a program, under the form of a \(2\)-variable polynomial, by using Halo 2.</p>
<p><strong>Author(s):</strong> <a href="https://github.com/khaihanhtang">khaihanhtang</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plonkish-arithemetization"><a class="header" href="#plonkish-arithemetization">PLONKish Arithemetization</a></h1>
<p>We recommend readers who are not familiar with PlonK's arithmetization to read the article <a href="halo2-for-dummies/plonkish/./../../plonk/arithmetization/section.html">PlonK's Arithmetization</a>. In this chapter, we further discuss a more customized version of PlonK's arithmetization, namely, <a href="https://zcash.github.io/halo2/">PLONKish arithmetization</a>. Customization aims to handle more general gates with more complicated structures rather than employing only multiplication, addition, multiplication with constants and addition with constants gates. </p>
<p>PLONKish arithmetization can be pictured as a table of the following types of columns:</p>
<ul>
<li>Constant columns for putting constants,</li>
<li>Instant columns for putting public inputs,</li>
<li>Advice columns for putting private inputs, literally known as witnesses,</li>
<li>Selector columns for putting selectors.</li>
</ul>
<p>For simplicity, in this section, we present a transformation from a program, represented by an arithmetic circuit, to the form of PLONKish arithmetization. This transformation can be showed by an example that proves the knowledge of a \(2\)-variable polynomial specified in <a href="halo2-for-dummies/plonkish/./simple_arithmetic_circuit.html">A Simple Arithmetic Circuit</a>. Then, we explain the method for transforming this polynomial to the form of PLONKish arithmetization in <a href="halo2-for-dummies/plonkish/./transforming_to_plonkish_arithmetization.html">Transforming to PLONKish Arithmetization</a> and programming in <a href="halo2-for-dummies/plonkish/./../simple_example/section.html">A Simple Halo 2 Program</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-arithmetic-circuit"><a class="header" href="#a-simple-arithmetic-circuit">A Simple Arithmetic Circuit</a></h1>
<p>Let \(\mathbb{F}\) be some finite field. We would like to show in this section the transformation from the program computing polynomial \(f(u, v) = u^2 + 3uv + v + 5 \) where \(u, v \in \mathbb{F}\). With inputs \(u, v \in \mathbb{F}\), the arithmetic circuit for this polynomial is equivalently represented by topologically following the sequence of computations below.</p>
<ol>
<li>Compute \(u^2\).</li>
<li>Compute \(uv\).</li>
<li>Compute \(3uv\).</li>
<li>Compute \(u^2 + 3uv\).</li>
<li>Compute \(u^2 + 3uv + v\).</li>
<li>Compute \(u^2 + 3uv + v + 5\).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transforming-to-plonkish-arithmetization"><a class="header" href="#transforming-to-plonkish-arithmetization">Transforming to PLONKish Arithmetization</a></h1>
<p>To setup the above sequence of computations, in <a href="halo2-for-dummies/plonkish/./simple_arithmetic_circuit.html">A Simple Arithmetic Circuit</a>, into PLONKish arithmetization, we specify a table to contain all possible variables appeared during the computing the arithmetic circuit for \(f(u,v) = u^2 + 3uv + v + 5\). Then, for each row, we setup a the set gates, or equivalently gate constraints, that applies to the row. </p>
<h2 id="specifying-columns"><a class="header" href="#specifying-columns">Specifying columns</a></h2>
<p>We define the following tuple of columns
$$
(\mathsf{advice} _0, \mathsf{advice} _1, \mathsf{advice} _2, \mathsf{constant}, \mathsf{selector} _{\mathsf{add}}, \mathsf{selector} _{\mathsf{mul}}, \mathsf{selector} _{\mathsf{addc}}, \mathsf{selector} _{\mathsf{mulc}})
$$
where</p>
<ul>
<li>\(\mathsf{advice}_0, \mathsf{advice}_1, \mathsf{advice}_2\) are columns containing private inputs, i.e., values belonging to these columns are hidden to any verifier,</li>
<li>\(\mathsf{constant}\) is the column containing public constants appearing during the computation,</li>
<li>\(\mathsf{selector} _{\mathsf{add}}, \mathsf{selector} _{\mathsf{mul}}, \mathsf{selector} _{\mathsf{addc}}, \mathsf{selector} _{\mathsf{mulc}}\) contain public selectors corresponding to addition, multiplication, addition with constant, multiplication with constant, respectively, gates.</li>
</ul>
<h2 id="transforming-to-constraints-and-meaning-of-columns"><a class="header" href="#transforming-to-constraints-and-meaning-of-columns">Transforming to Constraints and Meaning of Columns</a></h2>
<p>We now explain the intuition to the above setting of columns. To do this, we need to transform the sequence of computations in <a href="halo2-for-dummies/plonkish/./simple_arithmetic_circuit.html">A Simple Arithmetic Circuit</a> into \(2\) parts, namely, gate constraints (or gate identities) and wire constraints (or wire identities). In particular, we transform
$$
\begin{align}<br />
t^{(1)} &amp;= u^2,  &amp;t^{(3)} &amp;= t^{(2)} \cdot 3 = 3uv, &amp; t^{(5)} &amp;= t^{(4)} + v = u^2 + 3uv + v,\\
t^{(2)} &amp;= u v, &amp; t^{(4)} &amp;= t^{(1)} + t^{(3)} = u^2 + 3uv, &amp;t^{(6)} &amp;= t^{(5)} + 5 = u^2 + 3uv + v + 5
\end{align}
$$
to gate constraints</p>
<p>$$
\begin{align}
x ^{(1)} _{c} &amp;= x ^{(1)} _{a} \cdot x ^{(1)} _{b},  &amp; x ^{(3)} _{c} &amp;= x ^{(3)} _{a} \cdot 3,         &amp; x ^{(5)} _{c} &amp;= x ^{(5)} _{a} + x ^{(5)} _{b},\\
x ^{(2)} _{c} &amp;= x ^{(2)} _{a} \cdot  x ^{(2)} _{b}, &amp; x ^{(4)} _{c} &amp;= x ^{(4)} _{a} + x ^{(4)} _{b}, &amp; x ^{(6)} _{c} &amp;= x ^{(6)} _{a} + 5
\end{align}
$$</p>
<p>and wire constraints</p>
<p>$$
\begin{align}
u &amp;= x_{a}^{(1)} = x_{a}^{(2)} = x_{b}^{(1)}, &amp;t^{(1)} &amp;= x_{a}^{(4)} = x_{c}^{(1)}, &amp;t^{(3)} &amp;= x_{b}^{(4)} = x_{c}^{(3)}, &amp;t^{(5)} &amp;= x_{a}^{(6)} = x_{c}^{(5)},\\
v &amp;= x_{b}^{(2)} = x_{b}^{(5)}, &amp;t^{(2)} &amp;= x_{a}^{(3)} = x_{c}^{(2)}, &amp;t^{(4)} &amp;= x_{a}^{(5)} = x_{c}^{(4)}, &amp;t^{(6)} &amp;= x_{c}^{(6)}.
\end{align}
$$</p>
<p>We note that \(x_b^{(3)}, x_b^{(6)}\) are not set. To deal with these values, we simple set them to be equal to any random vales, since they do not affect the constraints defined above.</p>
<p>Notice that each equation in gate constrains receives either \(2\) secret inputs or \(1\) secret input and \(1\) constant and returns \(1\) secret output. Therefore, we use \(2\) columns, namely, \(\mathsf{advice}_0\) and \(\mathsf{advice}_1\), to contain the secret inputs and \(1\) column, namely, \(\mathsf{advice}_2\), to contain the secret output. Moreover, we also use the column \(\mathsf{constant}\) to contain possible public constants.</p>
<p>The remaining columns, namely, \(\mathsf{selector} _{\mathsf{add}}, \mathsf{selector} _{\mathsf{mul}}, \mathsf{selector} _{\mathsf{addc}}, \mathsf{selector} _{\mathsf{mulc}}\), are employed to contain the selectors indicating the required constraints for each row, which corresponds to a constraint in the set of gate constraints specified above. We now clarify the employment of selectors to guarantee the correctness of gate constraints.</p>
<h2 id="specifying-table-values-and-gate-constraints"><a class="header" href="#specifying-table-values-and-gate-constraints">Specifying Table Values and Gate Constraints</a></h2>
<p>For each row \(i \in \{1, \dots,  6\}\) of the table, we denote by the tuple 
$$
(x_{a}^{(i)}, x_{b}^{(i)}, x_{c}^{(i)}, c^{(i)}, s_{\mathsf{add}}^{(i)}, s_{\mathsf{mul}}^{(i)}, s_{\mathsf{addc}}^{(i)}, s_{\mathsf{mulc}}^{(i)})
$$
corresponding to the tuple of columns 
$$
(\mathsf{advice} _0, \mathsf{advice} _1, \mathsf{advice} _2, \mathsf{constant}, \mathsf{selector} _{\mathsf{add}}, \mathsf{selector} _{\mathsf{mul}}, \mathsf{selector} _{\mathsf{addc}}, \mathsf{selector} _{\mathsf{mulc}})
$$
devised above.</p>
<p>For each row \(i \in \{1,\dots, 6\}\), we set the following \(4\) constraints
$$
\begin{align}
s_\mathsf{add}^{(i)}\cdot (x_{a}^{(i)} + x_{b}^{(i)} - x_{c}^{(i)}) &amp;= 0, &amp; s_\mathsf{mul}^{(i)}\cdot (x_{a}^{(i)} \cdot x_{b}^{(i)} - x_{c}^{(i)}) &amp;= 0,\\
s_\mathsf{addc}^{(i)}\cdot (x_{a}^{(i)} + c^{(i)} - x_{c}^{(i)}) &amp;= 0, &amp; s_\mathsf{mulc}^{(i)}\cdot (x_{a}^{(i)} \cdot c^{(i)} - x_{c}^{(i)}) &amp;= 0.
\end{align}
$$</p>
<blockquote>
<p><strong>Example.</strong> Assume that the \(i\)-th row corresponds to a multiplication gate. Hence, in this case, we set \((s_{\mathsf{add}}^{(i)}, s_{\mathsf{mul}}^{(i)}, s_{\mathsf{addc}}^{(i)}, s_{\mathsf{mulc}}^{(i)}) = (0, 1, 0, 0)\). We can see that only \(s_{\mathsf{mul}}^{(i)} = 1\) while remaining selectors are set to \(0\). </p>
<p>Therefore, whatever the values \(x_{a}^{(i)}, x_{b}^{(i)}, x_{c}^{(i)}, c^{(i)}\) are set, the results always hold with respect to the gates \(s_\mathsf{add}^{(i)}\cdot (x_{a}^{(i)} + x_{b}^{(i)} - x_{c}^{(i)}) = 0, s_\mathsf{addc}^{(i)}\cdot (x_{a}^{(i)} + c^{(i)} - x_{c}^{(i)}) = 0\) and \(s_\mathsf{mulc}^{(i)}\cdot (x_{a}^{(i)} \cdot c^{(i)} - x_{c}^{(i)}) = 0\). </p>
<p>However, since \(s_{\mathsf{mul}}^{(i)} = 1\), we can see that the gate \(s_\mathsf{mul}^{(i)}\cdot (x_{a}^{(i)} \cdot x_{b}^{(i)} - x_{c}^{(i)}) = 0\) must guarantee \(x_{a}^{(i)} \cdot x_{b}^{(i)} = x_{c}^{(i)}\).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-halo-2-program"><a class="header" href="#a-simple-halo-2-program">A Simple Halo 2 Program</a></h1>
<p>Based on the specifications in <a href="halo2-for-dummies/simple-example/./../plonkish/transforming_to_plonkish_arithmetization.html">Transforming to PLONKish Arithmetization</a>, we now show an implementation in Rust for proving knowledge of input of \(f(u, v) = u^2 + 3uv + v + 5\) mentioned in <a href="halo2-for-dummies/simple-example/./../plonkish/simple_arithmetic_circuit.html">A Simple Arithmetic Circuit</a>. The implementation can be found in <a href="https://github.com/khaihanhtang/example-halo2-pse">Example of Halo2-PSE</a>.</p>
<p>The following are a recommended for setting up a Rust implementation for Halo 2. </p>
<p>In <a href="https://github.com/khaihanhtang/example-halo2-pse/blob/main/Cargo.toml">Cargo.toml</a>, specify the dependency</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
halo2_proofs = { git = &quot;https://github.com/privacy-scaling-explorations/halo2.git&quot; }
<span class="boring">}</span></code></pre></pre>
<p>In <a href="https://github.com/khaihanhtang/example-halo2-pse/blob/main/src/main.rs">main.rs</a>, we implement step-by-step as follows:</p>
<ol>
<li>Specify columns by putting all possible columns into a custom <code>struct MyConfig</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug)]
struct MyConfig {
    advice: [Column&lt;Advice&gt;; 3],
    instance: Column&lt;Instance&gt;,
    constant: Column&lt;Fixed&gt;,

    // selectors
    s_add: Selector,
    s_mul: Selector,
    s_add_c: Selector,
    s_mul_c: Selector,
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Define gates based on elements of the above defined <code>struct</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Field: FieldExt&gt; FChip&lt;Field&gt; {
    fn configure(
        meta: &amp;mut ConstraintSystem&lt;Field&gt;,
        advice: [Column&lt;Advice&gt;; 3],
        instance: Column&lt;Instance&gt;,
        constant: Column&lt;Fixed&gt;,
    ) -&gt; &lt;Self as Chip&lt;Field&gt;&gt;::Config {
        // specify columns used for proving copy constraints
        meta.enable_equality(instance);
        meta.enable_constant(constant);
        for column in &amp;advice {
            meta.enable_equality(*column);
        }

        // extract columns with respect to selectors
        let s_add = meta.selector();
        let s_mul = meta.selector();
        let s_add_c = meta.selector();
        let s_mul_c = meta.selector();

        // define addition gate
        meta.create_gate(&quot;add&quot;, |meta| {
            let s_add = meta.query_selector(s_add);
            let lhs = meta.query_advice(advice[0], Rotation::cur());
            let rhs = meta.query_advice(advice[1], Rotation::cur());
            let out = meta.query_advice(advice[2], Rotation::cur());
            vec![s_add * (lhs + rhs - out)]
        });

        // define multiplication gate
        meta.create_gate(&quot;mul&quot;, |meta| {
            let s_mul = meta.query_selector(s_mul);
            let lhs = meta.query_advice(advice[0], Rotation::cur());
            let rhs = meta.query_advice(advice[1], Rotation::cur());
            let out = meta.query_advice(advice[2], Rotation::cur());
            vec![s_mul * (lhs * rhs - out)]
        });

        // define addition with constant gate
        meta.create_gate(&quot;add with constant&quot;, |meta| {
            let s_add_c = meta.query_selector(s_add_c);
            let lhs = meta.query_advice(advice[0], Rotation::cur());
            let fixed = meta.query_fixed(constant, Rotation::cur());
            let out = meta.query_advice(advice[2], Rotation::cur());
            vec![s_add_c * (lhs + fixed - out)]
        });

        // define multiplication with constant gate
        meta.create_gate(&quot;mul with constant&quot;, |meta| {
            let s_mul_c = meta.query_selector(s_mul_c);
            let lhs = meta.query_advice(advice[0], Rotation::cur());
            let fixed = meta.query_fixed(constant, Rotation::cur());
            let out = meta.query_advice(advice[2], Rotation::cur());
            vec![s_mul_c * (lhs * fixed - out)]
        });

        MyConfig {
            advice,
            instance,
            constant,
            s_add,
            s_mul,
            s_add_c,
            s_mul_c,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>Put values to the table and define wire constraints.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Field: FieldExt&gt; Circuit&lt;Field&gt; for MyCircuit&lt;Field&gt; {
    type Config = MyConfig;
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&amp;self) -&gt; Self {
        Self::default()
    }

    fn configure(meta: &amp;mut ConstraintSystem&lt;Field&gt;) -&gt; Self::Config {
        let advice = [meta.advice_column(), meta.advice_column(), meta.advice_column()];
        let instance = meta.instance_column();
        let constant = meta.fixed_column();
        FChip::configure(meta, advice, instance, constant)
    }

    fn synthesize(
        &amp;self, config: Self::Config, mut layouter: impl Layouter&lt;Field&gt;
    ) -&gt; Result&lt;(), Error&gt; {
        // handling multiplication region
        let t1 = self.u * self.u;
        let t2 = self.u * self.v;
        let t3 = t2 * Value::known(Field::from(3));

        // define multiplication region
        let (
            (x_a1, x_b1, x_c1),
            (x_a2, x_b2, x_c2),
            (x_a3, x_c3)
        ) = layouter.assign_region(
            || &quot;multiplication region&quot;,
            |mut region| {
                // first row
                config.s_mul.enable(&amp;mut region, 0)?;
                let x_a1 = region.assign_advice(|| &quot;x_a1&quot;,
                    config.advice[0].clone(), 0, || self.u)?;
                let x_b1 = region.assign_advice(|| &quot;x_b1&quot;,
                    config.advice[1].clone(), 0, || self.u)?;
                let x_c1 = region.assign_advice(|| &quot;x_c1&quot;,
                    config.advice[2].clone(), 0, || t1)?;

                // second row
                config.s_mul.enable(&amp;mut region, 1)?;
                let x_a2 = region.assign_advice(|| &quot;x_a2&quot;,
                    config.advice[0].clone(), 1, || self.u)?;
                let x_b2 = region.assign_advice(|| &quot;x_b2&quot;,
                    config.advice[1].clone(), 1, || self.v)?;
                let x_c2 = region.assign_advice(|| &quot;x_c2&quot;,
                    config.advice[2].clone(), 1, || t2)?;

                // third row
                config.s_mul_c.enable(&amp;mut region, 2)?;
                let x_a3 = region.assign_advice(|| &quot;x_a3&quot;,
                    config.advice[0].clone(), 2, || t2)?;
                region.assign_fixed(|| &quot;constant 3&quot;,
                    config.constant.clone(), 2, || Value::known(Field::from(3)))?;
                let x_c3 = region.assign_advice(|| &quot;x_c3&quot;,
                    config.advice[2].clone(), 2, || t3)?;

                Ok((
                    (x_a1.cell(), x_b1.cell(), x_c1.cell()),
                    (x_a2.cell(), x_b2.cell(), x_c2.cell()),
                    (x_a3.cell(), x_c3.cell())
                ))
            }
        )?;

        let t4 = t1 + t3;
        let t5 = t4 + self.v;
        let t6 = t5 + Value::known(Field::from(5));

        // define addition region
        let (
            (x_a4, x_b4, x_c4),
            (x_a5, x_b5, x_c5),
            (x_a6, x_c6)
        ) = layouter.assign_region(
            || &quot;addition region&quot;,
            |mut region| {
                // first row
                config.s_add.enable(&amp;mut region, 0)?;
                let x_a4 = region.assign_advice(|| &quot;x_a4&quot;,
                    config.advice[0].clone(), 0, || t1)?;
                let x_b4 = region.assign_advice(|| &quot;x_b4&quot;,
                    config.advice[1].clone(), 0, || t3)?;
                let x_c4 = region.assign_advice(|| &quot;x_c4&quot;,
                    config.advice[2].clone(), 0, || t4)?;

                // second row
                config.s_add.enable(&amp;mut region, 1)?;
                let x_a5 = region.assign_advice(|| &quot;x_a5&quot;,
                    config.advice[0].clone(), 1, || t4)?;
                let x_b5 = region.assign_advice(|| &quot;x_b5&quot;,
                    config.advice[1].clone(), 1, || self.v)?;
                let x_c5 = region.assign_advice(|| &quot;x_c5&quot;,
                    config.advice[2].clone(), 1, || t5)?;

                // third row
                config.s_add_c.enable(&amp;mut region, 2)?;
                let x_a6 = region.assign_advice(|| &quot;x_a6&quot;,
                    config.advice[0].clone(), 2, || t5)?;
                region.assign_fixed(|| &quot;constant 5&quot;,
                    config.constant.clone(), 2, || Value::known(Field::from(5)))?;
                let x_c6 = region.assign_advice(|| &quot;x_c6&quot;,
                    config.advice[2].clone(), 2, || t6)?;
                Ok((
                    (x_a4.cell(), x_b4.cell(), x_c4.cell()),
                    (x_a5.cell(), x_b5.cell(), x_c5.cell()),
                    (x_a6.cell(), x_c6.cell())
                ))
            }
        )?;

        // t6 is result, assign instance
        layouter.constrain_instance(x_c6, config.instance, 0)?;

        // enforce copy constraints
        layouter.assign_region(|| &quot;equality&quot;,
            |mut region| {
                region.constrain_equal(x_a1, x_a2)?; // namely, x_a1 = x_a2
                region.constrain_equal(x_a2, x_b1)?; // namely, x_a2 = x_b1

                region.constrain_equal(x_b2, x_b5)?; // namely, x_b2 = x_b5

                region.constrain_equal(x_a4, x_c1)?; // namely, x_a4 = x_c1

                region.constrain_equal(x_a3, x_c2)?; // namely, x_a3 = x_c2

                region.constrain_equal(x_b4, x_c3)?; // namely, x_b4 = x_c3

                region.constrain_equal(x_a5, x_c4)?; // namely, x_a5 = x_c4

                region.constrain_equal(x_a6, x_c5)?; // namely, x_a6 = x_c5
                Ok(())
            }
        )?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verifiable-delay-function-vdf"><a class="header" href="#verifiable-delay-function-vdf">Verifiable Delay Function (VDF)</a></h1>
<p>Verifiable Delay Functions (VDF) was introduced in 2018 and has become an active research aera in cryptography. VDF has many applications in blockchains, such as randomness beacon, resource-efficient blockchain, computational timestamping, etc. In this chapter, we first give a brief overview of VDF, then study and discuss several existing VDF constructions.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h3>
<p>Verifiable Delay Functions (VDF) were introducted by Boneh et al [<a href="verifiable-delay-functions/vdf-summary/../../bibliography.html#BBBF18">BBBF18</a>] in 2018. Informally, a VDF is a funtion that requires a specified number of step to compute its output, even with a large number of parallel processor, but the correctness of the output can be <strong>quickly</strong> verified.
While there can be many functions that require a specified of step to compute its output, not all of them are qualified to become VDFs. For example, consider the function \(f(X)=\mathsf{SHA256}^t(X)=\mathsf{SHA256}(\mathsf{SHA256}(...(\mathsf{SHA256}(X))...))\). Calculating \(f(X)\) require \(t\) iterations, even on a parallel computer. However, verification would also require \(t\) iterations, thus the function \(f(X)\), while VDF verification time must be within \(O(poly(\log t))\).
VDFs has found it application in many aspects [<a href="verifiable-delay-functions/vdf-summary/../../bibliography.html#BBBF18">BBBF18</a>]. We will highlight some of them later in the <strong>Application</strong> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="vdf-algorithms"><a class="header" href="#vdf-algorithms">VDF Algorithms</a></h3>
<p>A VDF consists of three algorithms \( (\mathsf{Gen}, \mathsf{Eval}, \mathsf{Verify})\) where:</p>
<p><strong>\((ek,vk) \leftarrow \mathsf{Gen}(1^{\lambda},t)\):</strong> This algorithm takes as input as a security parameter \( \lambda \), and outputs a public key pair \( (ek,vk)\).</p>
<p><strong>\( (Y,\pi) \leftarrow \mathsf{Eval}(X,ek,t)\):</strong> This algorithm takes an input an evaluation key \(sk\), a value \(X\) a time parameter \(t\) and outputs a value \(Y \in \{0,1\}^{out(\lambda)} \) and a proof \( \pi \).</p>
<p><strong>\( b \leftarrow \mathsf{Verify}(vk,X,Y,\pi,t)\):</strong> This algorithm takes an input a verification key \(vk \), a value \(X\), a value \(Y\), a proof \(\pi\), a time parameter \(t\) and outputs a bit \(b\) that determines whether \(Y=\mathsf{Eval}(X,ek)\). This algorithm run within time \(O(poly(\log t))\).</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="properties-4"><a class="header" href="#properties-4">Properties</a></h3>
<p>We require a VDF to have the following security properties:</p>
<p><strong>Correctness:</strong> For all parameter \(x\),\(t\) and \((ek,vk) \leftarrow \mathsf{Gen}(1^{\lambda})\) if \((Y,\pi)=Eval(ek,X,t)\) then \(Verify(vk,X,Y,\pi,t)=1\)</p>
<p><strong>Soundness:</strong> A VDF is sound if every algorithms \(A\) can solve the following problem with negligible probability in \(\lambda\): Given \(ev,vk\) output \(X,Y,\pi\) such that \((Y,\pi) \neq Eval(ek,X,t)\) and \(Verify(vk,X,Y,\pi,t)=1\).</p>
<p><strong>Sequentiality:</strong> A VDF is \(t-\)sequentiality if for all algorithms \(A\) with at most \(O(\mathsf{poly}(t))\) parallel processors and runs within time \(O(\mathsf{poly}(t))\), the experiment \(ExpSeq*{VDF}^{A}(1^\lambda)\) is negilible in \(\lambda\), where \(ExpSeq*{VDF}^{A}(1^\lambda)\) is described as follows:</p>
<p>\(ExpSeq_{VDF}^{A}(1^\lambda)\):</p>
<ul>
<li>\((ek,vk) \leftarrow \mathsf{Gen}(1^{\lambda})\)</li>
<li>\(X {\stackrel{$}{\leftarrow}} \{0,1\}^{in(\lambda)}\)</li>
<li>\((Y,\pi) \leftarrow A(X,ek,vk)\)</li>
<li>Return \((Y,\pi)==\mathsf{Eval}(X,ek,t)\)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="applications-1"><a class="header" href="#applications-1">Applications</a></h3>
<p>We present several applications of VDF below:</p>
<p><strong>Randomness Beacon</strong>:
To see the application of VDF in randomness beacons, we take a look at two examples below:
In proof of work blockchains, miners find solutions to computational puzzles and then submits them for monetary rewards. However, there can be more than one solution, and a miner may submit the one that benefits him the most, or refuse to submit if it does not benefit him. Using VDF, then given the deterministic nature of VDF, a miner cannot choose any output other than the VDF output for his goal.
Another example is the the RANDAO [<a href="verifiable-delay-functions/vdf-summary/../../bibliography.html#Ra17">Ra17</a>] that use &quot;commit-and-reveal&quot; paradigm. In RANDAO, each participant \(P_i\) submit the commitment of a random value \(s_i\), after each participants reveal \(s_i\) and the final output is defined to be \(s=\oplus_{i=1}^ns_i.\). The problem is that the last participant may not submit his value if the final output does not benefit him. One approach to solve this problem is to use VDF. After all \(s_i\)s are revealed, the value \(H(s_1,s_2,...,s_n)\) is used as the seed of the VDF and the beacon output is the VDF output [<a href="verifiable-delay-functions/vdf-summary/../../bibliography.html#LW15">LW15</a>]. With a sufficient time parameter, the last participant cannot predict the output on time, even if he knows the seed.</p>
<p><strong>Resource efficient Blockchain</strong>: Various attempts have been made to develop resource-efficient blockchains to reduce energy consumption. However, resource-efficient mining suffers from nothing-at-stake attack [<a href="verifiable-delay-functions/vdf-summary/../../bibliography.html#BBBF18">BBBF18</a>]. Cohen proposes to combine proof of resources [<a href="verifiable-delay-functions/vdf-summary/../../bibliography.html#KCMW15">KCMW15</a>] with an incremental verifiable delay function and use the product of proven resources and
induced delay as a measure of blockchain quality. This scheme prevents nothing-at-stake attacks by simulating the proof-of-work mining process [<a href="verifiable-delay-functions/vdf-summary/../../bibliography.html#WXWJWR22">WXWJWR22</a>].
For other applications of VDF, we refer the readers to [<a href="verifiable-delay-functions/vdf-summary/../../bibliography.html#BBBF18">BBBF18</a>].</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-survey-of-vdf-constructions"><a class="header" href="#a-survey-of-vdf-constructions">A Survey of VDF Constructions</a></h2>
<p>In this section, we study several well known candidates for VDF constructions. These include: the construction of Dwork and Naor [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#DN92">DN92</a>], the construction of Pietrzak [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#Pie19">Pie19</a>] and Wesolowski [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#Wes19">Wes19</a>], and the isogeny based construction of de Feo et al [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#FMPS19">FMPS19</a>]. Then we compare these constructions. Finally, we discuss a possible construction based on incremential verifiable computation [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#BBBF18">BBBF18</a>].</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="modular-square-root-based-construction"><a class="header" href="#modular-square-root-based-construction">Modular Square Root based Construction</a></h3>
<p>One of the early example of VDF can be found in the paper of Dwork and Naor [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#DN92">DN92</a>]. Their construction require a prover, to compute \(Y=\sqrt(X) \pmod{p}\) for a prime \(p\) and input \(X\). When \(p \equiv 3 \pmod{4}\) we see that \(Y=X^{\dfrac{p+1}{4}} \pmod{p}\), and thus computing \(Y\) requires \(O(\log p)\) computation steps. Verifying only require one multiplication by checking \(Y^2 \equiv X \pmod{p}\). The construction is formally described as follow.</p>
<p><strong>\(\mathsf{Gen}(1^\lambda)\)</strong>: The algorithm outputs a \(\lambda\) bit prime \(p\) where \(p \equiv 3 \pmod{4}\).</p>
<p><strong>\(\mathsf{Eval}(X)\)</strong>: Compute \(Y=X^{\dfrac{p+1}{4}} \pmod{p}\). The proof \(\pi\) is \(Y\).</p>
<p><strong>\(\mathsf{Verify}(X,Y,\pi)\)</strong>: Check if \(Y^2 \equiv X \pmod{p}\).</p>
<p>This construction, althought very simple, has two problem: First, the time parameter \(t\) is only to \(\log p\), thus to increase \(t\), a very large prime \(p\) is required. Second, it is possible to use parallel processors to speed up in field multiplications.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="group-of-unknown-order-based-constructions"><a class="header" href="#group-of-unknown-order-based-constructions">Group of Unknown Order based Constructions</a></h3>
<p>As its name suggests, most constructions follow this direction uses a group \(G\) such that \(|G|\) is unknown. These constructions require the prover to calculate the value \(y=g^{2^t}\) and provide a proof \(\pi\) of \(y\) that allows efficient verification. Without the knowledge of \(|G|\), calculating \(y\) requires \(O(t)\) steps.
There are two candidates for such a group: The <strong>RSA group</strong> and the <strong>Class Group of Imaginary Quadratic Number Field</strong>. The RSA group is the group \(G=(\mathbb{Z}^\times,.)\) where \(N\) is a product of two primes with unknown factorization. Computing the group order of \(N\) is as hard as factoring \(N\), so \(G\) can be seen as a Group of Unknown Order. However, the problem of the RSA group is that we require a trusted party to generate \(N\). To avoid trusted setup, we can choose \(G\) to be the class group of an imaginary quadratic field. For a large \(d \equiv 3 \pmod{4}\), it is assumed that the order of the class group of \(\mathbb{Q}(\sqrt{d})\) is hard to compute.</p>
<h3 id="pietrzaks-construction"><a class="header" href="#pietrzaks-construction">Pietrzak's Construction</a></h3>
<p>Pietrzak [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#Pie19">Pie19</a>] proposed a VDF based on a Group of Unknown Order. His idea for generating the proof for \(y=g^{2^t}\) is to use the identity \(z^ry=(g^rz)^{2^{t/2}}\) for any \(r\) where \(z=g^{2^{t/2}}\). His construction is described below.</p>
<p><strong>\(\mathsf{Gen}(1^\lambda)\)</strong>: The algoritms outputs \(pp=(G,H)\), where:</p>
<ul>
<li>\(G\) is a finite group.</li>
<li>\(H\), a hash function that maps arbitary input length to a bit string.</li>
</ul>
<p><strong>\(\mathsf{Eval}(X,pp,t)\)</strong>: To generate the proof for \(Y=g^{2^t}\), compute \(u*{i+1}=u_i^{r_i+2^{t/2^i}}\), where \(r_i=H(u_i,t/2^i,v_i,u_i^{2^{t/2^i}})\) and \(v_i=u_i^{r_i2^{t/2^i}+2^t}\). The algorithm outputs \((Y,\pi)\)=\((g^{2^t},\{u_1,u_2,...,u_{\log t}\})\).</p>
<p><strong>\(\mathsf{Verify}(X,Y,\pi,pp,t)\)</strong>: To verify the output, compute \(v_i=u_i^{r_i2^{t/2^i}+2^t}\) and check if \(v_{\log t}==u_{\log t}^2\).</p>
<h3 id="wesolowskis-construction"><a class="header" href="#wesolowskis-construction">Wesolowski's Construction</a></h3>
<p>Independently from Pietrzak, Wesolowski [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#Wes19">Wes19</a>] also constructed a VDF based on a Group of Unknown Order. Unlike Pietrzak's, Wesolowski's construction has shorter proof size and allows faster verification. However, the proving time is slower, as it require \(O(t)\) computation steps compared to \(O(\sqrt{t})\) in Pietrzak's construction.</p>
<p><strong>\(\mathsf{Gen}(1^\lambda)\)</strong>: The algoritms outputs \((pk,sk)\)=\(((G,H_1,H_2),|G|)\) where:</p>
<ul>
<li>
<p>\(G\) is a finite group.</p>
</li>
<li>
<p>\(H_1\) is a hash function that maps a bit string \(X\) to an element \(g\) in \(G\).</p>
</li>
<li>
<p>\(H_2\) is a hash function that maps arbitary input length to a bit string.
<strong>\(\mathsf{Eval}(X,sk,t)\)</strong>: By converting \(X\) to an element \(g=H_1(X) \in G\), the algorithm outputs \((Y,\pi)\)=\((g^{2^t},g^{(2^t-r)/l})\), where \(l=H_2(g||Y)\). The trapdoor information makes calculation faster as follow:</p>
</li>
<li>
<p><strong>Eval with trapdoor</strong>: With the knowledge of \(|G|\) as a trapdoor, the value of \(Y\) can be computed within \(O\log t\) time by calculating \(e=2^t \pmod{|G|}\) and \(Y=g^e\). Similarly, one can compute \(\pi\) quickly by calculating \(q=(2^t-r)/l \pmod{|G|}\) and \(\pi=g^q\).</p>
</li>
<li>
<p><strong>Eval without trapdoor</strong>: Without the knowledge of \(|G|\), computation of \(Y\) and \(\pi\) require \(O(\lambda t)\) and \(O(t\log t)\) time, respectively.</p>
</li>
</ul>
<p><strong>\(\mathsf{Verify}(X,Y,\pi,pk,t)\)</strong>: To verify the output, simply check if \(g^r\pi^l==Y\).</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="isogeny-based-constructions"><a class="header" href="#isogeny-based-constructions">Isogeny based Constructions</a></h3>
<p>In 2019, Luca de Feo et al [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#FMPS19">FMPS19</a>] constructed a VDF based on isogenies of supersingular elliptic curves and pairing. Their construction is motivated by the BLS signature, which uses a bilinear pairing. [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#FMPS19">FMPS19</a>].</p>
<p>For more information about elliptic curves and isogeny graph \(G_{F_q}(l)\), we refer the reader to see <a href="https://github.com/orochi-network/cookbook/tree/vdf/src/isogeny-based-crypto">the Elliptic Curve chapter I wrote earlier.</a>. Before continuing, we introduce some notations. Let \(l\) be a small prime. Let \(N\) be a large prime and \(p\) be another prime such that \(p+1\) is divisible by \(N\). For an elliptic curve \(E/\mathbf{F}\), define \(E[N]=\{P \in E | N_(P)=O\}\) where \(O\) is the infinity point.
The definition and properties of Weil pairing can be found in [Unknown bib ref: BLS03]. In the construction, the authors consider the pairing \(e_N: E[N]\times E'[N] \rightarrow \mu_N\). As the authors stated in their paper, the main important property the pairing is that, for any curves \(E\), isogeny \(E \rightarrow E'\) and \(P \in E[N]\) and \(Q \in E'[N]\) we have \(e_N(P,\hat{\phi(Q)})=e_N(\phi(P),Q)\). Now we move to describe the VDF Construction.</p>
<p><strong>\(\mathsf{Gen}(1^\lambda,t)\)</strong>: The algorithm selects a supersingular ellpitic curve \(E/ \mathbb{F}\), then choose a direction of the supersingular isogeny graph of degree \(l\), then compute the isogeny \(\phi E \rightarrow E'\) of degree \(l^t\) and its dual isogeny \(\hat{\phi}\).</p>
<p><strong>\(\mathsf{Eval}(Q)\)</strong>: For a point \(Q \in E'[N]\cap E(\mathbf{F})\), outputs \(\hat{\phi(Q)}\).</p>
<p><strong>\(\mathsf{Verify}(E,E',P,Q,\phi(P),\hat{\phi(Q)})\)</strong>: Check that \(\hat{\phi(Q)} \in E[N]\cap E(\mathbf{F})\) and \(e_N(P,\hat{\phi(Q)})=e_N(\phi(P),Q)\).</p>
<p>The security of the VDF is based on the assumption that, to compute the isogeny the map \(\hat{\phi}\), we are expected to walk \(t\) times between some vertices in the isogeny graph \(G_{F_q}(l)\). Currently, there is no efficient algorithm to find shortcut between these vertices of the graph. Finally, while the VDF is isogeny-based, it is not completely quantum secure, due to of the relation \(e_N(P,\hat{\phi(Q)})=e_N(\phi(P),Q)\) of bilinear pairing. Since Shor's algorithm can break the pairing inversion problem [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#FMPS19">FMPS19</a>], it can trivially recover the output \(\hat{\phi(Q)}\) from the relation above.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="comparision"><a class="header" href="#comparision">Comparision</a></h3>
<p>Now that we have described several well known VDF constructions, we would like to compare them. The table below compares the evaluation time, proof size and verification time of the VDF we described. Note that the value \(P\) in the table denote the number of processors.</p>
<div class="table-wrapper"><table><thead><tr><th>Construction</th><th>Eval Time</th><th>Eval Time (parallel)</th><th>Verification Time</th><th>Proof Size</th></tr></thead><tbody>
<tr><td>Dwork and Naor</td><td>\(O(t)\)</td><td>\(O(t^{2/3})\)</td><td>\(O(1)\)</td><td>\(O(\lambda)\)</td></tr>
<tr><td>Pietrzak</td><td>\(O(t+\sqrt{t})\)</td><td>\(O(t+\frac{\sqrt{t}}{P})\)</td><td>\(O(\log t)\)</td><td>\(O(\log t)\)</td></tr>
<tr><td>Wesolowski</td><td>\(O(t+\frac{t}{\log t})\)</td><td>\(O(t+\frac{\sqrt{t}}{P \log t})\)</td><td>\(\lambda^4\)</td><td>\(O(\lambda^3)\)</td></tr>
<tr><td>Feo et al.</td><td>\(O(t)\)</td><td>\(O(t)\)</td><td>\(\lambda^4\)</td><td>\(O(\lambda)\)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="possible-ivc-based-construction"><a class="header" href="#possible-ivc-based-construction">Possible IVC based construction</a></h2>
<p>Apart from the previous well-known constructions, we now discuss another possible direction to construct a VDF is to use Incrementally Verifiable Computation (IVC) [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#BBBF18">BBBF18</a>]. The basic idea of IVC is that after each computation step, the prover can produce a proof of the current state. The proof can also be updated after each step to produce a new proof for the corresponding step. The definition and properties of IVC can be found in [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#Pa08">Pa08</a>].
Now, consider a IVC system <strong>\((\mathsf{IVC.Setup}, \mathsf{IVC.Prove}, \mathsf{IVC.Verify})\)</strong> for a function \(f\), it is possible to construct a VDF as follow:</p>
<p><strong>\(\mathsf{Gen}(1^\lambda,t)\)</strong>: Run \((ek,vk) \leftarrow\) <strong>\(\mathsf{IVC.Gen}(1^\lambda,f,t)\)</strong>.</p>
<p><strong>\(\mathsf{Eval}(X,ek,t)\)</strong>: Run and output \((Y,\pi)\leftarrow\) <strong>\(\mathsf{IVC.Prove}(X,ek,t)\)</strong>.</p>
<p><strong>\(\mathsf{Verify}(X,Y,\pi,vk,t)\)</strong>: Outputs <strong>\(\mathsf{IVC.Verify}(X,Y,\pi,vk,t)\)</strong>.</p>
<p>The construction above is rather general. Therefore, it remains a question to choose a suitable IVC system and a function \(f\) to make the construction pratical.
As suggested by Boneh et al [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#BBBF18">BBBF18</a>] and Ethereum [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#KMT22">KMT22</a>], there are several candidate functions \(f\), for example VeeDo, Sloth++ [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#BBBF18">BBBF18</a>] or Minroot [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#KMT22">KMT22</a>].
Most previous IVCs involves using succinct non-interactive arguments of knowledge (SNARK). For these IVC constructions, at each step the prover has to constructs a SNARK which verifies a SNARK [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#BBBF18">BBBF18</a>]. This involves many FFT operations each step, and the SNARK verification circuit can be very expensive. In the recent NOVA [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#KST22">KST22</a>] proof system, the prover does not have to compute any FFT, and the recursion overhead is much lower than SNARK based IVCs [<a href="verifiable-delay-functions/vdf-candidates/../../bibliography.html#KST22">KST22</a>]. It is interesting to see if there will be any IVC based VDF using NOVA.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon-hash-for-zk-applications"><a class="header" href="#poseidon-hash-for-zk-applications">Poseidon hash for ZK applications</a></h1>
<p>Many use cases of practical computational integrity proof systems such as SNARKs, STARKs, Bulletproofs, involve <em>proving the knowledge of a preimage under a certain cryptographic hash function</em>, which is expressed as a circuit over a large prime field. However, the majority of hash functions do not perform computations in finite field, (SHA-256 in Zcash cryptocurrency). As a result, more constraints must be added in the circuit to represent the operations (for example, XOR, AND, etc.) in hash function as arithmetic operations in finite field. Hence, the expressed circuit could become very expensive due to the enormous number of hash constraints, leading to a huge computational
penalty. Therefore, new hash functions that performs natively with ZKP systems are needed.</p>
<p>In 2021, Grassi et al. [<a href="poseidon-hash/../bibliography.html#GKRRS21">GKRRS21</a>] introduced \(\mathsf{Poseidon}\), a cryptographic hash function that supports arithmetic operations for values in finite field, and therefore friendly with ZK applications. \(\mathsf{Poseidon}\) uses \(8\) times fewer constraints per message bit than [Pedersen Hash], according to <a href="https://iden3-docs.readthedocs.io/en/latest/iden3_repos/research/publications/zkproof-standards-workshop-2/pedersen-hash/pedersen.html">here</a>. The goal of this whole tutorial is to give a simpler explainations about Poseidon hash described in the referenced paper.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptographic-sponge-functions"><a class="header" href="#cryptographic-sponge-functions">Cryptographic sponge functions</a></h1>
<p>\(\mathsf{Poseidon}\) is a sponge-based cryptographic hash function, so it is neccessary to understand the design of such hash functions to understand the components of \(\mathsf{Poseidon}\). In this section, we look at the definitions and design of a sponged-based cryptographic hash function, before showing its applications in hash functions and other problems.</p>
<p>In 2007, the sponge construction was introduced by Guido Bertoni and others [<a href="poseidon-hash/cryptographic-sponge-function/../../bibliography.html#BDPA08">BDPA08</a>].</p>
<p>A <em><strong>sponge construction</strong></em> or <em><strong>sponge function</strong></em> takes input bit data of <em>arbitrary</em> length (called a <em><strong>message</strong></em>) and outputs bit data of <em>fixed</em> length (called a <em><strong>hash digest</strong></em>). In the context of a sponge function, we can say that the message is <em><strong>absorbed</strong></em> to the sponge, and the digest is <em><strong>squeezed</strong></em> out.</p>
<p>A sponge construction hash \(2\) <em><strong>phases</strong></em>:</p>
<ul>
<li><em><strong>Absorb</strong></em>: the message is compressed iteratively.</li>
<li><em><strong>Squeeze</strong></em>: the digest is extracted iteratively.</li>
</ul>
<p>Below is the construction of a sponge function:</p>
<p><img src="https://keccak.team/images/Sponge-150.png" alt="Sponge" /></p>
<ol>
<li>The first component (the leftmost) is the <em><strong>state memory</strong></em> \((S)\) and it is divided into \(2\) parts: the <em><strong>Bitrate</strong></em> part \((R)\) of size \(r\) and the <em><strong>Capacity</strong></em> part \((C)\) of size \(c\). \(S\) is initially set to \(0\), and we denote the initial state as \(I\): $$I = 0^r || 0^c.$$</li>
<li>The second component is the <em><strong>compress function \(f\)</strong></em> whose input and output are of the same length. \(S\) is updated whenever passing the compress function.</li>
<li>The third component is the <em><strong>padding function</strong></em> \(pad\) which increases the size of the <em><strong>message \(M\)</strong></em> to a suitable length (specifically, the length of the padded message is a multiple of bitrate \(r\)).</li>
<li>The squeeze phase takes the Bitrate of \(S\) as output parts, before going to the compress function \(f\). The final output: \(Z = \{ Z_0; Z_1;...\} \). If the length of \(Z\) is not a multiple of \(r\), it will be truncated.</li>
</ol>
<h1 id="applications-of-cryptographic-sponge-functions"><a class="header" href="#applications-of-cryptographic-sponge-functions">Applications of cryptographic sponge functions</a></h1>
<p>Sponge functions have both theoretical and practical uses. In theoretical cryptanalysis, a <strong>random sponge function</strong> is a sponge construction where \(f\) is a <em>random permutation or transformation</em>, as appropriate. Random sponge functions capture more of the practical limitations of cryptographic primitives than does the widely used random oracle model, in particular the <em>finite internal state</em> [<a href="poseidon-hash/cryptographic-sponge-function/../../bibliography.html#BDPA08">BDPA08</a>].</p>
<p>The sponge construction can also be used to build practical cryptographic primitives. For example, \(\mathsf{Keccak}\) cryptographic sponge with a \(1600\)-bit state has been selected by NIST as the winner in the \(\mathsf{SHA-3}\) competition. The strength of \(\mathsf{Keccak}\) derives from the intricate, multi-round permutation \(f\) developed by its authors. The \(\mathsf{RC4}\)-redesign called \(\mathsf{Spritz}\) [<a href="poseidon-hash/cryptographic-sponge-function/../../bibliography.html#RS16">RS16</a>] refers to the sponge-construct to define the algorithm.</p>
<p>In [<a href="poseidon-hash/cryptographic-sponge-function/../../bibliography.html#GKRRS21">GKRRS21</a>], they introduced \(\mathsf{Poseidon}\) hash function that uses the cryptographic sponge function as its architecture with the compression function \(f\) being the permutation \(\mathsf{Poseidon}^\pi\).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon-hash-overview"><a class="header" href="#poseidon-hash-overview">Poseidon Hash Overview</a></h1>
<p>Now that we understood the architecture of a sponge-based hash function, we are now ready to go to the details of \(\mathsf{Poseidon}\). \(\mathsf{Poseidon}\) is the proposed hash function in the paper, which maps strings over \(\mathbb{F}_p\) (for a prime \(p \approx 2^n &gt; 2^{31}\)) to fixed length strings over \(\mathbb{F}_p\). Specifically, they define: $$\mathsf{Poseidon}: \mathbb{F}_p^* \longrightarrow \mathbb{F}_p^o,$$ where \(o\) is the output length (\(\mathbb{F}_p\) elements), usually \(o = 1\).</p>
<p>The <strong>overall structure</strong> of \(\mathsf{Poseidon}\) hash is described in the figure below.</p>
<p><img src="poseidon-hash/poseidon-hash-overview/./../../assets/poseidon-hash/structure.png" alt="Pic" /></p>
<p>The hash function is constructed by instantiating a sponge function with the compression function \(f\) being the permutation \(\mathsf{Poseidon}^\pi\) (denoted by the block labeled \(\mathsf{P}\) in the figure). The hashing design strategy is based on \(\mathsf{Hades}\) [<a href="poseidon-hash/poseidon-hash-overview/../../bibliography.html#GLRRS20">GLRRS20</a>], which employes different <em>round functions</em> throughout the permutation to destroy all of its possible symmetries and structural properties.</p>
<p>The workflow of \(\mathsf{Poseidon}\) hash is described below, which is used the same in different use cases:</p>
<ul>
<li>Determine the capacity value \(c\) and the input padding \(pad\) depending on each use cases.</li>
<li>Split the obtained input \(m\) in to chunks of size \(r\).</li>
<li>Apply the \(\mathsf{Poseidon}^\pi\) permutation to the capacity element and the first chunk: \(I_c \oplus m_1\).</li>
<li>Add the result to the state and apply the permutation again until no more chunks are left.</li>
<li>Output \(o\) output elements from the bitrate part of the state. If needed, iterate the permutation one more time.</li>
</ul>
<p>Given that the overall structure of \(\mathsf{Poseidon}\) is determined by the instatiation of \(\mathsf{Poseidon}^\pi\), in  the next Sections, we would go to the details of each \(\mathsf{Poseidon}^\pi\) block (or equavilently, the block labeled \(\mathsf{P}\) in the figure).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon-permutation-design"><a class="header" href="#poseidon-permutation-design">Poseidon permutation design</a></h1>
<p>At the heart of the \(\mathsf{Poseidon}\) hash is the \(\mathsf{Hades}\)-based permutation \(\mathsf{Poseidon}^\pi\). As mentioned before, \(\mathsf{Hades}\) employs efficient <em>round functions</em> which is applied many times in order ti make the permutation behave like a random permutation. The same round function is applied throughout the permutation to destroy its symmetries and structural properties.</p>
<p>This section explains in detail the \(\mathsf{Hades}\) <a href="poseidon-hash/poseidon-permutation-design/./hades-design-strategy.html">design strategy</a>, the <a href="poseidon-hash/poseidon-permutation-design/./hades-based-design.html">detailed design</a> of \(\mathsf{Hades}\)-based permutation, and the <a href="poseidon-hash/poseidon-permutation-design/./concrete-poseidon-instantiation.html">different instantiations</a> of \(\mathsf{Poseidon}^\pi\) permutation in different use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hades-design-strategy"><a class="header" href="#hades-design-strategy">Hades design strategy</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>In \(\mathsf{Hades}\), they mix rounds with <em><strong>full SBox layers</strong></em> and rounds with <em><strong>partial SBox layers</strong></em>. They want to strike the balance between:</p>
<ul>
<li>Full layers are <em><strong>expensive</strong></em> in software and ZK proof systems, but <em><strong>well resists</strong></em> statistical attacks.</li>
<li>Partial layers are <em><strong>computationally cheap</strong></em>, but often serves as good as full ones against algebraic attacks.</li>
</ul>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p>The Hades design strategy receives input a state \(S=(S_1,S_2,\dots,S_t)\) and consists of \(R_f\) initial rounds, in which SBoxes are applied to the <em>full state</em>. After these \(R_f\) rounds, \(R_p\) partial rounds in the middle contain <em>a single SBox for each round</em>, and the rest of the state goes through the nonliner layer <em><strong>unchanged</strong></em> (you can say that the rest goes through the identity functions \(f(x) = x\)). Finally, \(R_f\) full rounds at the end are applied again:
$$R_f \longrightarrow R_p \longrightarrow R_f$$</p>
<p>An overview of the construction of the permutation can be described in the figure below:</p>
<p align="center" width="100%">
    <img width="120%" height="120%" src="poseidon-hash/poseidon-permutation-design/./../../assets/poseidon-hash/round-function.png">
</p>
<h2 id="the-round-function"><a class="header" href="#the-round-function">The round function</a></h2>
<p>As in the figure, in each round, several functions (illustrated as the blocks) are applied to the state \(S\) to transform it into a new state \(S'\), these functions are called <strong>round functions</strong>. Each round function consists of \(3\) components:</p>
<ul>
<li>\(AddRoundConstants\), denoted by \(ARC(\cdot)\): essentially an addition of the state with a random constant. </li>
<li>\(SubWords\), denoted by \(SBox(\cdot)\) or \(SB(\cdot)\). This is simply the SBox substitution.</li>
<li>\(MixLayers\), denoted by \(M(\cdot)\). This is the <em><strong>linear layer</strong></em> of the construction. It involves multiplication between the state and a \(t \times t\) <em><strong>MDS(Maximum Distance Separable) matrix</strong></em>. This is used to apply the <em><strong>wide trail strategy</strong></em> (explained in [<a href="poseidon-hash/poseidon-permutation-design/../../bibliography.html#DJRV01">DJRV01</a>]) which helps provide arguments against statistical attacks.</li>
</ul>
<p>Note that: we can use the same number of full rounds instead of partial rounds in the construction without decreasing the security. However, this leads to significantly higher computation costs in our applications.</p>
<h2 id="maximum-distance-separable"><a class="header" href="#maximum-distance-separable">Maximum Distance Separable</a></h2>
<p>A matrix \(M \in \mathbb{F}^{t \times t}\) is called <em><strong>maximum distance saparable (MDS)</strong></em> iff it has a branch number \(\mathcal{B}(M) = t + 1\). The branch number of \(M\) is defined as \(\mathcal{B}(M) = min_{x \in \mathbb{F}^t}\{wt(x) + wt(M(x))\}\) where \(wt\) is the <em><strong>Hamming weight</strong></em> in wide trail terminology. </p>
<p>Equivalently, a matrix \(M\) is MDS iff <strong>every submatrix of \(M\) is non-singular</strong> (a non-singluar matrix is a matrix whose determinant is not \(0\)). This definition is easier to understand.</p>
<p>There will be a construction of these matrices in later sections, because we do not need regular MDS matrices, but <em><strong>secure</strong></em> MDS matrices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hades-based-poseidonpi-permutation-design"><a class="header" href="#hades-based-poseidonpi-permutation-design">Hades-based POSEIDON\(^\pi\) permutation design</a></h1>
<p>Recall in the <a href="poseidon-hash/poseidon-permutation-design/./hades-design-strategy.html">previous section</a>, the \(\mathsf{Poseidon}^\pi\) permutation is a composition of round functions, each of which consists of \(3\) components such as \(AddroundConstants\), \(SubWords\), and \(MixLayer\), each takes input a state \(S=(S_1,S_2,\dots,S_t)\) and produces a new state \(S'\). In this Section, we describe the \(3\) main components of the round function of \(\mathsf{Poseidon}^\pi\).</p>
<h2 id="notation"><a class="header" href="#notation">Notation</a></h2>
<p>The function takes input of \(t \geq 2\) words in \(\mathbb{F}_p\), where \(p\) is a prime of size \(p \approx 2^n &gt; 2^{30}\) and \(N = nt\) to denote the size of texts in bits.</p>
<h2 id="addroundconstants-component"><a class="header" href="#addroundconstants-component">AddRoundConstants component</a></h2>
<p>This is the first component of the round function described in <a href="poseidon-hash/poseidon-permutation-design/./hades-design-strategy.html">Hades design strategy</a>. Given the input state \( S = ( S_1, S_2, \cdots, S_t ) \), where each of \( S_i \) is a word, it outputs $$ S' = AddRoundConstants(S, T) = S + T = ( S_1 + T_1, S_2 + T_2, \dots, S_t + T_t ) $$ where \(T\) is the <em><strong>round constant vector</strong></em> that is randomly generated in a method described in <a href="poseidon-hash/poseidon-permutation-design/./concrete-poseidon-instantiation.html">Poseidon concrete instantiation</a>. Essentially, this component performs a field addition between the state and the round constant.</p>
<h2 id="the-subwords-sbox-layer"><a class="header" href="#the-subwords-sbox-layer">The SubWords (SBox) layer</a></h2>
<p>This is the second component of the round function described in <a href="poseidon-hash/poseidon-permutation-design/./hades-design-strategy.html">Hades design strategy</a>. <em><strong>Subtitution boxes</strong></em> (or <em><strong>S-Boxes</strong></em>) are widely used in cryptography. In this context of an architecture that resembles block ciphers, SBoxes are used to ensure <a href="https://en.wikipedia.org/wiki/Confusion_and_diffusion">Shannon's property of confusion</a>.</p>
<p>Given the state \( S = ( S_1, S_2, \cdots, S_t ) \), where each of \(S_i\) is a word, this component outputs a new state $$ S' = SB(S) =  ( SB(S_1), SB(S_2), \dots, SB(S_t) ).$$ Essentially, this component performs multiple field multiplications on the state.</p>
<p>In [<a href="poseidon-hash/poseidon-permutation-design/../../bibliography.html#GKRRS21">GKRRS21</a>], the authors focus on the setting: $$SB(x) = x^\alpha, \alpha \geq 3$$ where \(\alpha\) is the smallest positive integer that satisfies \(gcd(\alpha, p - 1) = 1\). These permutations are called &quot;\(x^\alpha-Poseidon^\pi\)&quot;.</p>
<p>Specifically, they use:</p>
<ul>
<li>\(\alpha = 3\) if \(p \not\equiv 1 \pmod{3}\)</li>
<li>\(\alpha = 5\) if \(p \equiv 1 \pmod{3}\) and \(p \not\equiv 1 \pmod{5}\)</li>
</ul>
<p>It turns out that \(\alpha = 5\), which is \(SB(x) = x^5\), is suitable for the prime subfields of the scalar field of <em><strong>BLS12-381</strong></em> and <em><strong>BN254</strong></em>, which are two of the most popular prime fields in ZK applications.</p>
<h2 id="mixcolumns---the-linear-layer"><a class="header" href="#mixcolumns---the-linear-layer">MixColumns - The linear layer</a></h2>
<p>This is the last layer (also called the <em><strong>linear layer</strong></em>) of the round function. Given the state \( S = ( S_1, S_2, \cdots, S_t ) \). This layer outputs the new state
$$ S' = \mathcal{M} \times S =
\begin{bmatrix} 
\mathcal{M}_{11} &amp; \mathcal{M}_{12} &amp; \dots &amp; \mathcal{M}_{1t} \\ 
\mathcal{M}_{21} &amp; \mathcal{M}_{22} &amp; \dots &amp; \mathcal{M}_{2t} \\ 
\dots &amp; \dots &amp; \ddots &amp; \dots \\ 
\mathcal{M}_{t1} &amp; \mathcal{M}_{t2} &amp; \dots &amp; \mathcal{M}_{tt} 
\end{bmatrix} \times \begin{bmatrix}
S_1 \\ S_2 \\ \dots \\ S_t
\end{bmatrix} $$ 
where \(\mathcal{M}\) is the <em><strong>secure Maximum Distance Separable</strong></em> matrix of size \(t \times t\), which is explained in <a href="poseidon-hash/poseidon-permutation-design/./hades-design-strategy.html">the Hades design strategy</a>. The MDS matrices are randomly and securely generated using a method described in <a href="poseidon-hash/poseidon-permutation-design/./concrete-poseidon-instantiation.html">Poseidon concrete instantiations</a>.</p>
<p>It is proved [<a href="poseidon-hash/poseidon-permutation-design/../../bibliography.html#MS78">MS78</a>] that a \(t \times t\) MDS matrix with elements in \(\mathbb{F}_p\) exists if \(2t + 1 \leq p\).</p>
<p>One method of constructing such a matrix introduced in this paper is using a <em><strong>Cauchy matrix</strong></em>. For \((x_i, y_i) \in \mathbb{F}_p\), where \(i \in [1, t]\), the entries of the matrix \(\mathcal{M}\) are: $$\mathcal{M}_{i, j} = \dfrac{1}{x_i + y_j}$$ where the entries of \(\{x_i\}_{1 \leq i \leq t}\) and \(\{y_i\}_{1 \leq i \leq t}\) are pairwise distinct and \(x_i + y_i \neq 0\), where \(i \in \{1,\cdots,t\}\) and \(j \in \{1,\cdots,t\}\)</p>
<h2 id="constructing-the-matrix"><a class="header" href="#constructing-the-matrix">Constructing the matrix</a></h2>
<p>The paper suggest the following method to generate matrices to avoid some known vulnerabilities which this note skipped:</p>
<ul>
<li>Randomly select pairwise distinct \(\{x_i\}_{1 \leq i \leq t}\) and \(\{y_i\}_{1 \leq i \leq t}\) where \(x_i + y_j \neq 0\) and where \(i \in \{ 1,\cdots,t \}\) and \(j \in \{ 1,\cdots,t \}\).</li>
<li>Determine if the matrix is secure using <a href="https://extgit.iaik.tugraz.at/krypto/linear-layer-tool">this test</a> introduced in [<a href="poseidon-hash/poseidon-permutation-design/../../bibliography.html#GRS20">GRS20</a>]</li>
<li>Repeat this procedure until we find a secure matrix.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concrete-poseidonpi-instantiation"><a class="header" href="#concrete-poseidonpi-instantiation">Concrete POSEIDON\(^\pi\) instantiation</a></h1>
<h2 id="main-instance"><a class="header" href="#main-instance">Main instance</a></h2>
<ul>
<li>SBox function: The authors proposed using \(SB(x)=x^5\) for all use cases</li>
<li>With the security level \(M = 80, 128\), the size of the Capacity \(c = 255\) bits (\(1\) field element). And \(t\) can be \(3\) or \(5\) to achieve the <em>2-to-1</em> or <em>4-to-1</em> compression functions.</li>
<li>Psudeonumber generation: The paper uses <em><strong>Grain LFSR</strong></em> in self-shrinking mode. This can be used to generate the round constants and matrices. This usage can be reminiscent to <a href="https://en.wikipedia.org/wiki/Nothing-up-my-sleeve_number">nothing-up-my-sleeve numbers</a>.</li>
<li>MDS matrix: It is recommended that we should use the Cauchy matrix for the linear layer, which described in <a href="poseidon-hash/poseidon-permutation-design/./hades-based-design.html">Hades-based permutation design</a>.</li>
</ul>
<h2 id="the-grain-lfsr"><a class="header" href="#the-grain-lfsr">The grain LFSR</a></h2>
<p>The grain LFSR is used to generate pseudorandom numbers for the round constants and the MDS matrices described in <a href="poseidon-hash/poseidon-permutation-design/./hades-design-strategy.html">Hades design strategy</a>. The technical details of the LFSR is provided in Appendix E of [<a href="poseidon-hash/poseidon-permutation-design/../../bibliography.html#GKRRS21">GKRRS21</a>]. The state in Grain LFSR is \(80\) bits in size and is computed as follows:</p>
<ol>
<li>Initialize the state with \(80\) bits \(\{b_0,b_1,\cdots,b_{79}\}\) as follows:
<ul>
<li>\(b_0,b_1\): describe the field.</li>
<li>\(b_2,b_3,b_4,b_5\): describe the SBox.</li>
<li>\(b_6 \rightarrow b_{17}\): binary representation of \(n\).</li>
<li>\(b_{18} \rightarrow b_{29}\): binary representation of \(t\).</li>
<li>\(b_{30} \rightarrow b_{39}\): binary representation of \(R_F\).</li>
<li>\(b_{40} \rightarrow b_{49}\): binary representation of \(R_P\).</li>
<li>\(b_{50} \rightarrow b_{79}\): set to \(1\).</li>
</ul>
</li>
<li>Update the bits: $$b_{i + 80} = b_{i + 62} \oplus b_{i + 51} \oplus b_{i + 38} \oplus b_{i + 23} \oplus b_{i + 13} \oplus b_i$$</li>
<li>Discard the first \(160\) bits.</li>
<li>Evaluate bits in pairs: if the first bit is \(1\), output the second bit. If it is \(0\), discard the second bit.</li>
</ol>
<p>If a randomly sampled integer is \(\geq p\), we discard this value and take the next one. We generate numbers starting from the most significant bit. However, starting from MSB or LSB makes no difference regarding the security</p>
<h2 id="choosing-number-of-rounds"><a class="header" href="#choosing-number-of-rounds">Choosing number of rounds</a></h2>
<p>Proved in Proposition 5.1, 5.2, and 5.3 in [<a href="poseidon-hash/poseidon-permutation-design/../../bibliography.html#GKRRS21">GKRRS21</a>], this table represents the parameters \(R_F, R\) that can protect the construction from statistical and algebraic attacks:</p>
<div class="table-wrapper"><table><thead><tr><th>Construction</th><th>\(R_F\)</th><th>\(R = R_F + R_P\)</th></tr></thead><tbody>
<tr><td>\(x^5\)-\(\mathsf{Poseidon}\)-\(128\)</td><td>\(6\)</td><td>\(56 + \lceil \log_5{(t)} \rceil\)</td></tr>
<tr><td>\(x^5\)-\(\mathsf{Poseidon}\)-\(80\)</td><td>\(6\)</td><td>\(35 + \lceil \log_5{(t)} \rceil\)</td></tr>
<tr><td>\(x^5\)-\(\mathsf{Poseidon}\)-\(256\)</td><td>\(6\)</td><td>\(111 + \lceil \log_5{(t)} \rceil\)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="unlocking-the-web3-universe-orochi-networks-oracle-service"><a class="header" href="#unlocking-the-web3-universe-orochi-networks-oracle-service">Unlocking the Web3 Universe: Orochi Network's Oracle Service</a></h2>
<p>Imagine building a Web3 application that thrives on real-world data, free from centralized control. This is the vision behind Orochi Network's Oracle service, a powerful tool poised to revolutionize the way DApps interact with the external world.</p>
<p>Traditionally, DApps have struggled to access external data sources, relying on centralized oracles – single points of failure susceptible to manipulation and bias. Orochi's Oracle shatters these limitations, offering a decentralized, secure, and versatile solution for feeding accurate and verifiable data into your DApps.</p>
<h2 id="deployed-platform-2"><a class="header" href="#deployed-platform-2">Deployed Platform</a></h2>
<p>Oracle V1 was deployed on following smart contract platform.</p>
<h3 id="mainnet-2"><a class="header" href="#mainnet-2">Mainnet</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Network Name</th><th>Address</th></tr></thead><tbody>
<tr><td>Ancient8 Mainnet</td><td><a href="https://scan.ancient8.gg/address/0x11Af4c61D8D51016b8800EA71e42Cf7c3682Ab84">0x11Af4c61D8D51016b8800EA71e42Cf7c3682Ab84</a></td></tr>
<tr><td>U2U Solaris Mainnet</td><td><a href="https://u2uscan.xyz/address/0xF1EE9eD597336B2a585DDb5A3DB6c5f0739cbE87">0xF1EE9eD597336B2a585DDb5A3DB6c5f0739cbE87</a></td></tr>
</tbody></table>
</div>
<h3 id="testnet-2"><a class="header" href="#testnet-2">Testnet</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Network Name</th><th>Address</th></tr></thead><tbody>
<tr><td>Ancient8 Testnet</td><td><a href="https://scanv2-testnet.ancient8.gg/address/0xBF3Ff099fb6c23296Fd192df643ad49FCeD658D0">0xBF3Ff099fb6c23296Fd192df643ad49FCeD658D0</a></td></tr>
<tr><td>Unicorn Ultra Nebulas</td><td><a href="https://testnet.u2uscan.xyz/address/0xfA73F946E66eC366419c110f9Ae1AEe234eA714e">0xfA73F946E66eC366419c110f9Ae1AEe234eA714e</a></td></tr>
<tr><td>Sei Devnet</td><td><a href="https://seitrace.com/address/0x2323e0098c260Fe5815e85e9EC127D53401Bd6e7">0x2323e0098c260Fe5815e85e9EC127D53401Bd6e7</a></td></tr>
<tr><td>Moonbase Alpha TestNet</td><td><a href="https://moonbase.moonscan.io/address/0x23E47A2730464e6c7DcB11c8e1E82F0279c042Eb">0x23E47A2730464e6c7DcB11c8e1E82F0279c042Eb</a></td></tr>
<tr><td>Saakuru TestNet</td><td><a href="https://explorer.testnet.oasys.games/address/0xFe514492cBFB5b1713C7f7e8fd1c474D2739195f">0xFe514492cBFB5b1713C7f7e8fd1c474D2739195f</a></td></tr>
<tr><td>Zircuit TestNet</td><td><a href="https://explorer.zircuit.com/address/0xFe514492cBFB5b1713C7f7e8fd1c474D2739195f">0xFe514492cBFB5b1713C7f7e8fd1c474D2739195f</a></td></tr>
<tr><td>ZKFair TestNet</td><td><a href="https://testnet-scan.zkfair.io/address/0xFe514492cBFB5b1713C7f7e8fd1c474D2739195f">0xFe514492cBFB5b1713C7f7e8fd1c474D2739195f</a></td></tr>
</tbody></table>
</div>
<h2 id="so-what-exactly-can-the-orochi-oracle-orocle-do"><a class="header" href="#so-what-exactly-can-the-orochi-oracle-orocle-do">So, what exactly can the Orochi Oracle (Orocle) do?</a></h2>
<ul>
<li><strong>Gather Diverse Data:</strong> Access a vast pool of information, from financial markets and weather updates to social media sentiment and IoT sensor readings. The possibilities are endless, empowering DApps with real-time, relevant data.</li>
<li><strong>Decentralized &amp; Trustworthy:</strong> Eliminate the risk of manipulation with a distributed network of nodes verifying and securing data integrity. No single entity controls the flow of information, fostering trust and transparency.</li>
<li><strong>Highly Scalable &amp; Efficient:</strong> Designed to handle high volumes of data requests efficiently, ensuring your DApp performs smoothly even with complex data integrations.</li>
<li><strong>Chain Agnostic:</strong> Integrate seamlessly with various blockchain platforms, offering flexibility and wider reach for your DApp.
But why is this important?</li>
</ul>
<h2 id="the-potential-applications-are-vast-1"><a class="header" href="#the-potential-applications-are-vast-1">The potential applications are vast:</a></h2>
<ul>
<li><strong>Decentralized finance (DeFi):</strong> Integrate real-world market data for dynamic pricing and risk management in DeFi protocols.</li>
<li><strong>Prediction markets:</strong> Enable accurate and trustworthy predictions based on real-time events and data.</li>
<li><strong>Supply chain management:</strong> Track goods movement and environmental conditions transparently across complex supply chains.</li>
<li><strong>Gaming &amp; Entertainment:</strong> Create immersive experiences that react to real-world events and user behavior.</li>
</ul>
<p>Orochi's Oracle is more than just a data feed; it's a gateway to a truly decentralized and data-driven future for Web3. By unlocking the power of real-world data, it empowers developers to build DApps that are not only innovative but also robust, secure, and truly impactful.</p>
<p>Ready to explore the possibilities? Dive into the world of Orochi Network and unleash the full potential of your Web3 vision.</p>
<h3 id="installation-2"><a class="header" href="#installation-2">Installation</a></h3>
<p>Installing <code>@orochi-network/contracts</code> will help you interactive with Orochi Network Oracle and VRF (Orand) much more easier.</p>
<pre><code class="language-bash">npm i --save-dev @orochi-network/contracts
</code></pre>
<h2 id="oracle-aggregator-overview"><a class="header" href="#oracle-aggregator-overview">Oracle Aggregator Overview</a></h2>
<p>This section describes all methods of Oracle V1 that facilitate interaction from external smart contracts. To familiarize yourself with Oracle V1, the following terminology definitions may be helpful.</p>
<p><strong>appId:</strong> Application ID on Oracle, our oracle support multiple applications there are two of them listed here:</p>
<div class="table-wrapper"><table><thead><tr><th>Application ID</th><th>Description</th></tr></thead><tbody>
<tr><td>1</td><td>Asset Price</td></tr>
<tr><td>2</td><td>Cross Chain Data</td></tr>
</tbody></table>
</div>
<p><strong>round:</strong> Each application will have different round number, every time a new dataset submitted the round number will be increased by 1</p>
<p><strong>identifier:</strong> Data identifier, it's a <code>bytes20</code> used to index data on smart contract, for asset price application <code>identifier</code> is token's symbol</p>
<p><strong>Note:</strong></p>
<ul>
<li><em>Only 255 latest rounds will be cached on smart contract, you can not get more than 255 rounds from the current round by using <code>getData()</code> method</em></li>
<li><em>Round is uint64, so 2^64 is the limit of number of round</em></li>
</ul>
<h3 id="summary-1"><a class="header" href="#summary-1">Summary:</a></h3>
<ul>
<li>This contract defines an interface for interacting with an oracle aggregator.</li>
<li>It provides functions to retrieve application metadata, data, and round information.</li>
<li>It's designed for read-only access, as all functions are marked as view.</li>
</ul>
<h3 id="key-points-1"><a class="header" href="#key-points-1">Key Points:</a></h3>
<p>The IOrocleAggregatorV1 interface defines several methods:</p>
<ul>
<li><code>request(uint256 identifier, bytes calldata data)</code>: This function is used to create a new request. It takes an identifier and data as parameters and returns a boolean indicating whether the request was successful.</li>
<li><code>fulfill(uint256 identifier, bytes calldata data)</code>: This function is used to fulfill a request. It also takes an identifier and data as parameters and returns a boolean indicating whether the fulfillment was successful.</li>
<li><code>getMetadata(uint32 appId, bytes20 identifier)</code>: This function is used to get the metadata of a given application. It takes an application ID and an identifier as parameters and returns the round and the last update time.</li>
<li><code>getData(uint32 appId, uint64 round, bytes20 identifier)</code>: This function is used to get the data of an application for a specific round. It takes an application ID, a round number, and an identifier as parameters and returns the data.</li>
<li><code>getLatestData(uint32 appId, bytes20 identifier)</code>: This function is used to get the latest data of an application. It takes an application ID and an identifier as parameters and returns the data.</li>
<li><code>getLatestRound(uint32 appId, bytes20 identifier)</code>: This function is used to get the latest round of an application. It takes an application ID and an identifier as parameters and returns the round number, the last update time, and the data.</li>
</ul>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<p>Here is an example of <code>AssetPrice</code> consumer:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@orochi-network/contracts/IOracleAggregatorV1.sol';

contract ConsumerAssetPrice is Ownable {
  IOracleAggregatorV1 private oracle;

  event SetOracle(address indexed oldOracle, address indexed newOracle);

  constructor(address oracleAddress) {
    _setOracle(oracleAddress);
  }

  function _setOracle(address newOracle) internal {
    emit SetOracle(address(oracle), newOracle);
    oracle = IOracleAggregatorV1(newOracle);
  }

  /**
   * Get price of an asset based USD
   * @dev Token price will use 18 decimal for all token
   * @param identifier Asset identifier (e.g. BTC, ETH, USDT)
   * @return price
   */
  function _getPrice(bytes20 identifier) internal view returns (uint256) {
    return uint256(oracle.getLatestData(1, identifier));
  }

  /**
   * Get price of a pair
   * @dev Token price will use 18 decimal for all token
   * (e.g. BTC/ETH =&gt; srcToken='BTC' dstToken='ETH')
   * @param srcToken Asset identifier of source
   * @param dstToken Asset identifier of destination
   * @return price
   */
  function _getPriceOfPair(bytes20 srcToken, bytes20 dstToken) internal view returns (uint256) {
    return (_getPrice(srcToken) * 10 ** 9) / (_getPrice(dstToken));
  }

  /**
   * Allow owner to set new Oracle address
   * @param newOracle new Oracle address
   * @return success
   */
  function setOracle(address newOracle) external onlyOwner returns (bool) {
    _setOracle(newOracle);
    return true;
  }
}
</code></pre>
<p>Here is an example of <code>BitcoinSeller</code> that used <code>ConsumerAssetPrice</code>:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import './ConsumerAssetPrice.sol';

contract BitcoinSeller is ConsumerAssetPrice {
  constructor(address provider) ConsumerAssetPrice(provider) {}

  function estimate(uint256 amount) external view returns (uint256 total) {
    total = _getPrice('BTC') * amount;
  }

  function ethOverBtc() external view returns (uint256 price) {
    price = _getPriceOfPair('ETH', 'BTC');
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unlocking-the-web3-universe-orochi-networks-oracle-service-1"><a class="header" href="#unlocking-the-web3-universe-orochi-networks-oracle-service-1">Unlocking the Web3 Universe: Orochi Network's Oracle Service</a></h2>
<p>Imagine building a Web3 application that thrives on real-world data, free from centralized control. This is the vision behind Orochi Network's Oracle service, a powerful tool poised to revolutionize the way DApps interact with the external world.</p>
<p>Traditionally, DApps have struggled to access external data sources, relying on centralized oracles – single points of failure susceptible to manipulation and bias. Orochi's Oracle shatters these limitations, offering a decentralized, secure, and versatile solution for feeding accurate and verifiable data into your DApps.</p>
<h2 id="deployed-platform-3"><a class="header" href="#deployed-platform-3">Deployed Platform</a></h2>
<p>Oracle V1 was deployed on following smart contract platform.</p>
<h3 id="mainnet-3"><a class="header" href="#mainnet-3">Mainnet</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Network Name</th><th>Address</th></tr></thead><tbody>
<tr><td>Ancient8 Mainnet</td><td><a href="https://scan.ancient8.gg/address/0x11Af4c61D8D51016b8800EA71e42Cf7c3682Ab84">0x11Af4c61D8D51016b8800EA71e42Cf7c3682Ab84</a></td></tr>
<tr><td>U2U Solaris Mainnet</td><td><a href="https://u2uscan.xyz/address/0xF1EE9eD597336B2a585DDb5A3DB6c5f0739cbE87">0xF1EE9eD597336B2a585DDb5A3DB6c5f0739cbE87</a></td></tr>
</tbody></table>
</div>
<h3 id="testnet-3"><a class="header" href="#testnet-3">Testnet</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Network Name</th><th>Address</th></tr></thead><tbody>
<tr><td>Ancient8 Testnet</td><td><a href="https://scanv2-testnet.ancient8.gg/address/0xBF3Ff099fb6c23296Fd192df643ad49FCeD658D0">0xBF3Ff099fb6c23296Fd192df643ad49FCeD658D0</a></td></tr>
<tr><td>Unicorn Ultra Nebulas</td><td><a href="https://testnet.u2uscan.xyz/address/0xfA73F946E66eC366419c110f9Ae1AEe234eA714e">0xfA73F946E66eC366419c110f9Ae1AEe234eA714e</a></td></tr>
<tr><td>Sei Devnet</td><td><a href="https://seitrace.com/address/0x2323e0098c260Fe5815e85e9EC127D53401Bd6e7">0x2323e0098c260Fe5815e85e9EC127D53401Bd6e7</a></td></tr>
<tr><td>Moonbase Alpha TestNet</td><td><a href="https://moonbase.moonscan.io/address/0x23E47A2730464e6c7DcB11c8e1E82F0279c042Eb">0x23E47A2730464e6c7DcB11c8e1E82F0279c042Eb</a></td></tr>
<tr><td>Saakuru TestNet</td><td><a href="https://explorer.testnet.oasys.games/address/0xFe514492cBFB5b1713C7f7e8fd1c474D2739195f">0xFe514492cBFB5b1713C7f7e8fd1c474D2739195f</a></td></tr>
<tr><td>Zircuit TestNet</td><td><a href="https://explorer.zircuit.com/address/0xFe514492cBFB5b1713C7f7e8fd1c474D2739195f">0xFe514492cBFB5b1713C7f7e8fd1c474D2739195f</a></td></tr>
<tr><td>ZKFair TestNet</td><td><a href="https://testnet-scan.zkfair.io/address/0xFe514492cBFB5b1713C7f7e8fd1c474D2739195f">0xFe514492cBFB5b1713C7f7e8fd1c474D2739195f</a></td></tr>
</tbody></table>
</div>
<h2 id="so-what-exactly-can-the-orochi-oracle-orocle-do-1"><a class="header" href="#so-what-exactly-can-the-orochi-oracle-orocle-do-1">So, what exactly can the Orochi Oracle (Orocle) do?</a></h2>
<ul>
<li><strong>Gather Diverse Data:</strong> Access a vast pool of information, from financial markets and weather updates to social media sentiment and IoT sensor readings. The possibilities are endless, empowering DApps with real-time, relevant data.</li>
<li><strong>Decentralized &amp; Trustworthy:</strong> Eliminate the risk of manipulation with a distributed network of nodes verifying and securing data integrity. No single entity controls the flow of information, fostering trust and transparency.</li>
<li><strong>Highly Scalable &amp; Efficient:</strong> Designed to handle high volumes of data requests efficiently, ensuring your DApp performs smoothly even with complex data integrations.</li>
<li><strong>Chain Agnostic:</strong> Integrate seamlessly with various blockchain platforms, offering flexibility and wider reach for your DApp.
But why is this important?</li>
</ul>
<h2 id="the-potential-applications-are-vast-2"><a class="header" href="#the-potential-applications-are-vast-2">The potential applications are vast:</a></h2>
<ul>
<li><strong>Decentralized finance (DeFi):</strong> Integrate real-world market data for dynamic pricing and risk management in DeFi protocols.</li>
<li><strong>Prediction markets:</strong> Enable accurate and trustworthy predictions based on real-time events and data.</li>
<li><strong>Supply chain management:</strong> Track goods movement and environmental conditions transparently across complex supply chains.</li>
<li><strong>Gaming &amp; Entertainment:</strong> Create immersive experiences that react to real-world events and user behavior.</li>
</ul>
<p>Orochi's Oracle is more than just a data feed; it's a gateway to a truly decentralized and data-driven future for Web3. By unlocking the power of real-world data, it empowers developers to build DApps that are not only innovative but also robust, secure, and truly impactful.</p>
<p>Ready to explore the possibilities? Dive into the world of Orochi Network and unleash the full potential of your Web3 vision.</p>
<h3 id="installation-3"><a class="header" href="#installation-3">Installation</a></h3>
<p>Installing <code>@orochi-network/contracts</code> will help you interactive with Orochi Network Oracle and VRF (Orand) much more easier.</p>
<pre><code class="language-bash">npm i --save-dev @orochi-network/contracts
</code></pre>
<h2 id="oracle-aggregator-overview-1"><a class="header" href="#oracle-aggregator-overview-1">Oracle Aggregator Overview</a></h2>
<p>This section describes all methods of Oracle V1 that facilitate interaction from external smart contracts. To familiarize yourself with Oracle V1, the following terminology definitions may be helpful.</p>
<p><strong>appId:</strong> Application ID on Oracle, our oracle support multiple applications there are two of them listed here:</p>
<div class="table-wrapper"><table><thead><tr><th>Application ID</th><th>Description</th></tr></thead><tbody>
<tr><td>1</td><td>Asset Price</td></tr>
<tr><td>2</td><td>Cross Chain Data</td></tr>
</tbody></table>
</div>
<p><strong>round:</strong> Each application will have different round number, every time a new dataset submitted the round number will be increased by 1</p>
<p><strong>identifier:</strong> Data identifier, it's a <code>bytes20</code> used to index data on smart contract, for asset price application <code>identifier</code> is token's symbol</p>
<p><strong>Note:</strong></p>
<ul>
<li><em>Only 255 latest rounds will be cached on smart contract, you can not get more than 255 rounds from the current round by using <code>getData()</code> method</em></li>
<li><em>Round is uint64, so 2^64 is the limit of number of round</em></li>
</ul>
<h3 id="summary-2"><a class="header" href="#summary-2">Summary:</a></h3>
<ul>
<li>This contract defines an interface for interacting with an oracle aggregator.</li>
<li>It provides functions to retrieve application metadata, data, and round information.</li>
<li>It's designed for read-only access, as all functions are marked as view.</li>
</ul>
<h3 id="key-points-2"><a class="header" href="#key-points-2">Key Points:</a></h3>
<p>The IOrocleAggregatorV1 interface defines several methods:</p>
<ul>
<li><code>request(uint256 identifier, bytes calldata data)</code>: This function is used to create a new request. It takes an identifier and data as parameters and returns a boolean indicating whether the request was successful.</li>
<li><code>fulfill(uint256 identifier, bytes calldata data)</code>: This function is used to fulfill a request. It also takes an identifier and data as parameters and returns a boolean indicating whether the fulfillment was successful.</li>
<li><code>getMetadata(uint32 appId, bytes20 identifier)</code>: This function is used to get the metadata of a given application. It takes an application ID and an identifier as parameters and returns the round and the last update time.</li>
<li><code>getData(uint32 appId, uint64 round, bytes20 identifier)</code>: This function is used to get the data of an application for a specific round. It takes an application ID, a round number, and an identifier as parameters and returns the data.</li>
<li><code>getLatestData(uint32 appId, bytes20 identifier)</code>: This function is used to get the latest data of an application. It takes an application ID and an identifier as parameters and returns the data.</li>
<li><code>getLatestRound(uint32 appId, bytes20 identifier)</code>: This function is used to get the latest round of an application. It takes an application ID and an identifier as parameters and returns the round number, the last update time, and the data.</li>
</ul>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<p>Here is an example of <code>AssetPrice</code> consumer:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@orochi-network/contracts/IOracleAggregatorV1.sol';

contract ConsumerAssetPrice is Ownable {
  IOracleAggregatorV1 private oracle;

  event SetOracle(address indexed oldOracle, address indexed newOracle);

  constructor(address oracleAddress) {
    _setOracle(oracleAddress);
  }

  function _setOracle(address newOracle) internal {
    emit SetOracle(address(oracle), newOracle);
    oracle = IOracleAggregatorV1(newOracle);
  }

  /**
   * Get price of an asset based USD
   * @dev Token price will use 18 decimal for all token
   * @param identifier Asset identifier (e.g. BTC, ETH, USDT)
   * @return price
   */
  function _getPrice(bytes20 identifier) internal view returns (uint256) {
    return uint256(oracle.getLatestData(1, identifier));
  }

  /**
   * Get price of a pair
   * @dev Token price will use 18 decimal for all token
   * (e.g. BTC/ETH =&gt; srcToken='BTC' dstToken='ETH')
   * @param srcToken Asset identifier of source
   * @param dstToken Asset identifier of destination
   * @return price
   */
  function _getPriceOfPair(bytes20 srcToken, bytes20 dstToken) internal view returns (uint256) {
    return (_getPrice(srcToken) * 10 ** 9) / (_getPrice(dstToken));
  }

  /**
   * Allow owner to set new Oracle address
   * @param newOracle new Oracle address
   * @return success
   */
  function setOracle(address newOracle) external onlyOwner returns (bool) {
    _setOracle(newOracle);
    return true;
  }
}
</code></pre>
<p>Here is an example of <code>BitcoinSeller</code> that used <code>ConsumerAssetPrice</code>:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import './ConsumerAssetPrice.sol';

contract BitcoinSeller is ConsumerAssetPrice {
  constructor(address provider) ConsumerAssetPrice(provider) {}

  function estimate(uint256 amount) external view returns (uint256 total) {
    total = _getPrice('BTC') * amount;
  }

  function ethOverBtc() external view returns (uint256 price) {
    price = _getPriceOfPair('ETH', 'BTC');
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orand-v2"><a class="header" href="#orand-v2">Orand V2</a></h1>
<p>Orand project was built based on Elliptic Curve Verifiable Random Function (ECVRF). It is deterministic, verifiable and secured based on assumptions from elliptic curves. Administrators of Orochi Network are unable to manipulate the results.</p>
<p>To optimize operation costs and improve security we provided following features:</p>
<ul>
<li><strong>Verifiable:</strong> An Orand's epoch can be verified independently outside our system or can be verified by smart contracts.</li>
<li><strong>Self and Delegated Submission:</strong> Orand project have flexibility in proof submission, we just generate valid ECVRF proof and you can decide how to submit them:
<ul>
<li><strong>Self Submission:</strong> You can request from your back-end to Orand service and submit the randomness to your smart contract.</li>
<li><strong>Delegation Submission:</strong> You can delegate the submission process to Orochi Network by transfer token to our operator, so the feeding process will be performed automatically.</li>
<li><strong>Request Submission:</strong> Instead of request to Orand service, you can request randomness via Oracle contract.</li>
</ul>
</li>
<li><strong>Batching:</strong> We allow you to set the batching limit for one epoch, e.g., we can batch <code>100</code> randomness for one single epoch which makes the cost be reduced significantly.</li>
</ul>
<h2 id="deployed-platform-4"><a class="header" href="#deployed-platform-4">Deployed Platform</a></h2>
<p>Orand V2 was deployed on following smart contract platform.</p>
<h3 id="mainnet-4"><a class="header" href="#mainnet-4">Mainnet</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Network Name</th><th>Address</th></tr></thead><tbody>
<tr><td>Ancient8 Mainnet</td><td><a href="https://scan.ancient8.gg/address/0x184Ae846c6AC7F7452350AB4Fa81C2cD986c64E1">0x184Ae846c6AC7F7452350AB4Fa81C2cD986c64E1</a></td></tr>
<tr><td>U2U Solaris Mainnet</td><td><a href="https://u2uscan.xyz/address/0x8131bE6F2b15Bead0B8D675db9D3d43BFcb3eA72">0x8131bE6F2b15Bead0B8D675db9D3d43BFcb3eA72</a></td></tr>
</tbody></table>
</div>
<h3 id="testnet-4"><a class="header" href="#testnet-4">Testnet</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Network Name</th><th>Address</th></tr></thead><tbody>
<tr><td>Ancient8 Testnet</td><td><a href="https://scanv2-testnet.ancient8.gg/address/0x5778CE57f49A5487D2127fd39a060D75aF694e8c">0x5778CE57f49A5487D2127fd39a060D75aF694e8c</a></td></tr>
<tr><td>Unicorn Ultra Nebulas</td><td><a href="https://testnet.u2uscan.xyz/address/0xe97FE633EC2021A71214D5d9BfF9f337dD1db5c1">0xe97FE633EC2021A71214D5d9BfF9f337dD1db5c1</a></td></tr>
<tr><td>Sei Devnet</td><td><a href="https://seitrace.com/address/0x1b95BCC7828719a4C2Dc74789708b70fE5EEa9Cf">0x1b95BCC7828719a4C2Dc74789708b70fE5EEa9Cf</a></td></tr>
<tr><td>Moonbase Alpha TestNet</td><td><a href="https://moonbase.moonscan.io/address/0xf212917C9cd73E1A2860996a13AC474A70635447">0xf212917C9cd73E1A2860996a13AC474A70635447</a></td></tr>
<tr><td>Saakuru TestNet</td><td><a href="https://explorer.testnet.oasys.games/address/0xEaC801617D35A62f6782Ce11f0E935DC5960817c">0xEaC801617D35A62f6782Ce11f0E935DC5960817c</a></td></tr>
<tr><td>Zircuit TestNet</td><td><a href="https://explorer.zircuit.com/address/0xEaC801617D35A62f6782Ce11f0E935DC5960817c">0xEaC801617D35A62f6782Ce11f0E935DC5960817c</a></td></tr>
<tr><td>ZKFair TestNet</td><td><a href="https://testnet-scan.zkfair.io/address/0xEaC801617D35A62f6782Ce11f0E935DC5960817c">0xEaC801617D35A62f6782Ce11f0E935DC5960817c</a></td></tr>
</tbody></table>
</div>
<h2 id="self-submission-1"><a class="header" href="#self-submission-1">Self Submission</a></h2>
<p>User will request the verifiable randomness from Orand service, they can submit the randomness themselves and control gas consumption. You must submit epoch by sequence and starting epoch or genesis must be epoch <code>0</code>.</p>
<pre class="mermaid">%%{init: {'theme':'neutral'}}%%
sequenceDiagram
    Game Backend-&gt;&gt;+Orand: Request randomness
    Orand-&gt;&gt;-Game Backend: VRF Epoch
    Game Backend-&gt;&gt;+Orand Contract: Publish VRF Epoch
    Orand Contract-&gt;&gt;-Game Backend: Transaction Receipt
</pre>
<h2 id="delegated-submission-1"><a class="header" href="#delegated-submission-1">Delegated Submission</a></h2>
<p>User will delegate the submission process to Orochi Network, first they need to deposit native token to operator address that provided by Orochi Network.</p>
<pre class="mermaid">%%{init: {'theme':'neutral'}}%%
sequenceDiagram
    Game Backend-&gt;&gt;+Orand: Request randomness
    Orand-&gt;&gt;+Orand Contract: Publish VRF Epoch
    Orand Contract-&gt;&gt;-Orand: Transaction Receipt
    Orand-&gt;&gt;-Game Backend: VRF Epoch + Tx Receipt
</pre>
<h2 id="request-submission-1"><a class="header" href="#request-submission-1">Request Submission</a></h2>
<p>dApp will request to Orochi Network's oracle contract for the randomness, Orand service will fulfill this request and submit the randomness to Orand provider contract.</p>
<pre class="mermaid">%%{init: {'theme':'neutral'}}%%
sequenceDiagram
    Game Frontend-&gt;&gt;+Oracle: Request randomness
    Orand-&gt;&gt;+Orand: Repeating Polling Request
    Orand-&gt;&gt;-Orand Contract: Fulfil Request
    Oracle-&gt;&gt;Game Frontend: Tx Receipt
</pre>
<h2 id="orand-v3-2"><a class="header" href="#orand-v3-2">Orand V3</a></h2>
<p>Orand V3 will focus on utilizing Multi Party Computation (MPC) to secure the randomness generation, allowing the whole system to act as one random oracle. It makes the process more dispersed. In this stage, we boot up <strong>Chaos Theory Alliance</strong> to preventing predictability. Everything is built up toward to the vision of <strong>Decentralized Random Number Generator</strong>. If you believe in the vision of <strong>Decentralized Random Number Generator</strong>, please send drop us an email to (<a href="orochi-network/contact@orochi.network">contact@orochi.network</a>) in order to participate in <strong>Chaos Theory Alliance</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orochi-network-sdk"><a class="header" href="#orochi-network-sdk">Orochi Network SDK</a></h1>
<p>Orochi Network SDK provides client-side tools that allow you to interact with the whole Orochi Network ecosystem. We supported browser and Node.js at the first place.</p>
<h2 id="installation-4"><a class="header" href="#installation-4">Installation</a></h2>
<p>You can install Orochi Network sdk by running:</p>
<pre><code class="language-bash">npm install @orochi-network/sdk
</code></pre>
<p>Please take note that <code>@orochi-network/sdk</code> requires <code>es2018</code> to work as expected.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>First you might need to import <code>@orochi-network/sdk</code> to your project</p>
<pre><code class="language-ts">import { Orand } from &quot;@orochi-network/sdk&quot;;
</code></pre>
<p>After you import the sdk, you can use our sdk in your project.</p>
<pre><code class="language-ts">let orand = await Orand.fromRPC(
  {
    user: &quot;YOUR_REGISTERED_USERNAME&quot;,
    secretKey: &quot;YOUR_REGISTERED_SECRET&quot;,
    url: &quot;https://orand-test.orochi.network&quot;,
    consumerAddress: &quot;YOUR_CONSUMER_ADDRESS&quot;,
  },
  &quot;https://rpcv2-testnet.ancient8.gg/&quot;
);
</code></pre>
<p>Orochi Network is going to provide following data:</p>
<ul>
<li><code>YOUR_REGISTERED_USERNAME</code>: Your identify in our system</li>
<li><code>YOUR_REGISTERED_SECRET</code>: Your HMAC-SHA256 secret key</li>
<li><code>YOUR_CONSUMER_ADDRESS</code>: Consumer address can be any valid EVM compatible address</li>
</ul>
<p><strong>Note:</strong> <em>for the mainnet <code>YOUR_CONSUMER_ADDRESS</code> need to be provided by you and should be a valid consumer contract that implied <a href="https://github.com/orochi-network/smart-contracts/blob/main/contracts/orand-v2/interfaces/IOrandConsumerV2.sol">IOrandConsumerV2</a></em></p>
<p>In the example above, we initiated an instance of <code>Orand</code> which provides verifiable randomness based on <a href="orochi-network/../ecvrf/verifiable_random_function.html">ECVRF</a>.</p>
<p>To learn more about Orand integration please check <a href="orochi-network/./contract-integration.html">next section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orand-code-integration"><a class="header" href="#orand-code-integration">Orand Code Integration</a></h1>
<h3 id="randomness-feeding-process"><a class="header" href="#randomness-feeding-process">Randomness Feeding Process</a></h3>
<p>Your application can request the verifiable randomness directly from Orand. Then you can publish the randomness yourself by calling the method <code>publish()</code> (<code>genesis()</code> for the genesis epoch) on smart contract <code>OrandProviderV2</code>. Higher tier of service establishes the ability to submit the randomness from Orand service but the Orochi Network will cover the cost for each randomness.</p>
<pre><code class="language-plain">┌───────────┐         ┌─────┐      ┌──────────────┐
│Application│         │Orand│      │Smart Contract│
└─────┬─────┘         └──┬──┘      └──────┬───────┘
      │                  │                │
      │Request Randomness│                │
      │─────────────────&gt;│                │
      │                  │                │
      │                  │Get latest epoch│
      │                  │───────────────&gt;│
      │                  │                │
      │                  │  Latest epoch  │
      │                  │&lt;───────────────│
      │                  │                │
      │   ECVRF Proof    │                │
      │&lt;─────────────────│                │
      │                  │                │
      │            ECVRF Proof            │
      │──────────────────────────────────&gt;│
┌─────┴─────┐         ┌──┴──┐      ┌──────┴───────┐
│Application│         │Orand│      │Smart Contract│
└───────────┘         └─────┘      └──────────────┘
</code></pre>
<h3 id="request-randomness-from-orand"><a class="header" href="#request-randomness-from-orand">Request Randomness From Orand</a></h3>
<pre><code class="language-ts">import { Orand } from &quot;@orochi-network/sdk&quot;;

(async () =&gt; {
  // Create an instance of Orand
  let orandInstance = await Orand.fromRPC(
    {
      user: &quot;YOUR_REGISTERED_USERNAME&quot;,
      secretKey: &quot;YOUR_REGISTERED_SECRET&quot;,
      url: &quot;ORAND_SERVICE_URL&quot;,
      consumerAddress: &quot;YOUR_CONSUMER_ADDRESS&quot;,
    },
    &quot;NETWORK_RPC_URL&quot;
  );

  const newEpoch = await orandInstance.newPrivateEpoch();
  console.log(newEpoch);
})();
</code></pre>
<ul>
<li><strong>ORAND_SERVICE_URL:</strong> We will provide you the service URL</li>
<li><strong>YOUR_REGISTERED_USERNAME:</strong> The username that you registered with Orand service, <em>e.g: &quot;Navi&quot;</em></li>
<li><strong>YOUR_REGISTERED_SECRET:</strong> The random secret key used to authenticate yourself, <em>for instance, 6b1ab607287f5379db8b70bb7515feaa</em></li>
<li><strong>YOUR_CONSUMER_ADDRESS:</strong> The consumer smart contract address <em>for instance, &quot;0x66681298BBbdf30a0B3Ec98cAbf41AA7669dc201&quot;</em></li>
<li><strong>NETWORK_RPC_URL:</strong> JSON RPC endpoint of network, All configurations will be load base on <code>ChainId</code></li>
</ul>
<p><strong>Note:</strong> <code>ChainId</code> is a predefined value, you can check <a href="https://chainlist.org/">the chain list here</a>.</p>
<h3 id="submit-the-randomness-to-your-smart-contract"><a class="header" href="#submit-the-randomness-to-your-smart-contract">Submit The Randomness To Your Smart Contract</a></h3>
<pre><code class="language-ts">const wallet = Wallet.fromPhrase(
  &quot;YOUR_WALLET_PASSPHRASE&quot;
  orandInstance.rpcProvider
);

const newEpoch = await orandInstance.newPrivateEpoch();
console.log(newEpoch);
console.log(await orandInstance.publish(newEpoch, wallet));
</code></pre>
<p>Don't mind to contact us on Telegram if you need support <a href="https://t.me/OrochiNetwork">https://t.me/OrochiNetwork</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliography"><a class="header" href="#bibliography">Bibliography</a></h1>
<script type="text/javascript">
function defaultCopyTextToClipboard(text) {
    var textArea = document.createElement("textarea");
    textArea.value = text;

    // Avoid scrolling to bottom
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.position = "fixed";

    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    try {
        var ok = document.execCommand('copy');
        var msg = ok ? 'was ok' : 'failed';
        console.log('Backing copy: Text copy was ' + msg);
    } catch (err) {
        console.error('Backing copy: Unable to copy text', err);
    }

    document.body.removeChild(textArea);
}

function copyToClipboard(text) {
    if (!navigator.clipboard) {
        defaultCopyTextToClipboard(text);
        return;
    }
    navigator.clipboard.writeText(text).then(function() {
        console.log('Text copied to clipboard');
    }, function(err) {
        console.error('Error copying text: ', err);
    });
}

</script>
<style></style>
<div class="bib_div">
<details data-key="WXWJWR22" class=ref>
<summary class=citation>
<a id="WXWJWR22">[WXWJWR22]</a> - Qiang Wu and Liang Xi and Shiren Wang and Shan Ji and Shenqing Wang and Yongjun Ren - <a href="https://doi.org/10.3390/s22197524" target="_blank"><cite>Verifiable Delay Function and Its Blockchain-Related Application:
               {A} Survey</cite></a>. - 2022. -
<button onclick="copyToClipboard('\{\{ #cite WXWJWR22 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract"><a class="header" href="#summaryabstract">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="KST22" class=ref>
<summary class=citation>
<a id="KST22">[KST22]</a> - Abhiram Kothapalli and Srinath Setty and Ioanna Tzialla - <a href="https://doi.org/10.1007/978-3-031-15985-5\_13" target="_blank"><cite>Nova: Recursive Zero-Knowledge Arguments from Folding Schemes</cite></a>. - 2022. -
<button onclick="copyToClipboard('\{\{ #cite KST22 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-1"><a class="header" href="#summaryabstract-1">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="Pa08" class=ref>
<summary class=citation>
<a id="Pa08">[Pa08]</a> - Paul Valiant - <a href="https://doi.org/10.1007/978-3-540-78524-8\_1" target="_blank"><cite>Incrementally Verifiable Computation or Proofs of Knowledge Imply
               Time/Space Efficiency</cite></a>. - 2008. -
<button onclick="copyToClipboard('\{\{ #cite Pa08 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-2"><a class="header" href="#summaryabstract-2">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="KMT22" class=ref>
<summary class=citation>
<a id="KMT22">[KMT22]</a> - Dmitry Khovratovich and Mary Maller and Pratyush Ranjan Tiwari - <a href="https://eprint.iacr.org/2022/1626" target="_blank"><cite>MinRoot: Candidate Sequential Function for Ethereum {VDF}</cite></a>. - 2022. -
<button onclick="copyToClipboard('\{\{ #cite KMT22 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-3"><a class="header" href="#summaryabstract-3">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="FMPS19" class=ref>
<summary class=citation>
<a id="FMPS19">[FMPS19]</a> - Luca De Feo and Simon Masson and Christophe Petit and Antonio Sanso - <a href="https://doi.org/10.1007/978-3-030-34578-5_10" target="_blank"><cite>Verifiable Delay Functions from Supersingular Isogenies and Pairings</cite></a>. - 2019. -
<button onclick="copyToClipboard('\{\{ #cite FMPS19 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-4"><a class="header" href="#summaryabstract-4">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="Pie19" class=ref>
<summary class=citation>
<a id="Pie19">[Pie19]</a> - Krzysztof Pietrzak - <a href="https://doi.org/10.4230/LIPIcs.ITCS.2019.60" target="_blank"><cite>Simple Verifiable Delay Functions</cite></a>. - 2019. -
<button onclick="copyToClipboard('\{\{ #cite Pie19 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-5"><a class="header" href="#summaryabstract-5">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="Wes19" class=ref>
<summary class=citation>
<a id="Wes19">[Wes19]</a> - Benjamin Wesolowski - <a href="https://doi.org/10.1007/978-3-030-17659-4\_13" target="_blank"><cite>Efficient Verifiable Delay Functions</cite></a>. - 2019. -
<button onclick="copyToClipboard('\{\{ #cite Wes19 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-6"><a class="header" href="#summaryabstract-6">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="DN92" class=ref>
<summary class=citation>
<a id="DN92">[DN92]</a> - Cynthia Dwork and Moni Naor - <a href="https://doi.org/10.1007/3-540-48071-4\_10" target="_blank"><cite>Pricing via Processing or Combatting Junk Mail</cite></a>. - 1992. -
<button onclick="copyToClipboard('\{\{ #cite DN92 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-7"><a class="header" href="#summaryabstract-7">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="Ra17" class=ref>
<summary class=citation>
<a id="Ra17">[Ra17]</a> - randao.org - <a href="https://www.randao.org/whitepaper/Randao_v0.85_en.pdf" target="_blank"><cite>Randao</cite></a>. - 2017. -
<button onclick="copyToClipboard('\{\{ #cite Ra17 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-8"><a class="header" href="#summaryabstract-8">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="BBBF18" class=ref>
<summary class=citation>
<a id="BBBF18">[BBBF18]</a> - Dan Boneh and Joseph Bonneau and Benedikt B{\{u}}nz and Ben Fisch - <a href="https://doi.org/10.1007/978-3-319-96884-1\_25" target="_blank"><cite>Verifiable Delay Functions</cite></a>. - 2018. -
<button onclick="copyToClipboard('\{\{ #cite BBBF18 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-9"><a class="header" href="#summaryabstract-9">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="KCMW15" class=ref>
<summary class=citation>
<a id="KCMW15">[KCMW15]</a> - Chun{-}Han Ko and Ching{-}Chun Chou and Hsiang{-}Yun Meng and Hung{-}Yu Wei - <a href="https://doi.org/10.1109/TWC.2015.2402680" target="_blank"><cite>Strategy-Proof Resource Allocation Mechanism for Multi-Flow Wireless
               Multicast</cite></a>. - 2015. -
<button onclick="copyToClipboard('\{\{ #cite KCMW15 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-10"><a class="header" href="#summaryabstract-10">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="LW15" class=ref>
<summary class=citation>
<a id="LW15">[LW15]</a> - Arjen K. Lenstra and Benjamin Wesolowski - <a href="http://eprint.iacr.org/2015/366" target="_blank"><cite>A random zoo: sloth, unicorn, and trx</cite></a>. - 2015. -
<button onclick="copyToClipboard('\{\{ #cite LW15 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-11"><a class="header" href="#summaryabstract-11">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="KZG10" class=ref>
<summary class=citation>
<a id="KZG10">[KZG10]</a> - Aniket Kate and Gregory M. Zaverucha and Ian Goldberg - <a href="https://doi.org/10.1007/978-3-642-17373-8_11" target="_blank"><cite>Constant-Size Commitments to Polynomials and Their Applications</cite></a>. - 2010. -
<button onclick="copyToClipboard('\{\{ #cite KZG10 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-12"><a class="header" href="#summaryabstract-12">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="FKLO0W21" class=ref>
<summary class=citation>
<a id="FKLO0W21">[FKLO0W21]</a> - Nicholas Franzese and Jonathan Katz and Steve Lu and Rafail Ostrovsky and Xiao Wang and Chenkai Weng - <a href="https://doi.org/10.1145/3460120.3484800" target="_blank"><cite>Constant-Overhead Zero-Knowledge for {RAM} Programs</cite></a>. - 2021. -
<button onclick="copyToClipboard('\{\{ #cite FKLO0W21 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-13"><a class="header" href="#summaryabstract-13">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="GWC19" class=ref>
<summary class=citation>
<a id="GWC19">[GWC19]</a> - Ariel Gabizon and Zachary J. Williamson and Oana Ciobotaru - <a href="https://eprint.iacr.org/2019/953" target="_blank"><cite>{PLONK:} Permutations over Lagrange-bases for Oecumenical Noninteractive
               arguments of Knowledge</cite></a>. - 2019. -
<button onclick="copyToClipboard('\{\{ #cite GWC19 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-14"><a class="header" href="#summaryabstract-14">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="Sipser2012-introduction-to-theory-of-computation" class=ref>
<summary class=citation>
<a id="Sipser2012-introduction-to-theory-of-computation">[Sipser2012-introduction-to-theory-of-computation]</a> - Sipser, Michael - <cite>Introduction to the Theory of Computation</cite>. - 2012. -
<button onclick="copyToClipboard('\{\{ #cite Sipser2012-introduction-to-theory-of-computation \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-15"><a class="header" href="#summaryabstract-15">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="MRV99" class=ref>
<summary class=citation>
<a id="MRV99">[MRV99]</a> - Silvio Micali and Michael O. Rabin and Salil P. Vadhan - <a href="https://doi.org/10.1109/SFFCS.1999.814584" target="_blank"><cite>Verifiable Random Functions</cite></a>. - 1999. -
<button onclick="copyToClipboard('\{\{ #cite MRV99 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-16"><a class="header" href="#summaryabstract-16">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="PWHVNRG17" class=ref>
<summary class=citation>
<a id="PWHVNRG17">[PWHVNRG17]</a> - DimitriosPapadopoulos and Duane Wessels and Shumon Huque and Moni Naor and Jan Včelák and Leonid Reyzin and Sharon Goldberg - <a href="https://eprint.iacr.org/2017/099.pdf" target="_blank"><cite>Making NSEC5 Practical for DNSSEC</cite></a>. - 2017. -
<button onclick="copyToClipboard('\{\{ #cite PWHVNRG17 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-17"><a class="header" href="#summaryabstract-17">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="DY05" class=ref>
<summary class=citation>
<a id="DY05">[DY05]</a> - Yevgeniy Dodis and Aleksandr Yampolskiy - <a href="https://doi.org/10.1007/978-3-540-30580-4_28" target="_blank"><cite>A Verifiable Random Function with Short Proofs and Keys</cite></a>. - 2005. -
<button onclick="copyToClipboard('\{\{ #cite DY05 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-18"><a class="header" href="#summaryabstract-18">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="Jag15" class=ref>
<summary class=citation>
<a id="Jag15">[Jag15]</a> - Tibor Jager - <a href="https://doi.org/10.1007/978-3-662-46497-7_5" target="_blank"><cite>Verifiable Random Functions from Weaker Assumptions</cite></a>. - 2015. -
<button onclick="copyToClipboard('\{\{ #cite Jag15 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-19"><a class="header" href="#summaryabstract-19">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="HJ15" class=ref>
<summary class=citation>
<a id="HJ15">[HJ15]</a> - Dennis Hofheinz and Tibor Jager - <a href="https://doi.org/10.1007/978-3-662-49096-9\_14" target="_blank"><cite>Verifiable Random Functions from Standard Assumptions</cite></a>. - 2016. -
<button onclick="copyToClipboard('\{\{ #cite HJ15 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-20"><a class="header" href="#summaryabstract-20">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="BMR10" class=ref>
<summary class=citation>
<a id="BMR10">[BMR10]</a> - Dan Boneh and Hart William Montgomery and Ananth Raghunathan - <a href="https://doi.org/10.1145/1866307.1866323" target="_blank"><cite>Algebraic pseudorandom functions with improved efficiency from the
               augmented cascade</cite></a>. - 2010. -
<button onclick="copyToClipboard('\{\{ #cite BMR10 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-21"><a class="header" href="#summaryabstract-21">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="GLOW20" class=ref>
<summary class=citation>
<a id="GLOW20">[GLOW20]</a> - David Galindo and Jia Liu and Mihai Ordean and Jin{-}Mann Wong - <a href="https://doi.org/10.1109/EuroSP51992.2021.00017" target="_blank"><cite>Fully Distributed Verifiable Random Functions and their Application
               to Decentralised Random Beacons</cite></a>. - 2021. -
<button onclick="copyToClipboard('\{\{ #cite GLOW20 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-22"><a class="header" href="#summaryabstract-22">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="EKSSZSC20" class=ref>
<summary class=citation>
<a id="EKSSZSC20">[EKSSZSC20]</a> - Muhammed F. Esgin and Veronika Kuchta and Amin Sakzad and Ron Steinfeld and Zhenfei Zhang and Shifeng Sun and Shumo Chu - <a href="https://doi.org/10.1007/978-3-662-64331-0_29" target="_blank"><cite>Practical Post-quantum Few-Time Verifiable Random Function with Applications
               to Algorand</cite></a>. - 2021. -
<button onclick="copyToClipboard('\{\{ #cite EKSSZSC20 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-23"><a class="header" href="#summaryabstract-23">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="SECG1" class=ref>
<summary class=citation>
<a id="SECG1">[SECG1]</a> - Certicom Research - <a href="https://www.secg.org/sec1-v2.pdf" target="_blank"><cite>SEC1: Elliptic Curve Cryptography</cite></a>. - 2009. -
<button onclick="copyToClipboard('\{\{ #cite SECG1 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-24"><a class="header" href="#summaryabstract-24">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="BCKL09" class=ref>
<summary class=citation>
<a id="BCKL09">[BCKL09]</a> - Mira Belenkiy and Melissa Chase and Markulf Kohlweiss and Anna Lysyanskaya - <a href="https://doi.org/10.1007/978-3-642-03298-1_9" target="_blank"><cite>Compact E-Cash and Simulatable VRFs Revisited</cite></a>. - 2009. -
<button onclick="copyToClipboard('\{\{ #cite BCKL09 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-25"><a class="header" href="#summaryabstract-25">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="Bit19" class=ref>
<summary class=citation>
<a id="Bit19">[Bit19]</a> - Nir Bitansky - <a href="https://doi.org/10.1007/s00145-019-09331-1" target="_blank"><cite>Verifiable Random Functions from Non-interactive Witness-Indistinguishable
               Proofs</cite></a>. - 2020. -
<button onclick="copyToClipboard('\{\{ #cite Bit19 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-26"><a class="header" href="#summaryabstract-26">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="Lysyanskaya02" class=ref>
<summary class=citation>
<a id="Lysyanskaya02">[Lysyanskaya02]</a> - Anna Lysyanskaya - <a href="https://doi.org/10.1007/3-540-45708-9_38" target="_blank"><cite>Unique Signatures and Verifiable Random Functions from the {DH-DDH}
               Separation</cite></a>. - 2002. -
<button onclick="copyToClipboard('\{\{ #cite Lysyanskaya02 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-27"><a class="header" href="#summaryabstract-27">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="MR02" class=ref>
<summary class=citation>
<a id="MR02">[MR02]</a> - Silvio Micali and Ronald L. Rivest - <a href="https://doi.org/10.1007/3-540-45760-7_11" target="_blank"><cite>Micropayments Revisited</cite></a>. - 2002. -
<button onclick="copyToClipboard('\{\{ #cite MR02 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-28"><a class="header" href="#summaryabstract-28">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="GJKR99" class=ref>
<summary class=citation>
<a id="GJKR99">[GJKR99]</a> - Rosario Gennaro and Stanislaw Jarecki and Hugo Krawczyk and Tal Rabin - <a href="https://doi.org/10.1007/3-540-48910-X_21" target="_blank"><cite>Secure Distributed Key Generation for Discrete-Log Based Cryptosystems</cite></a>. - 1999. -
<button onclick="copyToClipboard('\{\{ #cite GJKR99 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-29"><a class="header" href="#summaryabstract-29">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="Ped91" class=ref>
<summary class=citation>
<a id="Ped91">[Ped91]</a> - Torben P. Pedersen - <a href="https://doi.org/10.1007/3-540-46766-1_9" target="_blank"><cite>Non-Interactive and Information-Theoretic Secure Verifiable Secret
               Sharing</cite></a>. - 1991. -
<button onclick="copyToClipboard('\{\{ #cite Ped91 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-30"><a class="header" href="#summaryabstract-30">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="BKP11" class=ref>
<summary class=citation>
<a id="BKP11">[BKP11]</a> - Michael Backes and Aniket Kate and Arpita Patra - <a href="https://doi.org/10.1007/978-3-642-25385-0_32" target="_blank"><cite>Computational Verifiable Secret Sharing Revisited</cite></a>. - 2011. -
<button onclick="copyToClipboard('\{\{ #cite BKP11 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-31"><a class="header" href="#summaryabstract-31">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="CZAPGD20" class=ref>
<summary class=citation>
<a id="CZAPGD20">[CZAPGD20]</a> - Alin Tomescu and Robert Chen and Yiming Zheng and Ittai Abraham and Benny Pinkas and Guy Golan{-}Gueta and Srinivas Devadas - <a href="https://doi.org/10.1109/SP40000.2020.00059" target="_blank"><cite>Towards Scalable Threshold Cryptosystems</cite></a>. - 2020. -
<button onclick="copyToClipboard('\{\{ #cite CZAPGD20 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-32"><a class="header" href="#summaryabstract-32">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="Ped91a" class=ref>
<summary class=citation>
<a id="Ped91a">[Ped91a]</a> - Torben P. Pedersen - <a href="https://doi.org/10.1007/3-540-46416-6_47" target="_blank"><cite>A Threshold Cryptosystem without a Trusted Party (Extended Abstract)</cite></a>. - 1991. -
<button onclick="copyToClipboard('\{\{ #cite Ped91a \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-33"><a class="header" href="#summaryabstract-33">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="CGJKR99" class=ref>
<summary class=citation>
<a id="CGJKR99">[CGJKR99]</a> - Ran Canetti and Rosario Gennaro and Stanislaw Jarecki and Hugo Krawczyk and Tal Rabin - <a href="https://doi.org/10.1007/3-540-48405-1_7" target="_blank"><cite>Adaptive Security for Threshold Cryptosystems</cite></a>. - 1999. -
<button onclick="copyToClipboard('\{\{ #cite CGJKR99 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-34"><a class="header" href="#summaryabstract-34">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="CS04" class=ref>
<summary class=citation>
<a id="CS04">[CS04]</a> - John F. Canny and Stephen Sorkin - <a href="https://doi.org/10.1007/978-3-540-24676-3_9" target="_blank"><cite>Practical Large-Scale Distributed Key Generation</cite></a>. - 2004. -
<button onclick="copyToClipboard('\{\{ #cite CS04 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-35"><a class="header" href="#summaryabstract-35">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="KG09" class=ref>
<summary class=citation>
<a id="KG09">[KG09]</a> - Aniket Kate and Ian Goldberg - <a href="https://doi.org/10.1109/ICDCS.2009.21" target="_blank"><cite>Distributed Key Generation for the Internet</cite></a>. - 2009. -
<button onclick="copyToClipboard('\{\{ #cite KG09 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-36"><a class="header" href="#summaryabstract-36">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="CGMA85" class=ref>
<summary class=citation>
<a id="CGMA85">[CGMA85]</a> - Benny Chor and Shafi Goldwasser and Silvio Micali and Baruch Awerbuch - <a href="https://doi.org/10.1109/SFCS.1985.64" target="_blank"><cite>Verifiable Secret Sharing and Achieving Simultaneity in the Presence
               of Faults (Extended Abstract)</cite></a>. - 1985. -
<button onclick="copyToClipboard('\{\{ #cite CGMA85 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-37"><a class="header" href="#summaryabstract-37">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="CD22" class=ref>
<summary class=citation>
<a id="CD22">[CD22]</a> - Wouter Castryck and Thomas Decru - <a href="https://eprint.iacr.org/2022/975" target="_blank"><cite>An efficient key recovery attack on {SIDH} (preliminary version)</cite></a>. - 2022. -
<button onclick="copyToClipboard('\{\{ #cite CD22 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-38"><a class="header" href="#summaryabstract-38">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="CGL06" class=ref>
<summary class=citation>
<a id="CGL06">[CGL06]</a> - Denis Xavier Charles and Eyal Z. Goren and Kristin E. Lauter - <a href="http://eprint.iacr.org/2006/021" target="_blank"><cite>Cryptographic hash functions from expander graphs</cite></a>. - 2006. -
<button onclick="copyToClipboard('\{\{ #cite CGL06 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-39"><a class="header" href="#summaryabstract-39">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="MOT20" class=ref>
<summary class=citation>
<a id="MOT20">[MOT20]</a> - Tomoki Moriya and Hiroshi Onuki and Tsuyoshi Takagi - <a href="https://doi.org/10.1007/978-3-030-64834-3_19" target="_blank"><cite>SiGamal: {A} Supersingular Isogeny-Based {PKE} and Its Application
               to a {PRF}</cite></a>. - 2020. -
<button onclick="copyToClipboard('\{\{ #cite MOT20 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-40"><a class="header" href="#summaryabstract-40">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="Sil09" class=ref>
<summary class=citation>
<a id="Sil09">[Sil09]</a> - Joseph H. Silverman - <cite>The arithmetic of elliptic curves</cite>. - 1986. -
<button onclick="copyToClipboard('\{\{ #cite Sil09 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-41"><a class="header" href="#summaryabstract-41">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="EHLMP18" class=ref>
<summary class=citation>
<a id="EHLMP18">[EHLMP18]</a> - Kirsten Eisentr{\{a}}ger and Sean Hallgren and Kristin E. Lauter and Travis Morrison and Christophe Petit - <a href="https://doi.org/10.1007/978-3-319-78372-7_11" target="_blank"><cite>Supersingular Isogeny Graphs and Endomorphism Rings: Reductions and
               Solutions</cite></a>. - 2018. -
<button onclick="copyToClipboard('\{\{ #cite EHLMP18 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-42"><a class="header" href="#summaryabstract-42">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="Was08" class=ref>
<summary class=citation>
<a id="Was08">[Was08]</a> - Laurence C. Washington - <cite>Elliptic Curves: Number Theory and Cryptography</cite>. - 2008. -
<button onclick="copyToClipboard('\{\{ #cite Was08 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-43"><a class="header" href="#summaryabstract-43">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="TZ08" class=ref>
<summary class=citation>
<a id="TZ08">[TZ08]</a> - Jean{-}Pierre Tillich and Gilles Z{\&#x27;{e}}mor - <a href="https://doi.org/10.1007/978-3-540-78967-3_15" target="_blank"><cite>Collisions for the {LPS} Expander Graph Hash Function</cite></a>. - 2008. -
<button onclick="copyToClipboard('\{\{ #cite TZ08 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-44"><a class="header" href="#summaryabstract-44">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="PLQ08" class=ref>
<summary class=citation>
<a id="PLQ08">[PLQ08]</a> - Christophe Petit and Kristin E. Lauter and Jean{-}Jacques Quisquater - <a href="https://doi.org/10.1007/978-3-540-85855-3_18" target="_blank"><cite>Full Cryptanalysis of {LPS} and Morgenstern Hash Functions</cite></a>. - 2008. -
<button onclick="copyToClipboard('\{\{ #cite PLQ08 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-45"><a class="header" href="#summaryabstract-45">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="S91" class=ref>
<summary class=citation>
<a id="S91">[S91]</a> - Claus{-}Peter Schnorr - <a href="https://doi.org/10.1007/BF00196725" target="_blank"><cite>Efficient Signature Generation by Smart Cards</cite></a>. - 1991. -
<button onclick="copyToClipboard('\{\{ #cite S91 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-46"><a class="header" href="#summaryabstract-46">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="TS21" class=ref>
<summary class=citation>
<a id="TS21">[TS21]</a> - Dmytro Tymokhanov and Omer Shlomovits - <a href="https://eprint.iacr.org/2021/1621" target="_blank"><cite>Alpha-Rays: Key Extraction Attacks on Threshold {ECDSA} Implementations</cite></a>. - 2021. -
<button onclick="copyToClipboard('\{\{ #cite TS21 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-47"><a class="header" href="#summaryabstract-47">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="CGGMP21" class=ref>
<summary class=citation>
<a id="CGGMP21">[CGGMP21]</a> - Ran Canetti and Rosario Gennaro and Steven Goldfeder and Nikolaos Makriyannis and Udi Peled - <a href="https://eprint.iacr.org/2021/060" target="_blank"><cite>{UC} Non-Interactive, Proactive, Threshold {ECDSA} with Identifiable
                  Aborts</cite></a>. - 2021. -
<button onclick="copyToClipboard('\{\{ #cite CGGMP21 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-48"><a class="header" href="#summaryabstract-48">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="BCJZ20" class=ref>
<summary class=citation>
<a id="BCJZ20">[BCJZ20]</a> - Brendel, Jacqueline and Cremers, Cas and Jackson, Dennis and Zhao, Mang - <cite>The provable security of ed25519: theory and practice</cite>. - 2021. -
<button onclick="copyToClipboard('\{\{ #cite BCJZ20 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-49"><a class="header" href="#summaryabstract-49">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="HW10" class=ref>
<summary class=citation>
<a id="HW10">[HW10]</a> - Susan Hohenberger and Brent Waters - <a href="https://doi.org/10.1007/978-3-642-13190-5_33" target="_blank"><cite>Constructing Verifiable Random Functions with Large Input Spaces</cite></a>. - 2010. -
<button onclick="copyToClipboard('\{\{ #cite HW10 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-50"><a class="header" href="#summaryabstract-50">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="Shamir79" class=ref>
<summary class=citation>
<a id="Shamir79">[Shamir79]</a> - Adi Shamir - <a href="https://doi.org/10.1145/359168.359176" target="_blank"><cite>How to Share a Secret</cite></a>. - 1979. -
<button onclick="copyToClipboard('\{\{ #cite Shamir79 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-51"><a class="header" href="#summaryabstract-51">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="BDLSY12" class=ref>
<summary class=citation>
<a id="BDLSY12">[BDLSY12]</a> - Daniel J. Bernstein and Niels Duif and Tanja Lange and Peter Schwabe and Bo{-}Yin Yang - <a href="https://doi.org/10.1007/s13389-012-0027-1" target="_blank"><cite>High-speed high-security signatures</cite></a>. - 2012. -
<button onclick="copyToClipboard('\{\{ #cite BDLSY12 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-52"><a class="header" href="#summaryabstract-52">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="KG20" class=ref>
<summary class=citation>
<a id="KG20">[KG20]</a> - Chelsea Komlo and Ian Goldberg - <a href="https://doi.org/10.1007/978-3-030-81652-0\_2" target="_blank"><cite>{FROST:} Flexible Round-Optimized Schnorr Threshold Signatures</cite></a>. - 2020. -
<button onclick="copyToClipboard('\{\{ #cite KG20 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-53"><a class="header" href="#summaryabstract-53">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="GKRRS21" class=ref>
<summary class=citation>
<a id="GKRRS21">[GKRRS21]</a> - Lorenzo Grassi and Dmitry Khovratovich and Christian Rechberger and Arnab Roy and Markus Schofnegger - <a href="https://www.usenix.org/conference/usenixsecurity21/presentation/grassi" target="_blank"><cite>Poseidon: {A} New Hash Function for Zero-Knowledge Proof Systems</cite></a>. - 2021. -
<button onclick="copyToClipboard('\{\{ #cite GKRRS21 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-54"><a class="header" href="#summaryabstract-54">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="BDPA08" class=ref>
<summary class=citation>
<a id="BDPA08">[BDPA08]</a> - Guido Bertoni and Joan Daemen and Micha{\{e}}l Peeters and Gilles Van Assche - <a href="https://doi.org/10.1007/978-3-540-78967-3\_11" target="_blank"><cite>On the Indifferentiability of the Sponge Construction</cite></a>. - 2008. -
<button onclick="copyToClipboard('\{\{ #cite BDPA08 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-55"><a class="header" href="#summaryabstract-55">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="MS78" class=ref>
<summary class=citation>
<a id="MS78">[MS78]</a> - MacWilliams, F.J. and Sloane, N.J.A. - <cite>The Theory of Error-Correcting Codes</cite>. - 1978. -
<button onclick="copyToClipboard('\{\{ #cite MS78 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-56"><a class="header" href="#summaryabstract-56">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="GRS20" class=ref>
<summary class=citation>
<a id="GRS20">[GRS20]</a> - Lorenzo Grassi and Christian Rechberger and Markus Schofnegger - <a href="https://eprint.iacr.org/2020/500" target="_blank"><cite>Proving Resistance Against Infinitely Long Subspace Trails: How to Choose the Linear Layer</cite></a>. - 2020. -
<button onclick="copyToClipboard('\{\{ #cite GRS20 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-57"><a class="header" href="#summaryabstract-57">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="RS16" class=ref>
<summary class=citation>
<a id="RS16">[RS16]</a> - Ronald L.  Rivest and Jacob C.  N.  Schuldt - <a href="https://eprint.iacr.org/2016/856" target="_blank"><cite>Spritz---a spongy RC4-like stream cipher and hash function.</cite></a>. - 2016. -
<button onclick="copyToClipboard('\{\{ #cite RS16 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-58"><a class="header" href="#summaryabstract-58">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="GLRRS20" class=ref>
<summary class=citation>
<a id="GLRRS20">[GLRRS20]</a> - Lorenzo Grassi and Reinhard Lüftenegger and Christian Rechberger and Dragos Rotaru and Markus Schofnegger - <a href="https://eprint.iacr.org/2019/1107" target="_blank"><cite>On a Generalization of Substitution-Permutation Networks: The HADES Design Strategy</cite></a>. - 2019. -
<button onclick="copyToClipboard('\{\{ #cite GLRRS20 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-59"><a class="header" href="#summaryabstract-59">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="DJRV01" class=ref>
<summary class=citation>
<a id="DJRV01">[DJRV01]</a> - Daemen, Joan,  and Rijmen, Vincent - <cite>The Wide Trail Design Strategy</cite>. - 2001. -
<button onclick="copyToClipboard('\{\{ #cite DJRV01 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-60"><a class="header" href="#summaryabstract-60">Summary/Abstract</a></h1>
<div>We explain the theoretical background of the wide trail design strategy, which was used to design Rijndael, the Advanced Encryption Standard (AES). In order to facilitate the discussion, we introduce our own notation to describe differential and linear cryptanalysis. We present a block cipher structure and prove bounds on the resistance against differential and linear cryptanalysis.</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="KS22" class=ref>
<summary class=citation>
<a id="KS22">[KS22]</a> - Abhiram Kothapalli and Srinath Setty - <a href="https://eprint.iacr.org/2022/1758" target="_blank"><cite>{SuperNova}: Proving universal machine executions without universal circuits</cite></a>. - 2022. -
<button onclick="copyToClipboard('\{\{ #cite KS22 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-61"><a class="header" href="#summaryabstract-61">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
